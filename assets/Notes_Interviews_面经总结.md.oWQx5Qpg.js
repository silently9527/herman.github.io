import{_ as s,c as i,o as a,a4 as l}from"./chunks/framework.D1poPhlk.js";const n="/assets/HTTPS.Co7iHWcn.png",y=JSON.parse('{"title":"","description":"","frontmatter":{"updateTime":"2023-09-17 15:12","desc":"常考八股文收录,适合中国宝宝体质的八股速通","tags":"八股","outline":2},"headers":[],"relativePath":"Notes/Interviews/面经总结.md","filePath":"Notes/Interviews/面经总结.md","lastUpdated":1723472907000}'),t={name:"Notes/Interviews/面经总结.md"},e=l(`<h2 id="javascript-相关" tabindex="-1">JavaScript 相关 <a class="header-anchor" href="#javascript-相关" aria-label="Permalink to &quot;JavaScript 相关&quot;">​</a></h2><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><ul><li>基本类型：Number , String , Boolean , Symbol , BigInt , null, undefined</li><li>引用类型：Object( Array , Function... )</li></ul><h4 id="区分-null-和-undefined" tabindex="-1">区分 null 和 undefined <a class="header-anchor" href="#区分-null-和-undefined" aria-label="Permalink to &quot;区分 null 和 undefined&quot;">​</a></h4><ol><li><code>null</code> 可以理解为: 对象不存在. 当某个方法返回值是一个对象，但对象不存在时返回的就是 <code>null</code>.</li></ol><p>例如: <code>document.querySelector()</code>返回的是 DOM 对象，当没有查询到时返回的就是 <code>null</code>.</p><ol start="2"><li><code>undefined</code> 可以理解为: 缺少值.</li></ol><ul><li>变量定义了但是没有赋值</li><li>访问对象中不存在的属性</li><li>函数没有返回值时的默认值</li></ul><p>具体说明可以参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" target="_blank" rel="noreferrer">JavaScript 数据类型和数据结构 - JavaScript | MDN (mozilla.org)</a></p><h4 id="判断数据类型" tabindex="-1">判断数据类型 <a class="header-anchor" href="#判断数据类型" aria-label="Permalink to &quot;判断数据类型&quot;">​</a></h4><ol><li><p><code>typeof xxx</code>可以判断出基本类型的变量（例外:<code>null</code>显示为<code>object</code>）.</p></li><li><p><code>xxx instanceof yyy</code>可以判断 x 是不是 y (构造函数) 的实例.</p></li></ol><blockquote><p>原理是判断 x 的原型链上是否存在 y 的 prototype</p><p>参考 API 文档: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noreferrer">instanceof - JavaScript | MDN (mozilla.org)</a></p></blockquote><ol start="3"><li><code>Objetc.prototype.toString.call(xxx)</code> 可以区分不同的引用类型.</li></ol><p>结合 1 与 3 可以得到以下代码:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;object&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\[</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">object (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="深拷贝与浅拷贝" tabindex="-1">深拷贝与浅拷贝 <a class="header-anchor" href="#深拷贝与浅拷贝" aria-label="Permalink to &quot;深拷贝与浅拷贝&quot;">​</a></h3><p>该部分内容可结合 <code>深浅拷贝.js</code> 文件配合食用.</p><ul><li>赋值: 原始类型相互独立，引用类型互相干扰。</li><li>浅拷贝：引用类型中的原始类型相互独立，但是引用类型任然会受影响.</li><li>深拷贝: 完全独立.</li></ul><p>实现浅拷贝的常见方法: 1. 拓展运算符... ; 2. <code>Object.assign({},原始对象)</code></p><p>实现深拷贝的常见方法:</p><ul><li><code>JSON.parse(JSON.stringfy(obj))</code>:缺点是无法识别函数和正则对象.</li><li>手写深拷贝，利用构造函数开辟新的空间，再递归遍历原始对象去赋值.</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RegExp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RegExp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;object&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 防止循环引用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (hash.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cloneObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  hash.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, cloneObj);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 确保只拷贝自身的属性而非继承的属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasOwnProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)) cloneObj[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj[key], hash);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cloneObj;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="不知道怎么分类" tabindex="-1">不知道怎么分类 <a class="header-anchor" href="#不知道怎么分类" aria-label="Permalink to &quot;不知道怎么分类&quot;">​</a></h2><h3 id="cookie-localstorage-sessionstorage" tabindex="-1">cookie / localStorage / sessionStorage <a class="header-anchor" href="#cookie-localstorage-sessionstorage" aria-label="Permalink to &quot;cookie / localStorage / sessionStorage&quot;">​</a></h3><ul><li>cookie 的本职工作并非本地存储，而是维持状态，因为 HTTP 协议是无状态的，不会保存客户端与服务器之间的通信状态。</li><li>localStorage 是持久化的本地存储，存储在其中的数据不会过期，除非手动删除，通常用于提升网页首屏渲染速度。</li><li>sessionStorage 是临时性的本地存储，数据仅存在于一次会话（页面）中，关闭页面存储的数据就会被释放。</li></ul><p>参考资料：<a href="https://juejin.cn/post/6844903812092674061" target="_blank" rel="noreferrer">深入了解浏览器存储--从 cookie 到 WebStorage、IndexedDB - 掘金 (juejin.cn)</a></p><h3 id="从输入-url-到页面展现" tabindex="-1">从输入 URL 到页面展现 <a class="header-anchor" href="#从输入-url-到页面展现" aria-label="Permalink to &quot;从输入 URL 到页面展现&quot;">​</a></h3><ol><li>dns 解析获取目标 IP</li><li>TCP 封装 HTTP 报文，通过三次握手建立 TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器进行同源策略的判定</li><li>浏览器解析渲染页面</li></ol><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析出 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个结点的信息 =&gt; 绘制页面</li></ul><ol start="7"><li>四次挥手断开 TCP 连接</li></ol><h3 id="强缓存与协商缓存" tabindex="-1">强缓存与协商缓存 <a class="header-anchor" href="#强缓存与协商缓存" aria-label="Permalink to &quot;强缓存与协商缓存&quot;">​</a></h3><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><p>强缓存的含义是，客户端发送请求时，会先访问缓存数据库，存在就直接返回，否则再向服务器发送请求。</p><p>可以造成强缓存的字段是 <code>cache-control</code> 和 <code>Expires</code>.</p><p><strong>Expires</strong>表示缓存到期的时间，是一个绝对的时间.</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Expires</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Thu, 10 Nov 2017 08:45:11 GMT</span></span></code></pre></div><p>缺点：</p><ol><li><p>由于是绝对时间，考虑到时差/误差或者客户端自行修改等因素，都会造成客户端与服务器端时间不一致，从而导致缓存失效。</p></li><li><p>字段表示过于复杂，很容易因为非法属性值从而设置失效</p></li></ol><p><strong>cache-control</strong> 则是通过设置相对时间来修正 <code>Expires</code> 的缺点.</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-control</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">max-age=2592000</span></span></code></pre></div><p>更多常用的字段</p><ul><li><p><code>max-age</code>：即最大有效时间，在上面的例子中我们可以看到</p></li><li><p><code>must-revalidate</code>：如果超过了 <code>max-age</code> 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。</p></li><li><p><code>no-cache</code>：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。</p></li><li><p><code>no-store</code>: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。</p></li><li><p><code>public</code>：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)</p></li><li><p><code>private</code>：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</p></li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><p>当强制缓存失效（超过规定时间）时，就需要使用协商缓存，由服务器决定缓存内容是否失效。</p><p>大致流程如下：浏览器先请求缓存数据库返回一个缓存标识，随后携带这个缓存标识与浏览器通讯，如果未失效则返回 304 继续使用，否则返回新的数据与缓存规则。</p><p>协商缓存具有两组字段：</p><p><strong>Last-Modified &amp; If-Modified-Since</strong></p><ol><li>服务器通过 <code>Last-Modified</code> 告知客户端，资源最后一次被修改的时间.</li><li>浏览器将这个值和内容一起记录在缓存之中.</li><li>下一次请求相同资源而强缓存失效时，会在请求头中设置 <code>If-Modified-Since</code> 的值为缓存中记录的 <code>Last-Modified</code>.</li><li>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</li></ol><p>缺陷如下：</p><ul><li>如果资源更新的速度是秒以下的单位，那么该缓存是无法使用的。</li><li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能并没有改变，但仍然会被认为改变了。</li></ul><p><strong>Etag &amp; If-None-Match</strong></p><p>为了解决上述问题，出现了这一组新的字段。</p><p><code>Etag</code>存储文件的特殊标识（通常由 hash 生成），流程基本一致。</p><h4 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>如果有强制缓存且未失效，则使用强制缓存，不请求服务器，状态码均为 200.</p><p>如果有强制缓存但已失效，则使用协商缓存，比较 时间 或 Etag 确定是 304 还是 200.</p><h2 id="css-相关" tabindex="-1">CSS 相关 <a class="header-anchor" href="#css-相关" aria-label="Permalink to &quot;CSS 相关&quot;">​</a></h2><h3 id="绘制三角形" tabindex="-1">绘制三角形 <a class="header-anchor" href="#绘制三角形" aria-label="Permalink to &quot;绘制三角形&quot;">​</a></h3><p>借助 <code>border</code> 的宽度以及 <code>transparent</code>透明色</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> transparent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="文本溢出" tabindex="-1">文本溢出 <a class="header-anchor" href="#文本溢出" aria-label="Permalink to &quot;文本溢出&quot;">​</a></h3><p><strong>单行文本溢出</strong></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 强制单行显示 */</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">white-space</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: nowrap;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 溢出部分隐藏 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">overflow: hidden;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 超出部分用省略号替代 */</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">text-overflow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ellipsis;</span></span></code></pre></div><p><strong>多行溢出</strong></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; // 高度要设置得合理，或者不设置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  overflow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  text-overflow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ellipsis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-webkit-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -webkit-line-clamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -webkit-box-orient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vertical</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="清除浮动" tabindex="-1">清除浮动 <a class="header-anchor" href="#清除浮动" aria-label="Permalink to &quot;清除浮动&quot;">​</a></h3><ol><li>给父元素添加 <code>overflow:hidden</code></li><li>给父元素设置伪元素</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix:after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  visibility</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zoom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="响应式布局" tabindex="-1">响应式布局 <a class="header-anchor" href="#响应式布局" aria-label="Permalink to &quot;响应式布局&quot;">​</a></h3><ol><li>媒体查询</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@media</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> screen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> and(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max-width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /*样式相关*/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>利用相对单位 rem / 百分比 / vieport ，可以利用 js 动态计算 rem 的值</li></ol><h3 id="opacity-visibility-display-元素隐藏" tabindex="-1">opacity / visibility / display 元素隐藏 <a class="header-anchor" href="#opacity-visibility-display-元素隐藏" aria-label="Permalink to &quot;opacity / visibility / display 元素隐藏&quot;">​</a></h3><ul><li><code>opacity:0</code> 占据空间，可以点击，可以设置过渡动画，（既不回流也不重绘，触发的是 CSS3 硬件加速）</li></ul><blockquote><p>CSS3 硬件加速通过将特定的 CSS 属性应用于元素，例如<code>transform</code>、<code>opacity</code>、<code>filter</code>等，浏览器会将这些元素的渲染和动画操作交给 GPU 来处理，从而提高性能和流畅度。</p></blockquote><ul><li><code>visibility:hidden</code>占据空间，不可点击，（触发重绘）</li><li><code>display:none</code> 不占据空间，会导致页面回流</li></ul><h3 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h3><p>回流： 对 DOM 的修改引发了 DOM 几何尺寸的改变。</p><p>重绘： 对 DOM 的修改导致了样式的变化而尺寸没变。</p><p>回流一定引发重绘，重绘不一定引发回流。</p><p>参考文档：<a href="https://juejin.cn/post/6844903815758479374?searchId=202307221136419F779DBC144D253DB3E5" target="_blank" rel="noreferrer">你不知道的浏览器页面渲染机制 - 掘金 (juejin.cn)</a></p><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><p><strong>同源策略三要素</strong>: 协议 ， 域名 ， 端口</p><p>跨域问题仅发生在浏览器之中，浏览器向服务器发起请求，服务器正常响应，浏览器收到响应报文后进行跨域校验。</p><p>处理跨域的三种方式: JSONP , CORS , 代理</p><ol><li><p><code>JSONP</code>: 利用<code>&lt;script&gt;</code>标签的 src 属性发起跨域请求，浏览器需要返回一段类似 <code>handleResponse({ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25 });</code> 的 js 代码，其中 <code>handleResponse</code> 为前端编写的回调函数，中间的参数为响应的数据。</p></li><li><p><code>CORS</code>：服务端设置响应头:</p><ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Max-Age</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Allow-Headers</code></li><li><code>Access-Control-Allow-Credentials</code></li></ul></li><li><p>代理： 由于跨域问题只发生在浏览器，可以考虑利用一个同源的代理服务器进行请求转发。</p></li></ol><h2 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><p><strong>执行顺序</strong>：1. 从上到下一行一行执行. 2. 先执行同步代码，再执行异步代码. 3. 如果报错则停止执行后续代码.</p><p>异步代码又分为：</p><ul><li>宏任务: <code>setTimeout</code> , <code>setInterval</code>, Ajax 等等由浏览器发起的（）</li><li>微任务: <code>Promise</code>的回调函数(Promise 本身是同步的)，<code>async / await</code></li></ul><p>事件循环流程：</p><ol><li>清空 call stack 中的同步代码</li><li>执行微任务队列中的微任务</li><li>执行一个宏任务 A</li><li>执行由宏任务 A 产生的所有微任务</li><li>执行下一个宏任务...</li><li>所有宏任务执行完毕后，再执行由 A 产生的宏任务.</li></ol><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A[开始]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A --&gt; B[清空 call stack]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt; C[执行微任务队列中的微任务]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt; D[执行一个宏任务 A]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt; E[执行宏任务 A 产生的微任务]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    E --&gt; F[执行下一个宏任务]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    F --&gt; G{宏任务队列为空?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    G -- 是 --&gt; H[执行由上一次宏任务产生的微任务]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    H --&gt; F</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    G -- 否 --&gt; D</span></span></code></pre></div><h2 id="词法作用域" tabindex="-1">词法作用域 <a class="header-anchor" href="#词法作用域" aria-label="Permalink to &quot;词法作用域&quot;">​</a></h2><ol><li>函数外部无法访问函数内部定义的变量</li><li>在嵌套函数中，内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</li><li>相同作用域中的同名变量，内部变量会覆盖外部变量</li></ol><h2 id="this-指向" tabindex="-1">this 指向 <a class="header-anchor" href="#this-指向" aria-label="Permalink to &quot;this 指向&quot;">​</a></h2><ol><li>全局作用域中, this 指向全局对象.</li><li>在函数之中, this 的指向取决于函数的调用方式 <ol><li>如果函数作为对象的方法被调用， this 指向调用该方法的对象.</li><li>如果函数使用 call / bind/ apply 进行调用,this 指向作为参数传递的对象.</li><li>如果函数使用 new 关键字调用, this 指向新创建的实例对象.</li><li>如果函数被直接调用，则 this 指向全局对象(严格模式下为 undefined)</li></ol></li></ol><h2 id="登录鉴权" tabindex="-1">登录鉴权 <a class="header-anchor" href="#登录鉴权" aria-label="Permalink to &quot;登录鉴权&quot;">​</a></h2><h2 id="权限路由" tabindex="-1">权限路由 <a class="header-anchor" href="#权限路由" aria-label="Permalink to &quot;权限路由&quot;">​</a></h2><h2 id="防抖节流" tabindex="-1">防抖节流 <a class="header-anchor" href="#防抖节流" aria-label="Permalink to &quot;防抖节流&quot;">​</a></h2><h2 id="虚拟滚动和无限滚动" tabindex="-1">虚拟滚动和无限滚动 <a class="header-anchor" href="#虚拟滚动和无限滚动" aria-label="Permalink to &quot;虚拟滚动和无限滚动&quot;">​</a></h2><h2 id="性能优化-lighthouse" tabindex="-1">性能优化 lighthouse <a class="header-anchor" href="#性能优化-lighthouse" aria-label="Permalink to &quot;性能优化 lighthouse&quot;">​</a></h2><h2 id="http-与-https" tabindex="-1">HTTP 与 HTTPS <a class="header-anchor" href="#http-与-https" aria-label="Permalink to &quot;HTTP 与 HTTPS&quot;">​</a></h2><p><strong>HTTP 存在的问题</strong></p><ol><li>HTTP 采用明文传输，内容可能被窃听.</li><li>无法证明报文的完整性，可能遭遇篡改.</li><li>不验证通信方的身份，有可能遭遇伪装.</li></ol><p><strong>HTTPS 工作流程</strong></p><p><img src="`+n+'" alt="HTTPS"></p><p>通信过程可以分为两个阶段： TLS 握手阶段和数据传输阶段.</p><p>在 TLS 握手阶段，通过非对称加密算法来实现身份验证 (数字证书) 和密钥交换.</p><p>在数据传输阶段, 使用对称加密算法加密通信内容，同时使用某种算法生成数字签名用于校验内容的完整性.</p><p>**非对称加密简述:**公钥用于加密，私钥用于解密，两个密钥是相关联的，但是无法从一个推导出另一个.</p><h2 id="计网" tabindex="-1">计网 <a class="header-anchor" href="#计网" aria-label="Permalink to &quot;计网&quot;">​</a></h2><h3 id="tcp-四次挥手" tabindex="-1">TCP 四次挥手 <a class="header-anchor" href="#tcp-四次挥手" aria-label="Permalink to &quot;TCP 四次挥手&quot;">​</a></h3><blockquote><p>A: FIN</p><p>B: ACK</p><p>B: FIN</p><p>A: ACK</p><p>四次原因：服务端可能还有数据没有发送完，需要四次挥手来保证双方数据的完整性.</p></blockquote>',114),h=[e];function p(k,r,d,o,E,c){return a(),i("div",null,h)}const u=s(t,[["render",p]]);export{y as __pageData,u as default};
