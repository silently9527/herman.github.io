import{_ as a,c as n,o as s,aa as e}from"./chunks/framework.d_Ke7vMG.js";const g=JSON.parse('{"title":"02 Java8为什么需要引入新的日期和时间库","description":"","frontmatter":{"title":"02 Java8为什么需要引入新的日期和时间库","author":"Herman","updateTime":"2021-08-14 13:41","desc":"Java8为什么需要引入新的日期和时间库","categories":"Java","tags":"Java8新特性","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/01 Java/02 Java8为什么需要引入新的日期和时间库.md","filePath":"Notes/No2TechColumn/01 Java/02 Java8为什么需要引入新的日期和时间库.md","lastUpdated":1724592993000}'),t={name:"Notes/No2TechColumn/01 Java/02 Java8为什么需要引入新的日期和时间库.md"},p=e(`<h2 id="" tabindex="-1"><img src="https://cdn.jsdelivr.net/gh/silently9527/images//3970086690-5fafd0c6e2df8_articlex" alt=""> <a class="header-anchor" href="#" aria-label="Permalink to &quot;![](https://cdn.jsdelivr.net/gh/silently9527/images//3970086690-5fafd0c6e2df8_articlex)&quot;">​</a></h2><h4 id="java8为什么需要引入新的日期和时间库" tabindex="-1">Java8为什么需要引入新的日期和时间库 <a class="header-anchor" href="#java8为什么需要引入新的日期和时间库" aria-label="Permalink to &quot;Java8为什么需要引入新的日期和时间库&quot;">​</a></h4><ol><li>Date日期输出可读性较差<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Date date = new Date();</span></span>
<span class="line"><span>System.out.println(date);</span></span></code></pre></div>打印输出的结果：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Sat Nov 14 11:03:41 CST 2020</span></span></code></pre></div></li><li>Date日期的解析、格式化通过JDK自带的api实现较为麻烦，通常会使用第三方的日期时间库，比如：<code>joda-time</code>, <code>commons-lang</code></li></ol><hr><h4 id="java8中提供了哪些日期和时间类" tabindex="-1">Java8中提供了哪些日期和时间类 <a class="header-anchor" href="#java8中提供了哪些日期和时间类" aria-label="Permalink to &quot;Java8中提供了哪些日期和时间类&quot;">​</a></h4><p>在java.time包中提供了很多新的类，通常主要使用到的是<code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZoneId</code>, <code>ZoneDateTime</code>; 关系图如下： <img src="https://cdn.jsdelivr.net/gh/silently9527/images//1999023484-5faf611315cae_articlex" alt=""></p><ul><li><p>LocaDate这个类本身不包含时间和时区信息，只包含了日期信息；提供了很多方法来获取常用的值：星期几，几月 ...</p><p>常用的静态构造<code>LocaDate</code>方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDate.of(2020, 11, 14); //指定年月日</span></span>
<span class="line"><span>LocalDate.of(2020, Month.NOVEMBER, 14); //指定年月日 使用Month枚举类</span></span>
<span class="line"><span>LocalDate.ofYearDay(2020, 10); //2020年第10天 =&gt; 2020-01-10</span></span>
<span class="line"><span>LocalDate.now(); //当前时间</span></span>
<span class="line"><span>System.out.println(LocalDate.now()); // 比较好的可读性输出 =&gt; 2020-11-14</span></span></code></pre></div><p><code>LocaDate</code>常用实例方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDate now = LocalDate.of(2020, 11, 14);</span></span>
<span class="line"><span>System.out.println(now.getMonth()); //月份的枚举 =&gt; NOVEMBER</span></span>
<span class="line"><span>System.out.println(now.getMonthValue()); //月份的数字 =&gt; 11</span></span>
<span class="line"><span>System.out.println(now.getDayOfMonth()); //几号 =&gt; 14</span></span>
<span class="line"><span>System.out.println(now.getDayOfYear()); // 一年中的第几天 =&gt; 319</span></span>
<span class="line"><span>System.out.println(now.getDayOfWeek()); // 周几枚举 =&gt; SATURDAY</span></span>
<span class="line"><span>System.out.println(now.lengthOfMonth()); //本月多少天 =&gt; 30</span></span>
<span class="line"><span>System.out.println(now.lengthOfYear()); //本年多少天 =&gt; 366</span></span></code></pre></div></li><li><p>LocalTime只包含时间信息</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalTime.of(12, 9, 10); //时、分、秒</span></span>
<span class="line"><span>LocalTime.now();</span></span>
<span class="line"><span>LocalTime time = LocalTime.of(12, 9, 10);</span></span>
<span class="line"><span>System.out.println(time.getHour());</span></span>
<span class="line"><span>System.out.println(time.getMinute());</span></span>
<span class="line"><span>System.out.println(time.getSecond());</span></span></code></pre></div></li><li><p>LocalDateTime 从这个类的名字可以看出是合并了<code>LocalDate</code>, <code>LocalTime</code>，只包含日期和时间，不包含时区信息 构造的方式，可以直接使用静态方法创建，也可以通过<code>LocalDate</code>，<code>LocalTime</code>合并</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDateTime.of(LocalDate.now(), LocalTime.now());</span></span>
<span class="line"><span>LocalDateTime.of(2020, 11, 14, 13, 10, 50);</span></span>
<span class="line"><span>LocalDate.now().atTime(LocalTime.now());</span></span>
<span class="line"><span>LocalTime.now().atDate(LocalDate.now());</span></span>
<span class="line"><span>LocalDateTime.now();</span></span></code></pre></div><p>由于<code>LocalDateTime</code>是<code>LocalDate</code>, <code>LocalTime</code>的合并，所以<code>LocalDate</code>, <code>LocalTime</code>有的实例方法，基本在<code>LocalDateTime</code>中都可以找到</p></li><li><p>ZoneId 用来替代老版本<code>TimeZone</code>, 每个<code>ZoneId</code>都有一个特定的地区标识;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  ZoneId.of(&quot;Asia/Shanghai&quot;);</span></span>
<span class="line"><span>  ZoneId.systemDefault()</span></span></code></pre></div><p>查看所有的地区标识可以进入到<code>ZoneId</code>源码</p></li><li><p>ZoneDateTime带有日期、时间、时区信息，是<code>LocalDateTime</code>和<code>ZoneId</code>的组合</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());</span></span>
<span class="line"><span>ZonedDateTime.of(LocalDate.now(),LocalTime.now(),ZoneId.of(&quot;Asia/Shanghai&quot;));</span></span></code></pre></div></li></ul><p>经常我们会遇到需要求两个时间之间相差的时间, 如何实现呢？ Java8也提供给了相应的API支持， <code>Duration</code>、<code>Period</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Duration between = Duration.between(LocalTime.of(13, 0), LocalTime.of(14, 0)); </span></span>
<span class="line"><span>between.getSeconds(); //返回两个时间相差的秒数 =&gt; 3600</span></span></code></pre></div><p><code>Duration</code>是通过秒和毫秒来记录时间的长短，所以只能处理两个<code>LocalTime</code>, <code>DateLocalTime</code>, <code>ZonedDateTime</code>; 如果传入的是<code>LocalDate</code>，将会抛出异常</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: Seconds</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	at java.time.LocalDate.until(LocalDate.java:1614)</span></span>
<span class="line"><span>	at java.time.Duration.between(Duration.java:475)</span></span>
<span class="line"><span>	at com.haixue.crm.stock.service.LocalTest.testDate(LocalTest.java:121)</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span>
<span class="line"><span>	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span>
<span class="line"><span>	at java.lang.reflect.Method.invoke(Method.java:498)</span></span>
<span class="line"><span>	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span></span>
<span class="line"><span>	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span></span>
<span class="line"><span>	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span></span>
<span class="line"><span>	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span></span>
<span class="line"><span>	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</span></span>
<span class="line"><span>	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span></span>
<span class="line"><span>	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span></span>
<span class="line"><span>	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span></span>
<span class="line"><span>	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)</span></span>
<span class="line"><span>	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)</span></span>
<span class="line"><span>	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)</span></span>
<span class="line"><span>	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</span></span></code></pre></div><p>在这种情况下就可以使用<code>Period</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Period between1 = Period.between(LocalDate.of(2020, 11, 13), LocalDate.of(2020, 11, 13));</span></span>
<span class="line"><span>between1.getDays();  //返回相差的天数 =&gt; 1</span></span></code></pre></div><hr><h4 id="时间日期的更高级的操作" tabindex="-1">时间日期的更高级的操作 <a class="header-anchor" href="#时间日期的更高级的操作" aria-label="Permalink to &quot;时间日期的更高级的操作&quot;">​</a></h4><ul><li>以为对时间日期的修改增加减少都是通过第三方依赖包操作，现在原生API已经支持</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDate now2 = LocalDate.of(2020, 11, 13);</span></span>
<span class="line"><span>System.out.println(now2.plusDays(2));       //加2天   =&gt; 2020-11-15</span></span>
<span class="line"><span>System.out.println(now2.plusMonths(1));     //加1月   =&gt; 2020-12-13</span></span>
<span class="line"><span>System.out.println(now2.plusWeeks(1));      //加一周   =&gt; 2020-11-20</span></span>
<span class="line"><span>System.out.println(now2.minusDays(1));      //减一天   =&gt; 2020-11-12</span></span>
<span class="line"><span>System.out.println(now2.minusMonths(1));    //减一月   =&gt; 2020-10-13</span></span>
<span class="line"><span>System.out.println(now2.minusYears(1));     //减一年   =&gt; 2019-11-13</span></span>
<span class="line"><span>System.out.println(now2.withYear(2021));    //修改年   =&gt; 2021-11-13</span></span></code></pre></div><ul><li>有时候我们会遇到需要取本月的最后一天、本月的第一天、调整日期到下一个周日... ;这些需求也能够通过使用<code>TemporalAdjuster</code>很好的实现，<code>TemporalAdjuster</code> 能够实现很多定制化的日期操作，Java8在<code>TemporalAdjusters</code>已经给提供了默认的很多实现。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDate now3 = LocalDate.of(2020, 11, 13);</span></span>
<span class="line"><span>System.out.println(now3.with(TemporalAdjusters.firstDayOfYear())); // 本年的第一天 =&gt; 2020-01-01</span></span>
<span class="line"><span>System.out.println(now3.with(TemporalAdjusters.next(DayOfWeek.MONDAY))); //下一个周一 =&gt; 2020-11-16</span></span>
<span class="line"><span>System.out.println(now3.with(TemporalAdjusters.lastDayOfMonth())); // 本月的最后一天 =&gt; 2020-11-30</span></span>
<span class="line"><span>System.out.println(now3.with(TemporalAdjusters.lastDayOfYear())); // 本年的最后一天 =&gt; 2020-12-31</span></span></code></pre></div><ul><li>自定义<code>TemporalAdjuster</code>实现获取当天的开始时间和当天的最后时间</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 13, 10, 10, 10);</span></span>
<span class="line"><span>System.out.println(localDateTime);</span></span>
<span class="line"><span>System.out.println(localDateTime.with((temporal) -&gt; </span></span>
<span class="line"><span>    temporal.with(ChronoField.SECOND_OF_DAY, 0))); // 当天的凌晨 =&gt; 2020-11-13T00:00</span></span>
<span class="line"><span>System.out.println(localDateTime.with((temporal) -&gt;</span></span>
<span class="line"><span>    temporal.with(ChronoField.SECOND_OF_DAY, temporal.range(ChronoField.SECOND_OF_DAY).getMaximum()))); // 当天的最后一刻时间 =&gt; 2020-11-13T23:59:59</span></span></code></pre></div><h4 id="解析、格式化" tabindex="-1">解析、格式化 <a class="header-anchor" href="#解析、格式化" aria-label="Permalink to &quot;解析、格式化&quot;">​</a></h4><p>对日期的字符串解析和格式化的操作是常用的，首先看下不用第三方包如何简单的实现日期解析</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>System.out.println(LocalDateTime.parse(&quot;2020-11-14T20:50:00&quot;)); // 输出：2020-11-14T20:50</span></span>
<span class="line"><span>System.out.println(LocalDateTime.parse(&quot;2020/11/14 20:50:00&quot;,</span></span>
<span class="line"><span>        DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;))); // 输出：2020-11-14T20:50</span></span></code></pre></div><p>实现格式化同样也简单</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LocalDate now4 = LocalDate.of(2020, 11, 13);</span></span>
<span class="line"><span>System.out.println(now4.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;))); //输出：2020/11/13</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LocalDateTime localDateTime2 = LocalDateTime.of(2020, 11, 13, 10, 10, 10);</span></span>
<span class="line"><span>System.out.println(localDateTime2.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;))); //输出：2020/11/13 10:10:10</span></span></code></pre></div>`,26),l=[p];function o(i,c,r,d,u,h){return s(),n("div",null,l)}const v=a(t,[["render",o]]);export{g as __pageData,v as default};
