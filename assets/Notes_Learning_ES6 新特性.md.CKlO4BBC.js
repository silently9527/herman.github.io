import{_ as e,c as l,o as a,a4 as o}from"./chunks/framework.D1poPhlk.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{"updateTime":"2023-09-16 22:00","desc":"ES6新特性记录，来源于蓝桥杯备赛课程","tags":"ES6","outline":"deep"},"headers":[],"relativePath":"Notes/Learning/ES6 新特性.md","filePath":"Notes/Learning/ES6 新特性.md","lastUpdated":1723472907000}'),i={name:"Notes/Learning/ES6 新特性.md"},r=o('<h2 id="_1-数组" tabindex="-1">1.数组 <a class="header-anchor" href="#_1-数组" aria-label="Permalink to &quot;1.数组&quot;">​</a></h2><h3 id="find" tabindex="-1">[find] <a class="header-anchor" href="#find" aria-label="Permalink to &quot;[find]&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noreferrer">find()</a> 方法是用于从数组中寻找一个符合指定条件的值，该方法返回的是第一个符合条件的元素，如果没找到，则返回 undefined.</p><p>语法格式: <code>array.find(callback(value, index, arr), thisValue);</code></p><p>参数说明如下:</p><ul><li><code>callback</code> 是数组中每个元素执行的回调函数。</li><li><code>value</code> 是当前元素的值，它是一个必须参数。</li><li><code>index</code> 是数组元素的下标，它是一个可选参数。</li><li><code>arr</code> 是被 find() 方法操作的数组，它是一个可选参数。</li><li><code>thisValue</code> 是执行回调时用作 this 的对象，它是一个可选参数。</li></ul><blockquote><p>findIndex()方法类似,只不过返回值为元素下标</p></blockquote><h3 id="fill" tabindex="-1">[fill] <a class="header-anchor" href="#fill" aria-label="Permalink to &quot;[fill]&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noreferrer">fill()</a> 方法是用指定的值来填充原始数组的元素。</p><p>语法格式:<code>array.fill(value, start, end);</code></p><p>其参数说明如下：</p><ul><li><code>value</code> 是用来填充数组的值，它是一个必须参数。</li><li><code>start</code> 是被填充数组的索引起始值，它是一个可选参数。</li><li><code>end</code> 是被填充数组的索引结束值，它是一个可选参数。</li></ul><h3 id="遍历方法" tabindex="-1">遍历方法 <a class="header-anchor" href="#遍历方法" aria-label="Permalink to &quot;遍历方法&quot;">​</a></h3><ul><li><p><code>entries()</code>方法以<strong>键/值对</strong>的形式返回数组的 [index,value]，也就是索引和值。</p></li><li><p><code>keys()</code>方法只返回数组元素的键值也就是元素对应的索引，不会返回其值。</p></li><li><p><code>values()</code>方法返回的是每个键对应的值。</p></li></ul><p>可通过如下代码遍历上述方法的返回结果: <code>for(let term in arr.keys() )</code></p><h3 id="拓展运算符" tabindex="-1">拓展运算符[...] <a class="header-anchor" href="#拓展运算符" aria-label="Permalink to &quot;拓展运算符[...]&quot;">​</a></h3><ul><li>可以使用扩展运算符将一个对象的全部属性插入到另一个对象中，来创建一个新的对象。</li><li>可以使用扩展运算符给对象添加属性。</li><li>可以使用扩展运算符合并两个新对象。</li></ul><h2 id="_2-函数" tabindex="-1">2.函数 <a class="header-anchor" href="#_2-函数" aria-label="Permalink to &quot;2.函数&quot;">​</a></h2><ul><li>在函数中直接设置默认值 / 使用函数作为默认值</li><li>解构参数</li><li>rest 参数(与拓展运算符写法相同),用 rest 来获取函数的多余参数,接收可变的参数列表.</li><li>箭头函数: 箭头函数的 this 指向是其上下文的 this，没有方法可以改变其指向.</li></ul><h2 id="_3-类" tabindex="-1">3.类 <a class="header-anchor" href="#_3-类" aria-label="Permalink to &quot;3.类&quot;">​</a></h2><ul><li>使用 <code>class</code> 关键字来声明类。</li><li>使用 <code>extends</code> 和 <code>super</code> 关键字来实现类的继承。</li><li>使用 <code>static</code> 关键字来定义静态属性和静态方法，使用 <code>#</code> 来定义私有属性和私有方法。</li><li>使用 <code>new.target</code> 来判断构造函数的调用方式。</li></ul><blockquote><p>当我们想写不能被实例化，必须在继承后才能使用的类时，我们可以用 <code>new.target</code> 属性，做为限制其不能被实例化（new）的条件。</p></blockquote><h2 id="_4-对象" tabindex="-1">4.对象 <a class="header-anchor" href="#_4-对象" aria-label="Permalink to &quot;4.对象&quot;">​</a></h2><ul><li>对象字面量： <ul><li>属性的简洁表示法: 属性值的变量名与属性名想用可省略</li><li>方法的简洁表示法: 可直接写方法,不用再写function关键字</li><li>属性名表达式: 可以用表达式 / 模板字面量(即反引号)作为属性名.</li></ul></li><li>对象的扩展运算符: 与数组类似，能实现拷贝 / 合并 / 添加属性等操作</li><li>对象的新增方法 <ul><li><code>Object.is</code>：判断两个值是否相等。 比<code>===</code>更精确一点</li><li><code>Object.assign</code>：合并多个对象。（同名属性会被覆盖，且为浅拷贝）</li></ul></li></ul><h2 id="_5-set-和-map" tabindex="-1">5.[Set] 和 [Map] <a class="header-anchor" href="#_5-set-和-map" aria-label="Permalink to &quot;5.[Set] 和 [Map]&quot;">​</a></h2><ul><li>Set 是一个可以存储数据的对象，你可以在其中添加或者删除数据，并循环访问 Set。但是 Set 中没有索引，也不能存放重复的值，数组与之相反。</li><li>Map 可以创建任意数据类型的键值对，打破了对象键名类型限制的局限性。</li><li>Set 通过<code>add</code>添加元素,Map 通过<code>set</code>添加元素,通过<code>get</code>获取值</li><li>通用方法: <code>delete(),has(),clear(),forEach()</code></li></ul><h2 id="_6-异步编程" tabindex="-1">6.异步编程 <a class="header-anchor" href="#_6-异步编程" aria-label="Permalink to &quot;6.异步编程&quot;">​</a></h2><ul><li><code>Promise(reslove,reject)</code></li><li><code>async</code>关键字修饰的函数将返回一个Promise对象,<code>await</code>关键字会等异步请求完成后才执行.</li></ul><h2 id="_7-模块化" tabindex="-1">7.模块化 <a class="header-anchor" href="#_7-模块化" aria-label="Permalink to &quot;7.模块化&quot;">​</a></h2><ul><li>输出接口: <code>export {name}</code></li><li>输入接口: <code>import {} form &quot;url&quot;</code></li></ul><h2 id="_8-proxy" tabindex="-1">8.Proxy <a class="header-anchor" href="#_8-proxy" aria-label="Permalink to &quot;8.Proxy&quot;">​</a></h2><p>ES6中的<code>Proxy</code>是一种元编程机制，它允许开发人员拦截和自定义对象的访问和行为。它可以用来创建一个代理对象，它可以代替另一个对象作为被访问对象，从而控制对被代理对象的访问。</p><p>常用的四种拦截方法：</p><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置。</li><li><code>has(target, propKey)</code>：拦截 propKey in proxy 的操作。</li><li><code>ownKeys(target)</code>：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环。</li></ul>',34),t=[r];function d(c,n,s,h,u,p){return a(),l("div",null,t)}const b=e(i,[["render",d]]);export{f as __pageData,b as default};
