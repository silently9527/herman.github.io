import{_ as r,D as a,c as d,j as e,a as t,I as s,w as l,a4 as i,o as c}from"./chunks/framework.D1poPhlk.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{"updateTime":"2024-03-13 01:38","desc":"面试官：浏览器从输入URL到页面展示的过程是怎样的？浏览器的缓存机制是怎样的？什么是同源策略又有哪些跨域解决方案？你还是支支吾吾一头雾水吗？看完这篇文章，下次面试直接开始吟唱！😎","tags":"八股/计算机基础","outline":2},"headers":[],"relativePath":"Notes/Interviews/浏览器原理与计网.md","filePath":"Notes/Interviews/浏览器原理与计网.md","lastUpdated":1723472907000}'),h={name:"Notes/Interviews/浏览器原理与计网.md"},p=i('<h2 id="浏览器缓存策略-⚔️" tabindex="-1">浏览器缓存策略 ⚔️ <a class="header-anchor" href="#浏览器缓存策略-⚔️" aria-label="Permalink to &quot;浏览器缓存策略 ⚔️&quot;">​</a></h2><p>浏览器的缓存机制主要分为<strong>强制缓存</strong>与<strong>协商缓存</strong>。强制缓存通常是在浏览器端判断是否使用缓存，而协商缓存则是在服务器端判断是否使用缓存。</p><p>两者是共同工作的，在使用缓存之前，浏览器会<strong>先判断强制缓存是否生效</strong>🎯，如果强制缓存失效，浏览器会发送请求到服务器，<strong>再通过协商缓存来判断是否使用缓存</strong>🧐。</p><h3 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;强制缓存&quot;">​</a></h3><p>强制缓存可以通过响应头中的 <code>Expires</code> 和 <code>Cache-Control</code> 来设置。当浏览器第一次请求资源时，服务器会在响应头中包含相应的缓存策略（就是这俩字段），浏览器会将其记录下来，当再次请求这个资源时，浏览器会根据这些字段来判断是否使用缓存。</p><blockquote><p>当 <code>Expires</code> 和 <code>Cache-Control</code> 同时存在时，<code>Cache-Control</code> 优先级高于 <code>Expires</code>。</p></blockquote><p><strong>Expires</strong>：这是一个由服务器端所决定的绝对时间，表示资源的过期时间，以秒为单位。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Expires</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Thu, 10 Nov 2017 08:45:11 GMT</span></span></code></pre></div><ul><li>由于是绝对时间，考虑到时差/误差或者客户端自行修改等因素，都会造成客户端与服务器端时间不一致，从而导致缓存失效。</li><li>字段表示过于复杂 👾，很容易因为非法属性值从而设置失效。</li></ul><p><strong>Cache-Control</strong>：相对时间</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-control</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">max-age=2592000 no-cache</span></span></code></pre></div><ul><li>到期：<code>max-age</code> 代表最大有效时间，是一个相对时间，单位是秒。</li><li>可缓存性 <ul><li><code>public</code>：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)</li><li><code>private</code>：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li><li><code>no-cache</code>：不进行强制缓存的过期判断，而是直接使用协商缓存交由服务器判断。</li><li><code>no-store</code>: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。</li></ul></li><li>重新验证：<code>must-revalidate</code> 一旦资源过期，在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</li></ul><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>当浏览器在第一次请求资源时，服务器不仅会在响应头中包含强制缓存的策略，还会标明与协商缓存有关的信息，例如：</p><ul><li><code>Last-Modified</code> （对应请求头中的 <code>If-Modified-Since</code>）</li><li><code>ETag</code> （对应请求头中的 <code>If-None-Match</code>）</li></ul><p>他们的执行流程大概如下（以<code>ETag</code>为例）：</p><p>当首次请求资源时，服务器会在响应头中加入 <code>ETag</code> 字段，浏览器会将这个字段记录下来。再次请求资源时，浏览器会在<strong>请求头中加入 <code>If-None-Match</code> 字段，值为上次记录的 <code>ETag</code> 字段的值</strong>。</p>',17),g=e("code",null,"200 OK",-1),k=i('<p>而这两组字段的<strong>区别</strong>在于：</p><ul><li><code>Last-Modified</code> 是一个 GMT 格式的时间字符串，以秒为单位，表示资源的最后修改时间。如果资源在 1s 内被修改 🚀，那么这个字段就会失效。同时，如果文件是通过服务器<strong>动态生成</strong>🌊 的，那么该方法的更新时间永远是生成的时间，尽管文件可能并没有改变，但仍然会被认为改变了。</li><li><code>ETag</code> 是一个由服务器通过某些算法生成的字符串，只要资源有变化，这个值就会发生变化，因此可以更加<strong>精确</strong>🎉 的判断资源是否有变化。</li></ul><h2 id="跨域资源共享-🔥" tabindex="-1">跨域资源共享 🔥 <a class="header-anchor" href="#跨域资源共享-🔥" aria-label="Permalink to &quot;跨域资源共享 🔥&quot;">​</a></h2><p>跨域问题的产生源自<strong>浏览器的同源策略 🍨</strong>，同源策略是浏览器的一种安全策略，能够帮助隔离恶意文档，减少可能被攻击的媒介，主要用于防止一些常见的网络攻击（例如 CSRF 攻击）</p><p>同源策略指的是：如果两个 URL 的<strong>协议</strong>，<strong>端口</strong>（如果有指定的话）和<strong>域名</strong>都相同的话，则这两个 URL 是同源。只有同源的文档才能够自由地进行交互，否则就会受到限制。</p><h3 id="解决跨域问题的方案" tabindex="-1">解决跨域问题的方案 <a class="header-anchor" href="#解决跨域问题的方案" aria-label="Permalink to &quot;解决跨域问题的方案&quot;">​</a></h3><ol><li><p><strong>CORS 跨域资源共享</strong>（最为正统的解决方案 🏆）： 是现代浏览器普遍支持的一种机制，允许服务器明确指示哪些其他源（domain、协议、端口）有权访问它的资源。服务器可以在响应头中添加特定的字段，例如<code>Access-Control-Allow-Origin / Access-Control-Allow-Methods</code> 等等，来告诉浏览器这个请求是可以被允许的。</p></li><li><p><strong>代理</strong>：需要注意的是，跨域问题是浏览器的限制，所以在 Node 环境中并不存在跨域问题，我们可以通过搭建一个 NodeJS 代理服务器来实现对于跨域请求的处理。具体而言，如果你使用 Webpack 或者 Vite 你可以通过配置相应的插件来解决跨域问题，如果你使用 Node.js 的话，你可以使用 <code>http-proxy-middleware</code> 这个库来解决跨域问题。需要注意的是，这个办法<strong>只适用于开发环境</strong> 🚧。</p></li><li><p><strong>Nginx 反向代理</strong>💡：客户端向 Nginx 服务器发送请求，Nginx 服务器再将请求转发到真正的目标服务器，然后将目标服务器的响应返回给客户端。在这个过程中，我们需要配置 Nginx 服务器的反向代理规则，来对目标服务器的相应做进一步处理，例如修改响应头使其支持跨域请求。</p></li></ol><h3 id="简单请求与复杂请求" tabindex="-1">简单请求与复杂请求 <a class="header-anchor" href="#简单请求与复杂请求" aria-label="Permalink to &quot;简单请求与复杂请求&quot;">​</a></h3><p>在 CORS 策略中请求可以分类简单请求与复杂请求。</p><ul><li><strong>简单请求</strong>通常是指那些可以直接由 HTML 发起的请求，例如使用 GET 或 POST 方法的请求。这类请求的特点是它们不会改变服务端的状态，并且只使用了一些安全的头信息集合。对于简单请求，浏览器会在请求头中添加一个 Origin 字段来表示请求的源。服务器可以根据这个字段来判断是否允许该请求。</li><li><strong>复杂请求</strong>🎨 通常指的是那些需要通过 JavaScript 脚本发起，并且可能会改变服务端状态或使用了不属于简单请求头集合的请求，例如修改请求头中的 <code>Content-Type</code>，或者使用 PUT、DELETE 等 HTTP 方法。</li></ul>',10),u=e("code",null,"Access-Control-Request-Headers / Methods",-1),T=e("code",null,"Access-Control-Allow-Headers",-1),C=i('<h2 id="输入-url-到页面展示的过程-🎨" tabindex="-1">输入 URL 到页面展示的过程 🎨 <a class="header-anchor" href="#输入-url-到页面展示的过程-🎨" aria-label="Permalink to &quot;输入 URL 到页面展示的过程 🎨&quot;">​</a></h2><p>用户在地址栏中输入一个 URL 之后，将会发生以下几个过程：</p><p>DNS 解析 -&gt; TCP 握手 -&gt; TLS 握手 -&gt; 请求与响应 -&gt; 解析 -&gt; 渲染</p><h3 id="_1-导航" tabindex="-1">1. 导航 <a class="header-anchor" href="#_1-导航" aria-label="Permalink to &quot;1. 导航&quot;">​</a></h3><p>在网络的传输过程中，起点与终点是使用 IP 地址来标识的，而 IP 地址是比较难记忆的，所以才有了域名的出现。用户输入的 URL 通常是一个域名而非 IP，那么要做的第一件事情就是将域名解析成 IP 地址。这个过程被称之为 <strong>DNS 解析</strong>📚，其具体的过程是这样的：浏览器首先查看自己的缓存中是否有这个域名对应的 IP 地址，如果有的话则直接使用，如果没有则去查看本地 host 文件，如果还是没有的话则去请求 DNS 服务器，DNS 服务器会返回一个 IP 地址，然后浏览器就可以使用这个 IP 地址来发送请求了。</p><h3 id="_2-tcp-握手" tabindex="-1">2. TCP 握手 <a class="header-anchor" href="#_2-tcp-握手" aria-label="Permalink to &quot;2. TCP 握手&quot;">​</a></h3><p>获得了服务器的 IP 地址之后，浏览器就会通过 TCP <strong>三次握手</strong>与服务器建立连接。</p><ul><li>【你好，可以听到我讲话吗】浏览器发送 <code>SYN</code> 与序列号 <code>seq=x</code> 给服务器</li><li>【可以的，你可以听到我讲话吗】服务器收到了发送 <code>ACK=x+1 / SYN / seq=y</code> 给浏览器</li><li>【可以听到】浏览器再发送一个 <code>ACK=y+1</code> 包给服务器</li></ul><blockquote><p>为什么需要三次握手呢？🙌</p><p>三次握手都能够确保通信双方能够接收到对方数据并做出响应（很好的理解方式就是上面的对话。 如果只有两次握手，服务器端并不能知道浏览器是否收到了自己的数据）</p></blockquote><h3 id="_3-tls-握手-🔥" tabindex="-1">3. TLS 握手 🔥 <a class="header-anchor" href="#_3-tls-握手-🔥" aria-label="Permalink to &quot;3. TLS 握手 🔥&quot;">​</a></h3><p>对于使用 https 协议的网站，浏览器还需要与服务器进行 TLS 握手。</p><p><strong>TLS 1.2 的握手过程（2 RTT）</strong>：</p><ul><li>浏览器发送 ClientHello 并告知服务器自己支持的加密套件、TLS 版本与随机数 A</li><li>服务端发送 ServerHello 并告知浏览器自己选择的加密套件、TLS 版本与随机数 B 同时附带自己的 CA 证书</li><li>浏览器验证 CA 证书的有效性：证书是否由可信机构颁发、证书中的域名是否与请求的域名一致、证书是否过期。随后生成一个随机数作为预主密钥并使用服务端的公钥加密这个随机数，发送给服务端。</li><li>服务端使用自己的私钥解密浏览器发送的预主密钥，并结合随机数 A/B 生成会话密钥 🔒。</li></ul><p>在随后的数据传输过程中，浏览器与服务器使用会话密钥进行<strong>对称加密</strong>。</p><p><strong>TLS 1.3 的握手过程（1 RTT）</strong>：</p><ul><li>浏览器告知服务器基本的 TLS 信息并发送一个随机数 A</li><li>服务器告知浏览器基本的 TLS 信息与 CA 证书，并发送随机数 B</li></ul><p>TLS 1.3 中<strong>不再使用预主密钥</strong>。相反，双方使用 <strong>Diffie-Hellman 密钥交换</strong>来协商共享秘密。这个共享秘密，将会结合随机数 A/B 来生成会话密钥。一个简单的密钥交换过程如下：</p><ol><li>浏览器选定一个共享密钥 X, 并利用自己的私钥 a 生成随机数 <code>A = aX</code></li><li>服务器也利用共享密钥 X 和自己的私钥 b 生成随机数 <code>B=bX</code></li></ol><p>此后浏览器利用自己的私钥 a 能够计算出会话密钥 <code>aB = abX</code> , 服务器也能够计算会话密钥 <code>bA = baX</code>。</p><h3 id="_4-请求与响应" tabindex="-1">4. 请求与响应 <a class="header-anchor" href="#_4-请求与响应" aria-label="Permalink to &quot;4. 请求与响应&quot;">​</a></h3><p>成功建立连接之后，浏览器将会发送一个初始的 HTTP GET 请求，获得一个 HTML 文件。浏览器收到响应之后会解析 HTML 文件，如果 HTML 文件中包含了其他资源的引用（例如图片、样式表、脚本等），那么浏览器会再次发送请求获取这些资源。</p><h3 id="_5-解析" tabindex="-1">5. 解析 <a class="header-anchor" href="#_5-解析" aria-label="Permalink to &quot;5. 解析&quot;">​</a></h3><p>浏览器首先会处理 HTML 标记并构造 DOM 树，当解析器发现非阻塞资源，例如图片或者 CSS 文件，浏览器会请求这些资源并且继续解析，但是对于没有 <code>async/defer</code> 属性的 <code>script</code> 标签会暂时停止对 HTML 的解析，直到脚本被下载并执行完毕。</p><ul><li><code>async</code>: 异步下载，下载完成后立即执行</li><li><code>defer</code>: 异步下载，等到 HTML 解析完成后再执行</li></ul><p>为了优化解析 DOM 的过程，通常会有<strong>预加载解析器</strong>📝 的参与。它在构建 DOM 树的同时运行，用来扫描 HTML 文档，寻找可能需要加载的资源（例如图片、样式表、脚本、字体文件等）。当预加载解析器发现了这些资源之后，它会指示浏览器开始加载这些资源，即使它们还没有被解析器处理到。这样可以减少页面的加载时间，因为一些资源的下载和 DOM 的解析可以并行进行。</p><p>接下来浏览器将会处理 CSS 并构建 CSSOM 树。等待与处理 CSS 的过程并不会阻塞 DOM 的解析，但是会阻塞 JavaScript 的执行。这是因为 JavaScript 可能会去获取 DOM 元素的 CSS 样式，为了拿到正确的样式信息，需要等待 CSSOM 树的构建完成，否则可能会拿到错误、过时的样式信息。</p><h3 id="_6-渲染" tabindex="-1">6. 渲染 <a class="header-anchor" href="#_6-渲染" aria-label="Permalink to &quot;6. 渲染&quot;">​</a></h3><p>浏览器在构建 DOM 树和 CSSOM 树之后，就会开始构建渲染树。渲染树是由 DOM 树与 CSSOM 树合并而成的，它只包含了需要显示的节点以及这些节点的样式信息。渲染树构建完成之后，浏览器就可以开始布局（layout）与绘制（paint）。</p><ul><li>布局：确定每个节点在屏幕上的确切位置</li><li>绘制：将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影等 🌈。</li></ul><h3 id="断开连接" tabindex="-1">断开连接 <a class="header-anchor" href="#断开连接" aria-label="Permalink to &quot;断开连接&quot;">​</a></h3><p>当数据传输完毕之后，浏览器与服务器会通过<strong>四次挥手</strong>来关闭连接。</p><ul><li>【支付完毕 💰】浏览器发送 <code>FIN</code> 与 <code>seq=x</code> 给服务器，表明自己没有数据要发送了。</li><li>【好的，稍等我给您打印一下小票 📋】服务器收到了并发送 <code>ACK=x+1</code> 给浏览器，表明自己知道了。此时，服务器通常还有数据要处理和发送，所以并不立即关闭连接。</li><li>【谢谢惠顾】服务器发送 <code>FIN</code> 与 <code>seq=y</code> 给浏览器，此时服务器已经处理完了所有的数据。</li><li>【嗯嗯好】浏览器收到并发送 <code>ACK=y+1</code> 包给服务器。此时，浏览器并不会立即关闭连接，而是等待一段时间以确保服务器收到了自己的确认包。</li></ul><p><strong>为什么需要第四次挥手后还需要进行超时等待环节？</strong></p><p>最后一次挥手发出的 ACK 报文可能会在传输过程中丢失，如果服务器没有收到这个 ACK 报文，它就会重新发送 FIN 报文，倘若此时浏览器直接关闭了连接而不进行超时等待，那么服务器就会认为浏览器没有收到自己的 FIN 报文，从而导致服务器一直处于等待关闭状态。因此，超时等待阶段有两个关键目的：</p><ol><li>确保服务器端接收到了客户端发出的 ACK 报文，从而可以安全地关闭连接并释放相关资源。</li><li>防止服务器端先前发送的一些旧数据包在网络延迟后到达客户端，干扰新建立的连接。</li></ol><p><strong>为什么需要四次挥手？</strong></p><p>如果缺少最后一次挥手，那么服务器并不知道浏览器是否接收到了自己的数据，可能会导致服务器的连接处于半关闭状态，从而导致资源的浪费。</p><h2 id="web-安全-🛡️" tabindex="-1">Web 安全 🛡️ <a class="header-anchor" href="#web-安全-🛡️" aria-label="Permalink to &quot;Web 安全 🛡️&quot;">​</a></h2><ul><li><strong>CSRF</strong>：攻击者利用用户已经认证的会话，在用户不知情的情况下向目标网站发起恶意请求。</li><li><strong>XSS</strong>：攻击者将恶意脚本注入到网页中，以窃取信息或进行其他恶意操作。</li><li><strong>SQL 注入</strong>：攻击者通过向应用程序输入恶意 SQL 语句 💣，欺骗后端数据库执行非预期的命令或查询，从而获得敏感信息。</li></ul><h3 id="csrf-跨站请求伪造" tabindex="-1">CSRF - 跨站请求伪造 <a class="header-anchor" href="#csrf-跨站请求伪造" aria-label="Permalink to &quot;CSRF - 跨站请求伪造&quot;">​</a></h3><p>在一个 CSRF 攻击场景中，假如你现在登录了 bank.com 这个网站，网站中记录了你的 cookie 信息，然后你又打开了一个标签页，在这个标签页中，你访问了一个恶意网站 evil.com 👾，这个网站中存在一些恶意脚本，脚本会偷偷地向 bank.com 发送伪造的请求，请求会自动携带上 bank.com 的 cookie 信息。这样一来，恶意网站就可以利用这些信息施展它的恶意行动，比如神不知鬼不觉地转移你的资金 💸。</p><p><strong>防范措施</strong>：</p><ul><li>使用 cookie 的 <code>sameSite</code> 字段，此时 cookie 只能在符合同源策略的情况下才会被发送。</li><li>CSRF Token💡：客户端发送请求时需要携带由服务器动态生成的 Token，服务器会验证 Token 的有效性。</li></ul><h3 id="xss-跨站脚本攻击" tabindex="-1">XSS - 跨站脚本攻击 <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS - 跨站脚本攻击&quot;">​</a></h3><p>XSS 攻击又分为：存储型、反射型、DOM 型。他们的区别在于恶意代码的注入过程不同，但最终目的都是为了将恶意代码注入到网页中，以窃取信息或进行其他恶意操作。</p><ul><li>反射型：攻击者构造出特殊的 URL，包含恶意代码。用户点击链接时，请求发送到服务器，服务器会将请求中的脚本作为数据的一部分反射回给浏览器，浏览器随机解析执行了这段恶意脚本。</li><li>DOM 型 🛠️：仅在客户端发生。攻击者构造特定的输入，引起网站的前端更新，在更新过程中通过闭合标签等修改 DOM 结构的形式注入恶意代码。</li><li>存储型：攻击者将恶意代码提交到网站的数据库中，当用户访问网站时，恶意代码从数据库中读取并执行。</li></ul><p><strong>防范措施</strong>：</p><ul><li><strong>前后端</strong>在处理用户输入的内容时，都需要保持谨慎，对其中的特殊字符进行过滤和转义。</li><li>使用安全的编程方式，譬如避免使用危险的 <code>innerHTML</code> 去设置 HTML 内容，而是使用 <code>textContent</code>。</li></ul><h3 id="sql-注入" tabindex="-1">SQL 注入 <a class="header-anchor" href="#sql-注入" aria-label="Permalink to &quot;SQL 注入&quot;">​</a></h3><p>SQL 注入是一种代码注入攻击，攻击者通过向应用程序输入恶意 SQL 语句，欺骗后端数据库执行非预期的命令或查询，从而获得敏感信息。简单来讲，SQL 注入就是服务器在执行 SQL 语句时<strong>将用户的输入也作为了 SQL 语句的一部分</strong>，从而导致了一些意外的结果。</p><p>例如 🌰，对于根据用户 ID 查询用户信息的接口，其内部的 SQL 语句可能是这样的：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ${id}</span></span></code></pre></div><p>如果用户输入的 <code>id</code> 是 <code>1 OR 1=1</code>，那么 SQL 语句就会变成：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> OR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span></code></pre></div><p>在这种情况下，由于 <code>OR 1=1</code> 永远成立，查询结果竟然是全体用户的信息大曝光 👥！</p><p><strong>防范措施</strong>：</p><ul><li>使用参数化查询，即使用预编译的 SQL 语句，将用户输入的内容作为参数传入，而不是直接拼接到 SQL 语句中。</li><li>对用户的输入进行严格的校验 🔍 和过滤，避免用户输入的内容包含特殊字符。</li></ul><h2 id="http-史记" tabindex="-1">HTTP 史记 <a class="header-anchor" href="#http-史记" aria-label="Permalink to &quot;HTTP 史记&quot;">​</a></h2><ul><li><strong>http 1.0</strong>: 无连接，且在浏览器端存在队头阻塞。</li><li><strong>http 1.1</strong>: 支持持久连接，将队头阻塞转移到服务器端，减少了数据传输的延迟，与此同时还引入了 HTTP 头部的缓存机制。</li><li><strong>http 2.0</strong>: 利用二进制分帧的特性实现多路复用，并引入了头部压缩与服务器推送等技术。</li></ul><h3 id="http-1-0" tabindex="-1">http 1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;http 1.0&quot;">​</a></h3><ul><li><strong>无连接</strong>：默认情况下，每个 HTTP 请求都会创建一个新的 TCP 连接，并且在请求完成后关闭此连接，这导致了较高的延迟和较低的效率（每个 HTTP 请求都需要进行 TCP 握手与挥手），尤其是在网页包含多个资源时。</li><li><strong>不支持管道化</strong>：同一时间浏览器只能处理一个请求，后续请求必须等待前面的请求响应结束才能发送，这意味着如果一个请求如果没有得到响应，那么后续的所有请求都会被阻塞，这就是常说的“<strong>队头阻塞</strong>”💥。</li></ul><h3 id="http-1-1" tabindex="-1">http 1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;http 1.1&quot;">​</a></h3><ul><li><strong>长连接</strong>：引入 <code>Connection: keep-alive</code> 机制，允许单个 TCP 连接处理多个 HTTP 请求，减少了频繁握手与挥手带来的开销。</li><li><strong>支持管道化</strong>：客户端能够向服务器发送多个请求，服务器端可以同时处理这些请求，但是需要按照请求的顺序依次响应，以便客户端能够区分每次请求的响应内容。这意味着如果一个请求没有处理完毕，哪怕后面的请求已经准备就绪，也会被服务器所阻塞，事实上这只不过将队头阻塞转移到了服务器端。</li><li><strong>缓存</strong>：在 HTTP 头部中新增 <code>Cache-Control</code>、<code>Expires</code>、<code>Last-Modified</code> 等字段，用于指定资源的缓存策略。</li></ul><h3 id="http-2-0" tabindex="-1">http 2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;http 2.0&quot;">​</a></h3><ul><li><strong>二进制分帧</strong>：http 2.0 采用<strong>二进制格式</strong>传输数据，而非文本格式，并且 http 2.0 还将请求和响应分割为多个帧，以便支持多路复用。</li><li><strong>多路复用</strong>：由于二进制分帧的特性，多个请求和响应能够在同一个连接上交错进行，接收方只需要根据帧上的流标识符即可将其组装为正确且完整的消息。<strong>由于不再关心请求和响应的先后顺序，因此可以解决“队头阻塞”问题</strong>。</li><li><strong>头部压缩</strong>📦：对一些重复的 HTTP 头部字段（例如 cookie 等）进行压缩，以减少传输的流量。实现原理类似于双方协商一个编码表，然后对 HTTP 头部进行编码，最后在传输过程中解码，例如使用 &#39;A&#39; 来代指 Last-Modified。</li><li><strong>服务器推送</strong>：服务器可以主动向客户端推送数据，而无需客户端发送请求。例如在用户请求 HTML 文件时，服务器就可以将对应的 CSS 文件和 JS 文件发送给客户端，而不必等待浏览器解析到相应位置时再发送请求。</li></ul><h3 id="http-3" tabindex="-1">HTTP 3 <a class="header-anchor" href="#http-3" aria-label="Permalink to &quot;HTTP 3&quot;">​</a></h3><p>HTTP 3 是基于 QUIC（Quick UDP Internet Connection）协议实现的，事实上 HTTP 3 的主要作用就是保持 HTTP 基本语义，很多 http 2 的功能都移交给 QUIC 了。那么 QUIC 协议具有哪些特点呢？</p><ul><li><strong>解决 TCP 层面的队头阻塞</strong>： TCP 队头阻塞其实与 ACK 有一定的关系，后续的数据包需要等待前面的数据包的 ACK，这就导致了“队头阻塞”。QUIC 采用的解决办法与 http 2 的思想类似，就是为数据分配一个标识符，根据标识符来区分不同的数据包，从而不必进行排队等待 。</li><li><strong>整合 TCP 握手与 TLS 握手</strong>：在 http 2 之中传递数据需要经过 TCP 握手与 TLS 握手，至少需要 2 RTT 才能进行数据传输，而在 QUIC 中，这两个步骤可以合并为一个步骤，从而减少了 RTT 的数量 ⚡。</li><li><strong>Connection ID 实现切网不重握</strong>：通常情况下，发生网络切换（例如从 WIFI 切到 4G）时，浏览器需要进行重新握手连接。QUIC 引入 Connection ID，通过 Connection ID 将不同网络的请求与响应关联起来 🦄，从而实现切网不重握。</li></ul><p>关于该部分的内容可以参考以下视频：</p>',69),b=i(`<h2 id="web-storage🏦" tabindex="-1">Web Storage🏦 <a class="header-anchor" href="#web-storage🏦" aria-label="Permalink to &quot;Web Storage🏦&quot;">​</a></h2><ul><li><strong><code>sessionStorage</code></strong> 是<strong>临时性</strong>的本地存储，数据仅保存在一次会话（页面）中，关闭页面后数据会被释放。</li><li><strong><code>localStorage</code></strong> 是<strong>持久化</strong>的本地存储，存储在其中的数据不会过期，除非手动删除或者浏览器清除缓存。</li><li><strong><code>cookie</code></strong></li></ul><p>Cookie 🍪 不是专门设计用于数据存储的机制，主要作用在于维持状态，由于 http 协议本身是无状态的，每次请求都是独立的。为了跟踪用户的连续请求和会话，就需要借助额外的机制来维持状态。<strong>Cookie 主要用于维持用户的登录状态以及记录用户的偏好设置</strong>。其工作原理如下：</p><p>当服务器通过响应头中的 <code>Set-Cookie</code> 字段设置 Cookie 后，浏览器会将其保存在本地。随后，在发起下一次请求时，浏览器会自动将这些 Cookie 信息附带在请求头部。以下是一个简化的示例，注意若需设置多个 Cookie，则需在响应头中添加多个 <code>Set-Cookie</code> 字段：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">HTTP/1.0 200 OK</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">text/html</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">user_name=xxx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">status=xxx; Path=/; Domain=juejin.cn; Max-Age=2592000; HttpOnly</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">页面内容</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>Set-Cookie 字段中常见的参数一般有：</p><ul><li><code>&lt;key&gt;=&lt;value&gt;</code>：定义 Cookie 的名称与值。</li><li>生命周期 ⌛： <code>Expires</code> 绝对时间、<code>Max-Age</code>相对时间。默认为会话结束时失效。</li><li>安全策略：<code>Secure</code> 只有在 https 请求中才会发送、<code>HttpOnly</code> 禁止 JavaScript 访问。</li><li>作用域： <ul><li><code>Domain</code> 指定哪些域名可以访问，默认为当前 host ，并且不包括子域名。若指定了该字段，那么子域名也可以访问，这常用于实现单点登录功能。</li><li><code>Path</code> 指定哪些 URL 可以访问。例如如果设置 <code>Path=/user</code>，则只有访问 <code>/user</code> 下的 URL 才会携带这个 cookie。</li><li><code>SameSite</code> 通常用于防止 CSRF 攻击，设置为 <code>strict</code> 时，只有同源请求才会携带 cookie。</li></ul></li></ul><blockquote><p>需要注意的是 🧐，发送请求时并不会将所有 Cookie 都发送给服务器，而是要经过一系列的判断，例如是否过期，是否符合安全策略与作用域等等。</p></blockquote><h2 id="cdn-原理" tabindex="-1">CDN 原理 <a class="header-anchor" href="#cdn-原理" aria-label="Permalink to &quot;CDN 原理&quot;">​</a></h2><p>在未使用 CDN 加速的情况下，用户的浏览器直接向源服务器请求加载所需资源。这种情况下，如果用户与源服务器之间的距离较远，或者网络条件不佳，可能会导致较长的加载时间 🐌。</p><p>启用 CDN 加速后，浏览器请求资源的流程发生变化：</p><ol><li><strong>请求分发</strong>✨：用户发起的资源请求首先到达 CDN 的边缘服务器。CDN 服务器会根据用户的地理位置与网络条件，通过全局负载均衡的手段，将用户请求分发到离用户最近的 CDN 节点上，这一步通常是利用 dns 解析的 CNAME 记录来实现。</li><li><strong>资源缓存</strong>：当请求到达相应的 CDN 节点时： <ol><li>如果该节点已经缓存了用户请求的资源，则直接从节点返回给用户，减少响应时间和网络传输距离。</li><li>如果 CDN 节点上没有该资源，CDN 节点会向源服务器请求资源，缓存并返回给用户。后续请求时就可以直接使用。</li></ol></li></ol><p>需要注意的是使用 CDN <strong>并不总是能加速资源加载</strong>🚨。若 CDN 节点上的资源已经过期，节点需要重新向源服务器请求资源，这时 CDN 相较于直接访问源服务器的加速效果就会减弱（因为多走了一个 CDN 节点）。</p><p>CDN 主要解决了跨地域访问带来的<strong>延迟</strong>问题，以及减轻源服务器的<strong>负载压力</strong>。</p><h2 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">前文内容快速跳转</p><p><a href="#_2-tcp-握手">【TCP 三次握手】</a> / <a href="#断开连接">【TCP 四次挥手】</a></p></div><h3 id="tcp-与-udp-的区别" tabindex="-1">TCP 与 UDP 的区别 <a class="header-anchor" href="#tcp-与-udp-的区别" aria-label="Permalink to &quot;TCP 与 UDP 的区别&quot;">​</a></h3><p><strong>TCP</strong>：面向连接的、可靠的、基于字节流的传输层协议。TCP 通过三次握手建立连接，并借助序列号、ACK、超时重传等机制保证数据的可靠传输，并且提供流量控制和拥塞控制。</p><p><strong>UDP</strong>：无连接的、不可靠的、基于数据包的传输层协议。UDP 不保证数据的可靠传输，但是传输速度更快，并且支持广播和多播。</p><ul><li>TCP 适用于要求可靠传输的场景，例如 HTTP、HTTPS、SMTP 等。</li><li>UDP 适用于实时性要求较高的场景，例如音视频、DNS 等。</li></ul><details class="details custom-block"><summary>补充内容：可靠传输的定义</summary><ol><li>数据不丢失：接收方能够接收到发送方发送的所有数据。</li><li>数据不重复：接收方不会接收到重复的数据。</li><li>数据有序：接收方接收到的数据与发送方发送的数据顺序一致。</li><li>数据完整性：数据在传输过程中没有被篡改或损坏。</li></ol></details><h3 id="常用的-http-请求方式" tabindex="-1">常用的 HTTP 请求方式 <a class="header-anchor" href="#常用的-http-请求方式" aria-label="Permalink to &quot;常用的 HTTP 请求方式&quot;">​</a></h3><ul><li><strong>GET</strong>：用来请求获取某个网页的信息，并返回网页内容。</li><li><strong>POST</strong>：用来向指定的资源提交数据进行处理，比如提交表单或者上传文件。数据包含在请求体中。</li><li><strong>PUT</strong>：用来将客户端提供的数据替换指定资源的内容。</li><li><strong>DELETE</strong>：用来请求服务器删除指定的资源。</li><li><strong>OPTIONS</strong>：用来查看服务器支持哪些 HTTP 请求方法，通常用于跨域请求的预检操作。</li></ul><h4 id="get-与-post-的区别" tabindex="-1">GET 与 POST 的区别 <a class="header-anchor" href="#get-与-post-的区别" aria-label="Permalink to &quot;GET 与 POST 的区别&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>用途</strong></td><td>获取数据</td><td>提交数据，通常用于创建或者更新服务器上的资源</td></tr><tr><td style="text-align:center;"><strong>参数传递方式</strong></td><td>URL 查询字符串</td><td>请求体</td></tr><tr><td style="text-align:center;"><strong>安全性</strong></td><td>参数包含在 URL 中，安全性较低 😱</td><td>参数在请求体中，相对更安全</td></tr><tr><td style="text-align:center;"><strong>数据长度限制</strong></td><td>有长度限制（通常不超过 2048 字符）</td><td>无明确长度限制</td></tr><tr><td style="text-align:center;"><strong>幂等性</strong></td><td>幂等，重复请求不会改变服务器状态</td><td>非幂等，重复请求可能会改变服务器状态</td></tr><tr><td style="text-align:center;"><strong>缓存</strong></td><td>浏览器和缓存服务器会缓存</td><td>默认不缓存</td></tr></tbody></table><h3 id="常见的-http-状态码" tabindex="-1">常见的 HTTP 状态码 <a class="header-anchor" href="#常见的-http-状态码" aria-label="Permalink to &quot;常见的 HTTP 状态码&quot;">​</a></h3><details class="details custom-block"><summary>2xx 成功</summary><ul><li>200 OK：请求成功，服务器返回所请求的数据。</li><li>201 Created：请求成功并且服务器创建了新的资源。</li><li>204 No Content：请求成功但没有内容返回。</li></ul></details><details class="details custom-block"><summary>3xx 重定向</summary><ul><li>301 Moved Permanently：请求的资源已被<strong>永久</strong>移动到新的 URL。</li><li>302 Found：请求的资源<strong>临时</strong>从不同的 URL 响应。</li><li>304 Not Modified：资源未修改，客户端可以使用缓存的版本。</li></ul></details><details class="details custom-block"><summary>4xx 客户端错误 🚧</summary><ul><li>400 Bad Request：服务器无法理解请求的格式。</li><li>401 Unauthorized：请求要求用户认证。</li><li>403 Forbidden：服务器理解请求但拒绝执行。</li><li>404 Not Found：请求的资源未找到。</li></ul></details><details class="details custom-block"><summary>5xx 服务器错误</summary><ul><li>500 Internal Server Error：服务器遇到错误，无法完成请求。</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到<strong>无效响应</strong>。</li><li>503 Service Unavailable：服务器当前无法处理请求，通常是由于<strong>过载</strong>或维护。ChatGPT 过于火爆时就会报这个错误码 👾.</li><li>504 Gateway Timeout：服务器作为网关或代理，<strong>未能及时</strong>从上游服务器接收到响应。</li></ul></details><h3 id="对-websocket-与-sse-的理解" tabindex="-1">对 WebSocket 与 SSE 的理解 <a class="header-anchor" href="#对-websocket-与-sse-的理解" aria-label="Permalink to &quot;对 WebSocket 与 SSE 的理解&quot;">​</a></h3><ul><li><strong>WebSocket</strong>：是一种在单个 TCP 连接上进行全双工通信的协议，它<strong>允许客户端和服务器之间进行实时通信 🔗</strong> 。WebSocket 通过 HTTP 协议进行握手，然后在握手成功后升级为 WebSocket 协议。WebSocket 适用于实时性要求较高的场景，例如在线聊天、实时游戏等。</li><li><strong>SSE(Server Send Event)</strong>：是一种基于 HTTP 的<strong>单向通信</strong>协议，允许服务器向客户端推送数据。SSE 适用于服务器向客户端推送实时数据的场景，例如<code>ChatGPT</code>的流式 🌊 对话功能。</li></ul>`,32);function S(P,m,E,_,y,x){const o=a("HText"),n=a("LinkCard");return c(),d("div",null,[p,e("p",null,[t("服务器会将这两个值进行对比，如果相等，则表示未修改，响应 "),s(o,{type:"true"},{default:l(()=>[t(" 304 Not Modified ")]),_:1}),t("；反之，则表示修改了，响应 "),g,t("，并返回最新的数据与缓存标识。")]),k,e("p",null,[t("对于复杂请求，浏览器会首先发送一个预检（preflight）请求，这通常是一个 "),s(o,{type:"true"},{default:l(()=>[t("OPTIONS")]),_:1}),t(" 方法的请求。预检请求中会包含 "),u,t(" 等字段，用以表示实际请求中将会使用的 HTTP 方法和头信息等。服务器会根据这些信息来决定是否允许实际的请求。如果服务器允许，它会在响应头中添加 "),T,t(" 和其他相关字段。浏览器将根据这些响应头来决定是否继续发送实际的请求。如果不允许，浏览器将返回一个错误 ⚡。")]),C,s(n,{desc:"QUIC核心原理和握手过程 | 哔哩哔哩-技术蛋老师",link:"https://www.bilibili.com/video/BV1Mg411s7mP/?p=21&vd_source=078d08e0de4b58aacb1aef1949540066"}),b])}const f=r(h,[["render",S]]);export{D as __pageData,f as default};
