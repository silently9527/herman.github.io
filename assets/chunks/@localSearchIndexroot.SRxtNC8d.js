const t='{"documentCount":154,"nextId":154,"documentIds":{"0":"/about/#🌟-技能","1":"/about/#🐸-学习","2":"/about/#🌀-博客","3":"/about/#🐱-免责声明","4":"/article/pamphlet/algorithms/#基础算法篇","5":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#一致性hash算法java版实现","6":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#前言","7":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#分布式缓存集群的访问模型","8":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#一致性哈希算法","9":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#具体的算法过程","10":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#容错性","11":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#伸缩性","12":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#数据倾斜问题","13":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#一致性hash算法java版实现-1","14":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#核心代码","15":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#测试代码","16":"/article/pamphlet/algorithms/卧学算法/01-一致性Hash算法Java版实现#其他使用场景","17":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#老哥确定不来复习下数据结构吗","18":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#前言","19":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-看你这么会说话-让我先来帮你开个胃-说说二分查找吧","20":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-说说使用数组如何实现栈","21":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-你刚才实现的栈是定容的-那如何实现动态调整栈的大小","22":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-刚才你提到了链表-那么使用链表如何实现栈","23":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-使用链表如何实现先进先出队列","24":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-胃开的差不多了-来聊一点算法吧-你来设计一个算法对算术表示式求值-比如-1-2-3-4-5","25":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-一个int类型的数组-其中存在三个数字相加等于0-你来设计个算法帮我统计出有多少组这样的数字","26":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-假如这个数组有100万的int值-你这个算法得运行到什么时候","27":"/article/pamphlet/algorithms/卧学算法/02-老哥确定不来复习下数据结构吗#面试官-假如你是微信的开发人员-随便给你两个用户-如何判断这两个用户是否连通的。何为连通-a是b的好友-b是c的好友-那么a与c就是连通的","28":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#如何检测社交网络中两个人是否是朋友关系","29":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#前言","30":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#概念","31":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#相连","32":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#等价类","33":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#触点","34":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#连通分量","35":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#动态连通性","36":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#union-find算法api定义","37":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#quick-find算法","38":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#quick-union算法","39":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#加权quick-union算法","40":"/article/pamphlet/algorithms/卧学算法/03-如何检测社交网络中两个人是否是朋友关系（union-find算法）#总结","41":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#常见的初级排序算法-这次全搞懂","42":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#前言","43":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#排序算法的模板","44":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#选择排序","45":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#冒泡排序","46":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#插入排序","47":"/article/pamphlet/algorithms/卧学算法/04-常见的初级排序算法，这次全搞懂#希尔排序","48":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#死磕归并排序算法","49":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#前言","50":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#归并排序算法思路","51":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#原地归并实现","52":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#自顶向下的归并排序","53":"/article/pamphlet/algorithms/卧学算法/05-死磕归并排序算法#自底向上的归并排序","54":"/article/pamphlet/algorithms/卧学算法/06-快速排序算法实现及优化#快速排序算法实现及优化","55":"/article/pamphlet/algorithms/卧学算法/06-快速排序算法实现及优化#前言","56":"/article/pamphlet/algorithms/卧学算法/06-快速排序算法实现及优化#快速排序思路","57":"/article/pamphlet/algorithms/卧学算法/06-快速排序算法实现及优化#算法实现","58":"/article/pamphlet/algorithms/卧学算法/06-快速排序算法实现及优化#算法改进","59":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#原来实现优先级队列如此简单","60":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#前言","61":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#队列api定义","62":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#初级版本的实现","63":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#队列api的抽象类","64":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#基于无序数组实现","65":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#基于有序数组实现","66":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#基于链表实现","67":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#二叉堆实现","68":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#二叉堆的定义","69":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#由上向下恢复堆有序-上浮","70":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#由下向上恢复堆有序-下沉","71":"/article/pamphlet/algorithms/卧学算法/07-原来实现优先级队列如此简单#二叉堆实现优先级队列","72":"/article/pamphlet/algorithms/卧学算法/08-图解堆排序#图解堆排序","73":"/article/pamphlet/algorithms/卧学算法/08-图解堆排序#前言","74":"/article/pamphlet/algorithms/卧学算法/08-图解堆排序#构造堆","75":"/article/pamphlet/algorithms/卧学算法/08-图解堆排序#下沉排序","76":"/article/pamphlet/algorithms/卧学算法/08-图解堆排序#堆排序代码实现","77":"/article/pamphlet/algorithms/卧学算法/09-基于数组或链表实现Map#基于数组或链表实现map","78":"/article/pamphlet/algorithms/卧学算法/09-基于数组或链表实现Map#前言","79":"/article/pamphlet/algorithms/卧学算法/09-基于数组或链表实现Map#map-api的定义","80":"/article/pamphlet/algorithms/卧学算法/09-基于数组或链表实现Map#基于链表实现map","81":"/article/pamphlet/algorithms/卧学算法/09-基于数组或链表实现Map#基于数组实现map","82":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#基于二叉树实现map","83":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#前言","84":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#二叉树简介","85":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#基于二叉树实现map-1","86":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#查询","87":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#查询出最大值和最小值","88":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#插入","89":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#删除最大值和最小值","90":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#删除","91":"/article/pamphlet/algorithms/卧学算法/10-基于二叉树实现Map#分析","92":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#硬核图解红黑树并手写实现","93":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#前言","94":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#平衡查找树","95":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#_2-3树","96":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#查找","97":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#插入","98":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#基于2-3树实现的左倾红黑树","99":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#红黑树性质解释","100":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#_2-3树在左倾红黑树中表示","101":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#判断节点的颜色","102":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#旋转","103":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#变色","104":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#插入-1","105":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#向单键节点插入","106":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#向双键节点中插入","107":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#删除","108":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#删除最小值","109":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#删除最大值","110":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#删除任意节点","111":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#画出红黑树来验证实现","112":"/article/pamphlet/algorithms/卧学算法/11-硬核图解红黑树并手写实现#总结","113":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#基于拉链式和线性探测式散列表实现map","114":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#前言","115":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#散列函数","116":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#integer","117":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#long","118":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#double、float","119":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#string","120":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#软缓存","121":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#拉链式的散列表","122":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#线性探测式散列表","123":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#初始化","124":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#插入","125":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#动态调整数组的大小","126":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#查询","127":"/article/pamphlet/algorithms/卧学算法/12-基于拉链式和线性探测式散列表实现Map#删除元素","128":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#图算法系列之无向图的数据结构","129":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#前言","130":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#图的定义","131":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#图的术语","132":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#如何表示出图","133":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#无向图的api定义","134":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#无向图api的实现","135":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#图的常用工具方法","136":"/article/pamphlet/algorithms/卧学算法/13-图算法系列之无向图的数据结构#总结","137":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#图算法系列之深度优先搜索-一","138":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#前言","139":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#搜索api的定义","140":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#深度优先搜索","141":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#寻找路径的api","142":"/article/pamphlet/algorithms/卧学算法/14-图算法系列之深度优先搜索一#基于深度优先搜索查找图中的可达路径","143":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#图算法系列之深度优先搜索-二","144":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#连通分量","145":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#连通分量的api定义","146":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#连通分量的api实现","147":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#单元测试","148":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#检查无向图中是否有环","149":"/article/pamphlet/algorithms/卧学算法/15-图算法系列之深度优先搜索二#检查无向图是否是二分图","150":"/article/pamphlet/algorithms/卧学算法/16-图算法系列之计算图中最短路径#图算法系列之计算图中最短路径","151":"/article/pamphlet/algorithms/卧学算法/16-图算法系列之计算图中最短路径#前言","152":"/article/pamphlet/algorithms/卧学算法/16-图算法系列之计算图中最短路径#广度优先搜索","153":"/article/pamphlet/algorithms/卧学算法/16-图算法系列之计算图中最短路径#符号图"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[2,1,9],"1":[2,1,8],"2":[2,1,6],"3":[2,1,5],"4":[1,1,45],"5":[1,1,1],"6":[1,1,8],"7":[1,1,48],"8":[1,1,1],"9":[1,3,21],"10":[1,3,11],"11":[1,3,5],"12":[1,3,41],"13":[1,1,25],"14":[2,2,1],"15":[2,2,6],"16":[1,1,16],"17":[1,1,1],"18":[1,1,29],"19":[4,3,59],"20":[3,3,50],"21":[3,3,52],"22":[3,3,46],"23":[2,3,59],"24":[12,3,52],"25":[4,3,27],"26":[3,3,73],"27":[8,3,13],"28":[1,1,1],"29":[1,1,26],"30":[1,1,1],"31":[1,3,19],"32":[1,3,5],"33":[1,3,2],"34":[1,3,3],"35":[1,3,11],"36":[2,1,41],"37":[2,1,44],"38":[2,1,55],"39":[2,1,53],"40":[1,1,17],"41":[2,1,1],"42":[1,2,5],"43":[1,2,41],"44":[1,2,42],"45":[1,2,39],"46":[1,2,51],"47":[1,2,46],"48":[1,1,3],"49":[1,1,9],"50":[1,1,13],"51":[1,1,49],"52":[1,1,84],"53":[1,1,46],"54":[1,1,1],"55":[1,1,9],"56":[1,1,16],"57":[1,1,59],"58":[1,1,90],"59":[1,1,1],"60":[1,1,6],"61":[1,1,28],"62":[1,1,1],"63":[1,3,29],"64":[1,3,55],"65":[1,3,44],"66":[1,3,9],"67":[1,1,1],"68":[1,3,24],"69":[3,3,19],"70":[3,3,20],"71":[1,3,54],"72":[1,1,1],"73":[1,1,46],"74":[1,1,24],"75":[1,1,8],"76":[1,1,20],"77":[1,1,1],"78":[1,1,12],"79":[2,1,33],"80":[1,1,88],"81":[1,1,93],"82":[1,1,1],"83":[1,1,7],"84":[1,1,29],"85":[1,1,42],"86":[1,2,40],"87":[1,2,29],"88":[1,2,43],"89":[1,2,29],"90":[1,2,44],"91":[1,2,14],"92":[1,1,1],"93":[1,1,46],"94":[1,1,17],"95":[2,2,8],"96":[1,4,8],"97":[1,4,32],"98":[2,2,56],"99":[1,4,64],"100":[2,4,14],"101":[1,4,15],"102":[1,4,30],"103":[1,4,33],"104":[1,4,1],"105":[1,5,7],"106":[1,5,78],"107":[1,4,26],"108":[1,5,69],"109":[1,5,40],"110":[1,4,67],"111":[1,2,60],"112":[1,1,23],"113":[1,1,9],"114":[1,1,13],"115":[1,1,16],"116":[1,3,12],"117":[1,3,17],"118":[2,3,37],"119":[1,3,25],"120":[1,3,6],"121":[1,1,75],"122":[1,1,17],"123":[1,3,17],"124":[1,3,42],"125":[1,3,28],"126":[1,3,36],"127":[1,3,54],"128":[1,1,9],"129":[1,1,10],"130":[1,1,5],"131":[1,1,12],"132":[1,1,40],"133":[1,1,24],"134":[1,1,52],"135":[1,1,43],"136":[1,1,5],"137":[3,1,1],"138":[1,3,5],"139":[1,3,19],"140":[1,3,68],"141":[1,3,26],"142":[1,3,76],"143":[3,1,4],"144":[1,3,11],"145":[1,4,16],"146":[1,4,45],"147":[1,4,40],"148":[1,3,51],"149":[1,3,45],"150":[1,1,1],"151":[1,1,8],"152":[1,1,86],"153":[1,1,102]},"averageFieldLength":[1.3701298701298699,2.038961038961039,28.558441558441558],"storedFields":{"0":{"title":"🌟 技能","titles":[null,null]},"1":{"title":"🐸 学习","titles":[null,null]},"2":{"title":"🌀 博客","titles":[null,null]},"3":{"title":"🐱 免责声明","titles":[null,null]},"4":{"title":"基础算法篇","titles":[]},"5":{"title":"一致性Hash算法Java版实现","titles":[]},"6":{"title":"前言","titles":["一致性Hash算法Java版实现"]},"7":{"title":"分布式缓存集群的访问模型","titles":["一致性Hash算法Java版实现"]},"8":{"title":"一致性哈希算法","titles":["一致性Hash算法Java版实现"]},"9":{"title":"具体的算法过程","titles":["一致性Hash算法Java版实现","一致性哈希算法",null]},"10":{"title":"容错性","titles":["一致性Hash算法Java版实现","一致性哈希算法",null]},"11":{"title":"伸缩性","titles":["一致性Hash算法Java版实现","一致性哈希算法",null]},"12":{"title":"数据倾斜问题","titles":["一致性Hash算法Java版实现","一致性哈希算法",null]},"13":{"title":"一致性Hash算法Java版实现","titles":["一致性Hash算法Java版实现"]},"14":{"title":"核心代码：","titles":["一致性Hash算法Java版实现","一致性Hash算法Java版实现",null]},"15":{"title":"测试代码：","titles":["一致性Hash算法Java版实现","一致性Hash算法Java版实现",null]},"16":{"title":"其他使用场景","titles":["一致性Hash算法Java版实现"]},"17":{"title":"老哥确定不来复习下数据结构吗","titles":[]},"18":{"title":"前言","titles":["老哥确定不来复习下数据结构吗"]},"19":{"title":"面试官：看你这么会说话，让我先来帮你开个胃，说说二分查找吧","titles":["老哥确定不来复习下数据结构吗","前言",null]},"20":{"title":"面试官：说说使用数组如何实现栈？","titles":["老哥确定不来复习下数据结构吗","前言",null]},"21":{"title":"面试官：你刚才实现的栈是定容的，那如何实现动态调整栈的大小","titles":["老哥确定不来复习下数据结构吗","前言",null]},"22":{"title":"面试官：刚才你提到了链表，那么使用链表如何实现栈","titles":["老哥确定不来复习下数据结构吗","前言",null]},"23":{"title":"面试官：使用链表如何实现先进先出队列","titles":["老哥确定不来复习下数据结构吗","前言",null]},"24":{"title":"面试官：胃开的差不多了，来聊一点算法吧；你来设计一个算法对算术表示式求值，比如：( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )","titles":["老哥确定不来复习下数据结构吗","前言",null]},"25":{"title":"面试官：一个int类型的数组，其中存在三个数字相加等于0，你来设计个算法帮我统计出有多少组这样的数字","titles":["老哥确定不来复习下数据结构吗","前言",null]},"26":{"title":"面试官：假如这个数组有100万的int值，你这个算法得运行到什么时候","titles":["老哥确定不来复习下数据结构吗","前言",null]},"27":{"title":"面试官：假如你是微信的开发人员，随便给你两个用户，如何判断这两个用户是否连通的。何为连通？A是B的好友，B是C的好友，那么A与C就是连通的","titles":["老哥确定不来复习下数据结构吗","前言",null]},"28":{"title":"如何检测社交网络中两个人是否是朋友关系","titles":[]},"29":{"title":"前言","titles":["如何检测社交网络中两个人是否是朋友关系"]},"30":{"title":"概念","titles":["如何检测社交网络中两个人是否是朋友关系"]},"31":{"title":"相连","titles":["如何检测社交网络中两个人是否是朋友关系","概念",null]},"32":{"title":"等价类","titles":["如何检测社交网络中两个人是否是朋友关系","概念",null]},"33":{"title":"触点","titles":["如何检测社交网络中两个人是否是朋友关系","概念",null]},"34":{"title":"连通分量","titles":["如何检测社交网络中两个人是否是朋友关系","概念",null]},"35":{"title":"动态连通性","titles":["如何检测社交网络中两个人是否是朋友关系","概念",null]},"36":{"title":"union-find算法API定义","titles":["如何检测社交网络中两个人是否是朋友关系"]},"37":{"title":"quick-find算法","titles":["如何检测社交网络中两个人是否是朋友关系"]},"38":{"title":"quick-union算法","titles":["如何检测社交网络中两个人是否是朋友关系"]},"39":{"title":"加权quick-union算法","titles":["如何检测社交网络中两个人是否是朋友关系"]},"40":{"title":"总结","titles":["如何检测社交网络中两个人是否是朋友关系"]},"41":{"title":"常见的初级排序算法，这次全搞懂","titles":[]},"42":{"title":"前言","titles":["常见的初级排序算法，这次全搞懂"]},"43":{"title":"排序算法的模板","titles":["常见的初级排序算法，这次全搞懂"]},"44":{"title":"选择排序","titles":["常见的初级排序算法，这次全搞懂"]},"45":{"title":"冒泡排序","titles":["常见的初级排序算法，这次全搞懂"]},"46":{"title":"插入排序","titles":["常见的初级排序算法，这次全搞懂"]},"47":{"title":"希尔排序","titles":["常见的初级排序算法，这次全搞懂"]},"48":{"title":"死磕归并排序算法","titles":[]},"49":{"title":"前言","titles":["死磕归并排序算法"]},"50":{"title":"归并排序算法思路","titles":["死磕归并排序算法"]},"51":{"title":"原地归并实现","titles":["死磕归并排序算法"]},"52":{"title":"自顶向下的归并排序","titles":["死磕归并排序算法"]},"53":{"title":"自底向上的归并排序","titles":["死磕归并排序算法"]},"54":{"title":"快速排序算法实现及优化","titles":[]},"55":{"title":"前言","titles":["快速排序算法实现及优化"]},"56":{"title":"快速排序思路","titles":["快速排序算法实现及优化"]},"57":{"title":"算法实现","titles":["快速排序算法实现及优化"]},"58":{"title":"算法改进","titles":["快速排序算法实现及优化"]},"59":{"title":"原来实现优先级队列如此简单","titles":[]},"60":{"title":"前言","titles":["原来实现优先级队列如此简单"]},"61":{"title":"队列API定义","titles":["原来实现优先级队列如此简单"]},"62":{"title":"初级版本的实现","titles":["原来实现优先级队列如此简单"]},"63":{"title":"队列API的抽象类","titles":["原来实现优先级队列如此简单","初级版本的实现",null]},"64":{"title":"基于无序数组实现","titles":["原来实现优先级队列如此简单","初级版本的实现",null]},"65":{"title":"基于有序数组实现","titles":["原来实现优先级队列如此简单","初级版本的实现",null]},"66":{"title":"基于链表实现","titles":["原来实现优先级队列如此简单","初级版本的实现",null]},"67":{"title":"二叉堆实现","titles":["原来实现优先级队列如此简单"]},"68":{"title":"二叉堆的定义","titles":["原来实现优先级队列如此简单","二叉堆实现",null]},"69":{"title":"由上向下恢复堆有序（上浮）","titles":["原来实现优先级队列如此简单","二叉堆实现",null]},"70":{"title":"由下向上恢复堆有序（下沉）","titles":["原来实现优先级队列如此简单","二叉堆实现",null]},"71":{"title":"二叉堆实现优先级队列","titles":["原来实现优先级队列如此简单","二叉堆实现",null]},"72":{"title":"图解堆排序","titles":[]},"73":{"title":"前言","titles":["图解堆排序"]},"74":{"title":"构造堆","titles":["图解堆排序"]},"75":{"title":"下沉排序","titles":["图解堆排序"]},"76":{"title":"堆排序代码实现","titles":["图解堆排序"]},"77":{"title":"基于数组或链表实现Map","titles":[]},"78":{"title":"前言","titles":["基于数组或链表实现Map"]},"79":{"title":"Map API的定义","titles":["基于数组或链表实现Map"]},"80":{"title":"基于链表实现Map","titles":["基于数组或链表实现Map"]},"81":{"title":"基于数组实现Map","titles":["基于数组或链表实现Map"]},"82":{"title":"基于二叉树实现Map","titles":[]},"83":{"title":"前言","titles":["基于二叉树实现Map"]},"84":{"title":"二叉树简介","titles":["基于二叉树实现Map"]},"85":{"title":"基于二叉树实现Map","titles":["基于二叉树实现Map"]},"86":{"title":"查询","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"87":{"title":"查询出最大值和最小值","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"88":{"title":"插入","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"89":{"title":"删除最大值和最小值","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"90":{"title":"删除","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"91":{"title":"分析","titles":["基于二叉树实现Map","基于二叉树实现Map",null]},"92":{"title":"硬核图解红黑树并手写实现","titles":[]},"93":{"title":"前言","titles":["硬核图解红黑树并手写实现"]},"94":{"title":"平衡查找树","titles":["硬核图解红黑树并手写实现"]},"95":{"title":"2-3树","titles":["硬核图解红黑树并手写实现","平衡查找树"]},"96":{"title":"查找","titles":["硬核图解红黑树并手写实现","平衡查找树","2-3树"]},"97":{"title":"插入","titles":["硬核图解红黑树并手写实现","平衡查找树","2-3树"]},"98":{"title":"基于2-3树实现的左倾红黑树","titles":["硬核图解红黑树并手写实现","平衡查找树"]},"99":{"title":"红黑树性质解释","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"100":{"title":"2-3树在左倾红黑树中表示","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"101":{"title":"判断节点的颜色","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"102":{"title":"旋转","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"103":{"title":"变色","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"104":{"title":"插入","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"105":{"title":"向单键节点插入","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树","插入"]},"106":{"title":"向双键节点中插入","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树","插入"]},"107":{"title":"删除","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"108":{"title":"删除最小值","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树","删除"]},"109":{"title":"删除最大值","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树","删除"]},"110":{"title":"删除任意节点","titles":["硬核图解红黑树并手写实现","平衡查找树","基于2-3树实现的左倾红黑树"]},"111":{"title":"画出红黑树来验证实现","titles":["硬核图解红黑树并手写实现","平衡查找树"]},"112":{"title":"总结","titles":["硬核图解红黑树并手写实现"]},"113":{"title":"基于拉链式和线性探测式散列表实现Map","titles":[]},"114":{"title":"前言","titles":["基于拉链式和线性探测式散列表实现Map"]},"115":{"title":"散列函数","titles":["基于拉链式和线性探测式散列表实现Map"]},"116":{"title":"Integer","titles":["基于拉链式和线性探测式散列表实现Map","散列函数",null]},"117":{"title":"Long","titles":["基于拉链式和线性探测式散列表实现Map","散列函数",null]},"118":{"title":"Double、Float","titles":["基于拉链式和线性探测式散列表实现Map","散列函数",null]},"119":{"title":"String","titles":["基于拉链式和线性探测式散列表实现Map","散列函数",null]},"120":{"title":"软缓存","titles":["基于拉链式和线性探测式散列表实现Map","散列函数",null]},"121":{"title":"拉链式的散列表","titles":["基于拉链式和线性探测式散列表实现Map"]},"122":{"title":"线性探测式散列表","titles":["基于拉链式和线性探测式散列表实现Map"]},"123":{"title":"初始化","titles":["基于拉链式和线性探测式散列表实现Map","线性探测式散列表",null]},"124":{"title":"插入","titles":["基于拉链式和线性探测式散列表实现Map","线性探测式散列表",null]},"125":{"title":"动态调整数组的大小","titles":["基于拉链式和线性探测式散列表实现Map","线性探测式散列表",null]},"126":{"title":"查询","titles":["基于拉链式和线性探测式散列表实现Map","线性探测式散列表",null]},"127":{"title":"删除元素","titles":["基于拉链式和线性探测式散列表实现Map","线性探测式散列表",null]},"128":{"title":"图算法系列之无向图的数据结构","titles":[]},"129":{"title":"前言","titles":["图算法系列之无向图的数据结构"]},"130":{"title":"图的定义","titles":["图算法系列之无向图的数据结构"]},"131":{"title":"图的术语","titles":["图算法系列之无向图的数据结构"]},"132":{"title":"如何表示出图","titles":["图算法系列之无向图的数据结构"]},"133":{"title":"无向图的API定义","titles":["图算法系列之无向图的数据结构"]},"134":{"title":"无向图API的实现","titles":["图算法系列之无向图的数据结构"]},"135":{"title":"图的常用工具方法","titles":["图算法系列之无向图的数据结构"]},"136":{"title":"总结","titles":["图算法系列之无向图的数据结构"]},"137":{"title":"图算法系列之深度优先搜索（一）","titles":[]},"138":{"title":"前言","titles":["图算法系列之深度优先搜索（一）"]},"139":{"title":"搜索API的定义","titles":["图算法系列之深度优先搜索（一）"]},"140":{"title":"深度优先搜索","titles":["图算法系列之深度优先搜索（一）"]},"141":{"title":"寻找路径的API","titles":["图算法系列之深度优先搜索（一）"]},"142":{"title":"基于深度优先搜索查找图中的可达路径","titles":["图算法系列之深度优先搜索（一）"]},"143":{"title":"图算法系列之深度优先搜索（二）","titles":[]},"144":{"title":"连通分量","titles":["图算法系列之深度优先搜索（二）"]},"145":{"title":"连通分量的API定义","titles":["图算法系列之深度优先搜索（二）","连通分量",null]},"146":{"title":"连通分量的API实现","titles":["图算法系列之深度优先搜索（二）","连通分量",null]},"147":{"title":"单元测试","titles":["图算法系列之深度优先搜索（二）","连通分量",null]},"148":{"title":"检查无向图中是否有环","titles":["图算法系列之深度优先搜索（二）"]},"149":{"title":"检查无向图是否是二分图","titles":["图算法系列之深度优先搜索（二）"]},"150":{"title":"图算法系列之计算图中最短路径","titles":[]},"151":{"title":"前言","titles":["图算法系列之计算图中最短路径"]},"152":{"title":"广度优先搜索","titles":["图算法系列之计算图中最短路径"]},"153":{"title":"符号图","titles":["图算法系列之计算图中最短路径"]}},"dirtCount":0,"index":[["实际的过程可以根据具体情况来确定",{"2":{"153":1}}],["实现的思路",{"2":{"148":1,"153":1}}],["实现散列表的另一种方式就是用大小为m来保存n个键值",{"2":{"122":1}}],["实现散列表的第一步就是需要考虑如何把一个键转换为数组的下标",{"2":{"115":1}}],["实现所需的代码相对较小",{"2":{"98":1}}],["实现优先级队列的最简单实现可以参考",{"2":{"64":1}}],["实现归并算法还有另一种思路",{"2":{"53":1}}],["实现2",{"2":{"26":1}}],["实现思路",{"2":{"13":1}}],["z",{"2":{"153":1}}],["值对应字符串名称",{"2":{"153":1}}],["值都是在同一分量中的另一个触点的名称",{"2":{"38":1}}],["字符串",{"2":{"153":1}}],["哈希表实现map等等",{"2":{"153":1}}],["符号图",{"0":{"153":1}}],["来看看广度优先搜索的运行轨迹",{"2":{"152":1}}],["来聊一点算法吧",{"0":{"24":1}}],["取出队列中的下一个顶点v并标记它",{"2":{"152":1}}],["依然使用之前定义的寻找路径的api",{"2":{"152":1}}],["依然是递归",{"2":{"88":1}}],["广度优先搜索",{"0":{"152":1}}],["演员与演员直接也不会有边",{"2":{"149":1}}],["演员作为一个顶点",{"2":{"149":1}}],["电影与电影直接是不会有边",{"2":{"149":1}}],["电影与演员的关系",{"2":{"149":1,"153":1}}],["电影作为一个顶点",{"2":{"149":1}}],["举个实际的例子就很好理解",{"2":{"149":1}}],["举例",{"2":{"7":2}}],["白色节点是另一个集合",{"2":{"149":1}}],["何为二分图",{"2":{"149":1}}],["何为连通",{"0":{"27":1}}],["方法dfs的参数v表示需要待搜索的顶点",{"2":{"148":1}}],["方法修改一下",{"2":{"73":1}}],["标记已经搜索过的每个顶点",{"2":{"148":1}}],["标记它被已经访问",{"2":{"140":1}}],["检查无向图是否是二分图",{"0":{"149":1}}],["检查无向图中是否有环",{"0":{"148":1}}],["检查两个顶点是否连通",{"2":{"145":1}}],["更重要的是union",{"2":{"147":1}}],["统计连通分量的总数",{"2":{"145":1}}],["统计出连通分量的数量",{"2":{"36":1}}],["什么是连通分量",{"2":{"144":1}}],["知道了如何通过深度优先搜索在图中寻找路径",{"2":{"143":1}}],["知道遇到左子树为null的时候就结束",{"2":{"87":1}}],["验证结果完全匹配了父链树",{"2":{"142":1}}],["记录了edgeto的变化以及父链树的逐渐形成",{"2":{"142":1}}],["记录当前节点所在子树的节点个数",{"2":{"84":1}}],["画图来详细跟踪深度优先搜索的运行轨迹",{"2":{"142":1}}],["画出删除之后的红黑树",{"2":{"111":1}}],["画出删除之前的红黑树",{"2":{"111":1}}],["画出红黑树来验证实现",{"0":{"111":1}}],["父链树在之前的文章中也使用过",{"2":{"142":1}}],["父节点变为黑色",{"2":{"107":1}}],["父节点变成红色",{"2":{"103":1}}],["换句话说",{"2":{"141":1}}],["寻找路径的api",{"0":{"141":1}}],["构建一张图",{"2":{"140":1}}],["构建下面这张图",{"2":{"140":1}}],["构造这样一个图",{"2":{"147":1}}],["构造方法提供了一个图对象",{"2":{"139":1}}],["构造函数会初始化空的邻接表数组",{"2":{"134":1}}],["构造堆",{"0":{"74":1},"2":{"73":1}}],["单元测试的代码",{"2":{"152":1}}],["单元测试",{"0":{"147":1},"2":{"140":1}}],["单向的链表包含了值和下一个节点的引用",{"2":{"22":1}}],["递归的访问与之相连的所有邻接点",{"2":{"140":1}}],["递归这个过程",{"2":{"56":1}}],["继续选择一条未走过的通道",{"2":{"140":1}}],["继续改进提升效率",{"2":{"81":1}}],["深度优先搜索的实现思路就和走迷宫的方式一样",{"2":{"140":1}}],["深度优先搜索",{"0":{"140":1},"2":{"136":1,"138":1}}],["顶点v所在连通分量的标识",{"2":{"145":1}}],["顶点的度数就等于与之相连接顶点的个数",{"2":{"135":1}}],["顶点1的度数是3",{"2":{"131":1}}],["条边",{"2":{"134":1}}],["创建含有v个顶点不含边的图",{"2":{"133":1}}],["邻接表数组",{"2":{"132":1}}],["邻接矩阵",{"2":{"132":1}}],["包含两个int属性表示顶点",{"2":{"132":1}}],["包括后面我们的删除操作也会使用到",{"2":{"87":1}}],["边的数组",{"2":{"132":1}}],["键入有v个顶点的图",{"2":{"132":1}}],["可能会很大",{"2":{"132":1}}],["可以来源于数据库",{"2":{"153":1}}],["可以定义一个表示的边对象",{"2":{"132":1}}],["可以使用integer",{"2":{"121":1}}],["可以参考文章",{"2":{"132":1}}],["可以参考前面的文章",{"2":{"121":1}}],["可以参考我的git仓库中的代码",{"2":{"112":1}}],["可以与2",{"2":{"100":1}}],["可以查看",{"2":{"81":1}}],["可以在实际的工作中根据需要选择适合的map",{"2":{"78":1}}],["可以自己思考下使用第一个位置",{"2":{"71":1}}],["可以先将数组分为两个数组分别排序",{"2":{"50":1}}],["可以排序任意的对象",{"2":{"43":1}}],["可以",{"2":{"27":1}}],["太多也不太容易记得住",{"2":{"131":1}}],["太少数据又会不均匀",{"2":{"12":1}}],["暂时这里只列出本篇我们需要使用到的术语",{"2":{"131":1}}],["术语还有很多",{"2":{"131":1}}],["某个顶点的度数即表示连接这个顶点的边的总数",{"2":{"131":1}}],["连接同一对顶点的边称为平行边",{"2":{"131":1}}],["连接两个顶点的边没有方向",{"2":{"130":1}}],["连通分量的总数应该是3",{"2":{"147":1}}],["连通分量的api实现",{"0":{"146":1}}],["连通分量的api定义",{"0":{"145":1}}],["连通分量数减一",{"2":{"37":1}}],["连通分量",{"0":{"34":1,"144":1},"1":{"145":1,"146":1,"147":1}}],["拓扑排序等",{"2":{"129":1}}],["地图上的位置",{"2":{"153":1}}],["地图上求路径的最短距离",{"2":{"129":1}}],["地图功能",{"2":{"151":1}}],["地址或者计算机等等",{"2":{"31":1}}],["垃圾回收器的标记清除算法",{"2":{"129":1}}],["吐血整理程序员必读书单",{"2":{"128":1}}],["9",{"2":{"127":1,"147":1}}],["发生碰撞冲突之后直接把索引加一来检查下一个位置",{"2":{"122":1}}],["发现红黑树很好的表示了2",{"2":{"100":1}}],["线性探测式的删除稍微麻烦一些",{"2":{"127":1}}],["线性探测式散列表使用两个数组来存放keys和values",{"2":{"123":1}}],["线性探测式散列表",{"0":{"122":1},"1":{"123":1,"124":1,"125":1,"126":1,"127":1}}],["线性探测散列表中实现查询的思路",{"2":{"126":1}}],["线性探测的主要思路",{"2":{"122":1}}],["解决碰撞冲突就需要利用数组中的空位",{"2":{"122":1}}],["解决了初级版本实现的问题",{"2":{"71":1}}],["扩容之后需要把原来的值重新插入到扩容之后的数组中",{"2":{"121":1}}],["越短的数组出现碰撞的几率会增大",{"2":{"121":1}}],["拉链法可以使用原始的链表保存键",{"2":{"121":1}}],["拉链式的散列表",{"0":{"121":1}}],["拉链式和线性探测",{"2":{"114":1}}],["软缓存",{"0":{"120":1}}],["浮点类型的键java中hashcode的实现是将键表示为二进制",{"2":{"118":1}}],["^",{"2":{"117":1}}],["之后再与值相异或",{"2":{"117":1}}],["之后提供二叉树",{"2":{"78":1}}],["默认的hashcode返回的是对象的内存地址",{"2":{"115":1}}],["散列函数能够将键值转换成数组的下标",{"2":{"121":1}}],["散列函数",{"0":{"115":1},"1":{"116":1,"117":1,"118":1,"119":1,"120":1}}],["散列表的主要目的在于把键值均匀的分布到数组中",{"2":{"121":1}}],["散列表的版本实现",{"2":{"78":1}}],["散列表实现map主要分为了两个步骤",{"2":{"114":1}}],["处理散列值冲突的情况",{"2":{"114":1}}],["处于同一分量不做处理",{"2":{"38":1,"39":1}}],["链表中存放的值就是与该顶点相连的顶点",{"2":{"132":1}}],["链表",{"2":{"114":1}}],["程序员必读书单",{"2":{"113":1}}],["~galles",{"2":{"112":1}}],["给出一个红黑树网站演示",{"2":{"112":1}}],["给的解决方案就是加一层虚拟层",{"2":{"12":1}}],["顺序打印出node的执行的结果",{"2":{"111":1}}],["编写单元来测试我们用红黑树实现的map",{"2":{"111":1}}],["叶子节点直接结束",{"2":{"110":1}}],["唯一不同的只有最后三个if操作",{"2":{"106":1}}],["防止变色操作把根节点变为红色",{"2":{"106":1}}],["若左右子节点都是红色",{"2":{"106":1}}],["若左子节点是红色且他的左子节点也是红色",{"2":{"106":1}}],["若右子节点是红色",{"2":{"106":1}}],["若有不妥",{"2":{"3":1}}],["再进行变色",{"2":{"108":1}}],["再执行删除",{"2":{"108":1}}],["再执行删除操作",{"2":{"108":1}}],["再右旋",{"2":{"106":1}}],["再次找出剩余元素中最小的元素与数组中的第二个元素进行交换",{"2":{"44":1}}],["转换颜色",{"2":{"103":1}}],["变化过程如下图",{"2":{"106":1}}],["变色",{"0":{"103":1}}],["变相删除了c",{"2":{"80":1}}],["左节点是黑色",{"2":{"106":1}}],["左子节点是黑树",{"2":{"106":1}}],["左子树不为空",{"2":{"110":1}}],["左子树中查找",{"2":{"110":1}}],["左子树为空就与右子树最小值进行交换",{"2":{"110":1}}],["左子树",{"2":{"88":1}}],["左右两个子节点是红色",{"2":{"103":1}}],["左旋代码实现如下",{"2":{"102":1}}],["左旋",{"2":{"102":1}}],["旋转",{"0":{"102":1}}],["但他的兄弟是一个双键节点",{"2":{"108":1}}],["但在一些国外网站上有看到",{"2":{"99":1}}],["但是在实际的场景中",{"2":{"153":1}}],["但是在处理大量数据的情况下效率依然很低",{"2":{"81":1}}],["但是深度优先搜索与顶点的输入有很大的关系",{"2":{"151":1}}],["但是他们没有构成环",{"2":{"148":1}}],["但是union",{"2":{"147":1}}],["但是union的算法是无法处理大型数据的",{"2":{"37":1}}],["但是通常在随着数据量的增大",{"2":{"121":1}}],["但是如何验证我们的红黑树是不是真正的红黑树",{"2":{"111":1}}],["但是如果需要找到某个顶点的相连顶点有哪些",{"2":{"132":1}}],["但是如果插入的数据是有序的",{"2":{"91":1}}],["但是如果遇到需要删除有两个节点的节点应该怎么操作呢",{"2":{"90":1}}],["但是如果虚拟节点太多会影响查找的性能",{"2":{"12":1}}],["但是我们需要保证待删除的节点是一个双键的节点",{"2":{"108":1}}],["但是只能是左右两边各一个红色节点",{"2":{"99":1}}],["但是这个方式有个问题",{"2":{"132":1}}],["但是这在2",{"2":{"99":1}}],["但是这是理论",{"2":{"97":1}}],["但是这是面试官最喜欢问的知识点",{"2":{"93":1}}],["但是很多都是从红黑树的性质来讲红黑树",{"2":{"93":1}}],["但是为了保证文章的完整性",{"2":{"84":1}}],["但是对于数据量稍大的情况下",{"2":{"83":1}}],["但是优先级队列从上面的实现过程",{"2":{"66":1}}],["但是子数组可能是aux",{"2":{"52":1}}],["但是经过仔细思考之后",{"2":{"52":1}}],["但是现在的算法就是完美的吗",{"2":{"12":1}}],["但是hash算法也有缺点",{"2":{"7":1}}],["此时我们会想到之前文章实现的map",{"2":{"153":1}}],["此时的节点就是最小值",{"2":{"87":1}}],["此时的节点就是最大值",{"2":{"87":1}}],["此处与删除最小值不同",{"2":{"109":1}}],["此处提到的叶子其实是空链接",{"2":{"99":1}}],["此性质在百度百科中未出现",{"2":{"99":1}}],["此性质可以基于2",{"2":{"99":1}}],["此性质还是基于红色节点的作用来理解",{"2":{"99":1}}],["黑色节点表示二叉树中的普通节点",{"2":{"99":1}}],["即使用一个变量把这个值保存起来",{"2":{"120":1}}],["即左倾红黑树",{"2":{"98":1}}],["即将两个有序的数组合并成一个有序的数组",{"2":{"51":1}}],["了解了红黑树的理论模型2",{"2":{"98":1}}],["导致二叉树退化成了链表",{"2":{"97":1}}],["向图中添加一条边",{"2":{"133":1}}],["向双键节点中插入新的键有三种情况",{"2":{"106":1}}],["向双键节点中插入",{"0":{"106":1}}],["向双键key的节点中插入",{"2":{"97":2}}],["向单键节点插入",{"0":{"105":1}}],["向单键key的节点中插入",{"2":{"97":1}}],["向栈添加元素",{"2":{"20":1}}],["允许树中的节点保存多个键值",{"2":{"95":1}}],["平衡查找树",{"0":{"94":1},"1":{"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1}}],["红色节点的作用是什么",{"2":{"93":1,"99":1}}],["红黑树实现map",{"2":{"153":1}}],["红黑树来实现map的操作",{"2":{"114":1}}],["红黑树的删除最小值类似",{"2":{"108":1}}],["红黑树的插入操作前半部分和上一篇实现的二叉树的插入操作一致",{"2":{"106":1}}],["红黑树经过左旋右旋之后最终都会达到父节点是黑色",{"2":{"103":1}}],["红黑树作为了2",{"2":{"99":1}}],["红黑树性质解释",{"0":{"99":1}}],["红黑树与2",{"2":{"94":1}}],["红黑树对应的理论模型可以是2",{"2":{"94":1}}],["红黑树是近似平衡的二叉树",{"2":{"94":1}}],["红黑树几乎是完美平衡的",{"2":{"93":1}}],["红黑树于我们上一篇讨论的二叉树相比",{"2":{"93":1}}],["红黑树算是数据结构中比较有难度的知识点",{"2":{"93":1}}],["红黑树",{"2":{"78":1}}],["为什么规定红色节点只能出现在左节点",{"2":{"98":1}}],["为什么根节点必须是黑色",{"2":{"93":1,"99":1}}],["为什么节点要区分颜色",{"2":{"93":1,"99":1}}],["为了满足实际的场景",{"2":{"153":1}}],["为了保存路径",{"2":{"152":1}}],["为了保证树的绝对平衡",{"2":{"95":1}}],["为了保证quick",{"2":{"39":1}}],["为了找出最短路径",{"2":{"152":1}}],["为了减小实现的复杂度",{"2":{"148":1}}],["为了判断两个顶点是否相连",{"2":{"146":1}}],["为了统计出图中总共有多少连通分量",{"2":{"146":1}}],["为了展示",{"2":{"140":1}}],["为了加深对红黑树的理解",{"2":{"112":1}}],["为了代码的实现简单",{"2":{"108":1}}],["为了改进这个问题",{"2":{"83":1}}],["为了体现出我们的map是有序的",{"2":{"81":1}}],["为了学习并掌握常用的数据结构",{"2":{"78":1}}],["为了避免最糟糕的情况出现",{"2":{"58":1}}],["为了避免这种情况出现",{"2":{"57":1}}],["为了让我们实现的排序算法更加的通用",{"2":{"43":1}}],["为了让应用本地的缓存命中率最高",{"2":{"16":1}}],["为了提高union方法的速度",{"2":{"38":1}}],["为了提高缓存的命中率",{"2":{"7":1}}],["为了解决hash算法容错性和伸缩性的问题",{"2":{"7":1}}],["结点是红色或黑色",{"2":{"93":1,"99":1}}],["结果存放到a",{"2":{"51":1}}],["结果我突然觉得嗓子不舒服咳嗽了几声",{"2":{"18":1}}],["性能下降",{"2":{"97":1}}],["性能优化",{"2":{"4":1}}],["性质6",{"2":{"93":1,"99":1}}],["性质5",{"2":{"93":1,"99":1}}],["性质4",{"2":{"93":1,"99":1}}],["性质3",{"2":{"93":1,"99":1}}],["性质2",{"2":{"93":1,"99":1}}],["性质1",{"2":{"93":1,"99":1}}],["带着问题去学习红黑树",{"2":{"93":1}}],["针对最后两种情况",{"2":{"108":1}}],["针对每一条性质我们都需要问一个why",{"2":{"93":1}}],["针对随机算法的问题",{"2":{"7":1}}],["理解并掌握了本篇内容也就掌握了红黑树",{"2":{"112":1}}],["理解并掌握红黑树还是有必要的",{"2":{"93":1}}],["理想情况下插入和查询操作时间复杂度都是log",{"2":{"88":1}}],["改善上一篇中二叉树版本的不足",{"2":{"93":1}}],["硬核图解红黑树并手写实现",{"0":{"92":1},"1":{"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"112":1}}],["调用删除最大值或者删除最小值",{"2":{"90":1}}],["步骤",{"2":{"90":1}}],["两个子节点变为红色",{"2":{"107":1}}],["两种思路",{"2":{"90":1}}],["两周之后我又收到了hr的电话",{"2":{"18":1}}],["代码如下",{"2":{"89":1,"98":1}}],["代码实现如下",{"2":{"103":1,"109":1,"110":1,"153":1}}],["代码实现",{"2":{"44":1,"45":1,"46":1,"47":1,"58":1,"86":1,"90":1}}],["沿着左边路径一直深入",{"2":{"89":1}}],["删除了7之后",{"2":{"127":1}}],["删除元素之后需要把当前索引之后的连续位置上的元素重新插入",{"2":{"127":1}}],["删除元素",{"0":{"127":1}}],["删除之后的红黑树",{"2":{"111":1}}],["删除之后我们需要重新分解3建节点",{"2":{"108":1}}],["删除之前的红黑树",{"2":{"111":1}}],["删除任意节点",{"0":{"110":1}}],["删除",{"0":{"90":1,"107":1},"1":{"108":1,"109":1}}],["删除最大值需要从左节点中借一个节点",{"2":{"109":1}}],["删除最大值思路和删除最小值的思路类似",{"2":{"109":1}}],["删除最大值",{"0":{"109":1}}],["删除最大值和最小值",{"0":{"89":1}}],["删除最小值的代码实现如下",{"2":{"108":1}}],["删除最小值",{"0":{"108":1},"2":{"89":1}}],["删除某个节点有两种思路",{"2":{"80":1}}],["而不在是使用递归来实现",{"2":{"152":1}}],["而不是固定取第一个",{"2":{"58":1}}],["而union",{"2":{"147":1}}],["而标记不会让你重复走已经走过的通道",{"2":{"140":1}}],["而在红黑树中只有通过使用红色节点与父节点组成2",{"2":{"99":1}}],["而2",{"2":{"97":1}}],["而红黑树是基于接口的实现",{"2":{"94":1}}],["而树的形状取决于数据输入的顺序",{"2":{"91":1}}],["而且二叉树的插入与查询操作一样简单",{"2":{"88":1}}],["查找命中",{"2":{"96":1}}],["查找键与节点中的键比较",{"2":{"96":1}}],["查找",{"0":{"96":1}}],["查找的算法使用二分查找法",{"2":{"26":1}}],["查询出最大值和最小值",{"0":{"87":1}}],["查询",{"0":{"86":1,"126":1}}],["右旋代码实现如下",{"2":{"102":1}}],["右旋",{"2":{"102":1}}],["右子树不为空",{"2":{"110":1}}],["右子树中查找",{"2":{"110":1}}],["右子树",{"2":{"88":1}}],["右子树的个数",{"2":{"84":1}}],["右边下标是2k+2",{"2":{"73":1}}],["右边的元素都是大于它的值",{"2":{"56":1}}],["并且画出红黑树验证是否正确",{"2":{"111":1}}],["并且可能会破坏红黑树的性质",{"2":{"107":1}}],["并且修改节点的颜色",{"2":{"102":1}}],["并且我们规定红色节点只能出现在左节点",{"2":{"98":1}}],["并且父节点也是双键",{"2":{"97":1}}],["并且能够保证操作的运行时间都是对数级别",{"2":{"93":1}}],["并且每个节点的key都大于其左子树中的任意节点",{"2":{"84":1}}],["并通过二叉树来实现上一篇中定义的map结构",{"2":{"83":1}}],["并找到高效的解决方案",{"2":{"4":1}}],["很快o",{"2":{"81":1}}],["很多性能瓶颈都可以通过优化算法来解决",{"2":{"4":1}}],["虽然在实际的业务开发工作中使用的不多",{"2":{"93":1}}],["虽然大家都知道二叉树是什么",{"2":{"84":1}}],["虽然get方法采用的二分查找法",{"2":{"81":1}}],["虽然java中已经提供了很多map的实现",{"2":{"78":1}}],["的二进制表示就是除了首位是",{"2":{"121":1}}],["的值",{"2":{"81":1}}],["的方法",{"2":{"21":1}}],["老哥是时候来复习下数据结构与算法了",{"2":{"81":1,"121":1,"125":1}}],["老哥确定不来复习下数据结构吗",{"0":{"17":1},"1":{"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1},"2":{"61":1,"64":2,"66":1}}],["非常的低效",{"2":{"80":1}}],["分析",{"0":{"91":1}}],["分析上面基于链表实现的map",{"2":{"80":1}}],["分布式缓存集群的访问模型",{"0":{"7":1}}],["节点的数据结构定义",{"2":{"84":1}}],["节点",{"2":{"80":1}}],["节省空间",{"2":{"55":1}}],["节省复制元素到辅助数组的时间",{"2":{"52":1}}],["表示已经图中存在环",{"2":{"148":1}}],["表示已找到直接返回value",{"2":{"86":1}}],["表示从顶点v出发的连通分量中某个顶点的邻接顶点是v",{"2":{"148":1}}],["表示查询的key不存在",{"2":{"126":1}}],["表示他是正数",{"2":{"121":1}}],["表示我们需要存储的key",{"2":{"80":1}}],["表示的意义",{"2":{"38":1}}],["堆排序代码实现",{"0":{"76":1}}],["堆排序的过程主要有两个阶段",{"2":{"73":1}}],["图中每条边所连接的顶点都属于不同的部分",{"2":{"149":1}}],["图用什么数据结构来表示主要参考两个要求",{"2":{"132":1}}],["图的常用工具方法",{"0":{"135":1}}],["图的表示的数据结构是基础",{"2":{"132":1}}],["图的术语",{"0":{"131":1}}],["图的定义",{"0":{"130":1}}],["图",{"2":{"130":1}}],["图算法系列之计算图中最短路径",{"0":{"150":1},"1":{"151":1,"152":1,"153":1}}],["图算法系列之深度优先搜索",{"0":{"137":1,"143":1},"1":{"138":1,"139":1,"140":1,"141":1,"142":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1}}],["图算法系列之无向图的数据结构",{"0":{"128":1},"1":{"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1}}],["图算有很多相当实用算法",{"2":{"129":1}}],["图形变化如下",{"2":{"106":1}}],["图未完全画完",{"2":{"75":1}}],["图解堆排序",{"0":{"72":1},"1":{"73":1,"74":1,"75":1,"76":1}}],["输入数组",{"2":{"74":1}}],["开始之前",{"2":{"73":1}}],["开关机",{"2":{"0":1}}],["或者",{"2":{"98":1}}],["或者是用右子树中的最小值替换待删除节点",{"2":{"90":1}}],["或者是在社交网络中判断两个人是否是朋友关系",{"2":{"29":1}}],["或者最大",{"2":{"73":1}}],["注意",{"2":{"71":1}}],["释放内存",{"2":{"71":1}}],["增加堆的大小",{"2":{"71":1}}],["增强面试竞争力",{"2":{"4":1}}],["入队和出队的时间复杂对都是logn",{"2":{"71":1}}],["入队操作",{"2":{"71":1}}],["入队列",{"2":{"23":1,"61":1}}],["会造成空间的浪费",{"2":{"132":1}}],["会破坏堆有序",{"2":{"68":1}}],["会把数据存放到集群3上面",{"2":{"10":1}}],["它的两个子节点的位置为2k和2k+1",{"2":{"68":1}}],["它们是编程能力的核心",{"2":{"4":1}}],["位置k节点的父节点的位置为k",{"2":{"68":1}}],["重新指定两个节点的左右子树的链接",{"2":{"102":1}}],["重点",{"2":{"68":1}}],["重复递归这个过程",{"2":{"50":1}}],["二",{"0":{"143":1},"1":{"144":1,"145":1,"146":1,"147":1,"148":1,"149":1}}],["二叉树",{"2":{"114":1}}],["二叉树删除最小值就是一直沿着树的左子树中查找",{"2":{"108":1}}],["二叉树的生长是由上向下生长的",{"2":{"97":1}}],["二叉树的每个节点都包含了一个key",{"2":{"84":1}}],["二叉树中相对比较麻烦的操作就是删除操作",{"2":{"89":1}}],["二叉树中每个节点都包含了两个指针指向自己的左子树和右子树",{"2":{"84":1}}],["二叉树简介",{"0":{"84":1}}],["二叉堆的表示",{"2":{"68":1}}],["二叉堆的定义",{"0":{"68":1}}],["二叉堆实现优先级队列",{"0":{"71":1}}],["二叉堆实现",{"0":{"67":1},"1":{"68":1,"69":1,"70":1,"71":1}}],["二分查找",{"2":{"19":1}}],["二分查找法的时间复杂度是o",{"2":{"26":1}}],["二分查找法之所以快是因为每次一次查询都会排除掉一半的值",{"2":{"19":1}}],["二分查找法是在一个有序的数组中查到一个值",{"2":{"19":1}}],["循环一遍数组",{"2":{"64":1}}],["循环这个过程直到左右两个指针相遇",{"2":{"56":1}}],["队列api的抽象类",{"0":{"63":1}}],["队列api定义",{"0":{"61":1}}],["初级版本的实现",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1}}],["初始化",{"0":{"123":1}}],["初始化变量",{"2":{"58":1}}],["初始化数组大小",{"2":{"20":1}}],["初始默认第一个元素就是有序的",{"2":{"46":1}}],["优先级队列是一种抽象的数据结构",{"2":{"61":1}}],["优化算法不仅可以减少时间复杂度",{"2":{"4":1}}],["优化实现",{"2":{"4":1}}],["系统需要优先处理权重较高的事件",{"2":{"60":1}}],["原来实现优先级队列如此简单",{"0":{"59":1},"1":{"60":1,"61":1,"62":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1},"2":{"73":1}}],["原地归并实现",{"0":{"51":1}}],["都大于切分元素",{"2":{"58":1}}],["都小于切分元素",{"2":{"58":1}}],["都没能够把这两个特点结合起来",{"2":{"55":1}}],["维护一个指针lt",{"2":{"58":1}}],["思路就是先随意选择一个切分元素",{"2":{"58":1}}],["三向切分",{"2":{"58":1}}],["切换到插入排序",{"2":{"58":1}}],["简单实现",{"2":{"58":1}}],["执行的结果与我们分析的运行轨迹一致",{"2":{"152":1}}],["执行快速排序的过程如图",{"2":{"57":1}}],["执行结果",{"2":{"15":2}}],["80",{"2":{"111":3}}],["8",{"2":{"57":1,"74":1,"111":1,"140":1,"142":1,"147":1,"152":1}}],["7",{"2":{"57":1,"74":1,"97":1,"127":1,"140":2,"142":1,"147":1,"152":1}}],["6926685994347397127",{"2":{"132":1}}],["60",{"2":{"111":2}}],["6",{"2":{"57":1,"74":1,"97":1,"140":2,"142":2,"147":1,"152":2}}],["主要有两种情况",{"2":{"68":1}}],["主要的特点是基于原地排序",{"2":{"55":1}}],["主要谈了常用的初级算法",{"2":{"49":1}}],["快速排序也是一种分治的排序算法",{"2":{"56":1}}],["快速排序思路",{"0":{"56":1}}],["快速排序可以说是使用最广的排序算法了",{"2":{"55":1}}],["快速排序算法实现及优化",{"0":{"54":1},"1":{"55":1,"56":1,"57":1,"58":1}}],["保证每一位都用用到",{"2":{"117":1}}],["保证我们在进行排序的时候直接使用原始的数组",{"2":{"73":1}}],["保证随机性",{"2":{"58":1}}],["保证了切分元素左边的值都是小于它的值",{"2":{"56":1}}],["保证了array整体排序完成",{"2":{"52":1}}],["保证小的数组有序再归并",{"2":{"52":1}}],["修改之后的完整代码如下",{"2":{"52":1}}],["修复之后的dosort方法",{"2":{"52":1}}],["减小堆大小",{"2":{"71":1}}],["减小h步长继续排序子数组",{"2":{"47":1}}],["减少merge操作",{"2":{"52":1}}],["该网站实现红黑树的方式与本篇我们实现的方式不同",{"2":{"112":1}}],["该定义要求key必须实现接口comparable",{"2":{"81":1}}],["该算法还有可以优化的地方",{"2":{"52":1}}],["该方法中需要使用的上一篇中的公共函数",{"2":{"51":1}}],["以下图为列",{"2":{"152":1}}],["以下是基础算法重要性的几个方面",{"2":{"4":1}}],["以及一个起点s",{"2":{"139":1}}],["以及基于这种数据结构实现了几个简单的工具方法",{"2":{"136":1}}],["以及使用哪种数据结构来表示一张图",{"2":{"129":1}}],["以上的递归算法只是一个开始",{"2":{"141":1}}],["以上是红黑树删除最小值会遇到的所有情况",{"2":{"108":1}}],["以上代码是标准的递归归并排序操作",{"2":{"52":1}}],["省略其他函数",{"2":{"64":1,"65":1,"71":1}}],["省略",{"2":{"52":1}}],["dfs",{"2":{"140":3,"142":3,"146":3,"148":3,"149":3}}],["double",{"0":{"118":1},"2":{"135":1}}],["dosort",{"2":{"52":14}}],["draw",{"2":{"111":2}}],["d",{"2":{"80":1,"153":1}}],["data",{"2":{"64":2,"65":2}}],["disorderpriorityqueue",{"2":{"64":2}}],["depthfirstcc",{"2":{"145":2,"146":2,"147":2}}],["depthfirstpaths",{"2":{"142":4}}],["depthfirstsearch",{"2":{"140":3}}],["degree++",{"2":{"135":1}}],["degree",{"2":{"135":7}}],["desktop",{"2":{"111":2}}],["dest=array",{"2":{"52":1}}],["dest",{"2":{"52":10}}],["default",{"2":{"43":3,"79":2,"85":2}}],["dequeue时间复杂度是o",{"2":{"64":1,"65":1}}],["dequeue可以参考选择排序的实现",{"2":{"64":1}}],["dequeue",{"2":{"23":2,"61":1,"64":1,"65":1,"71":1,"152":1}}],["deletemax",{"2":{"85":1,"89":4,"90":1,"109":4,"110":1}}],["deletemin",{"2":{"85":1,"89":4,"108":4,"110":1}}],["delete方法实现",{"2":{"81":1}}],["delete方法实现同样也需要遍历链表",{"2":{"80":1}}],["delete都需要遍历整个链表",{"2":{"80":1}}],["delete",{"2":{"0":1,"79":1,"80":1,"81":1,"85":1,"90":5,"110":5,"111":3,"121":2,"127":1}}],["基于深度优先搜索实现的连通性检查理论上说要比以前实现的union",{"2":{"147":1}}],["基于深度优先搜索查找图中的可达路径",{"0":{"142":1}}],["基于图数据结构的实现",{"2":{"135":1}}],["基于散列函数将被查找键转换为数组的下标",{"2":{"114":1}}],["基于拉链式和线性探测式散列表实现map",{"0":{"113":1},"1":{"114":1,"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1,"122":1,"123":1,"124":1,"125":1,"126":1,"127":1}}],["基于2",{"0":{"98":1},"1":{"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1},"2":{"99":1}}],["基于这个问题",{"2":{"91":1}}],["基于这点",{"2":{"68":1}}],["基于二叉树实现map",{"0":{"82":1,"85":1},"1":{"83":1,"84":1,"85":1,"86":2,"87":2,"88":2,"89":2,"90":2,"91":2},"2":{"93":1,"102":1}}],["基于rank方法",{"2":{"81":2}}],["基于数组实现的map",{"2":{"81":1}}],["基于数组实现map",{"0":{"81":1}}],["基于数组或链表实现map",{"0":{"77":1},"1":{"78":1,"79":1,"80":1,"81":1},"2":{"85":1,"121":1}}],["基于堆的实现",{"2":{"71":1}}],["基于链表的实现非常低效",{"2":{"81":1}}],["基于链表的实现与上面的类似",{"2":{"66":1}}],["基于链表实现首先我们需要定义一个node节点",{"2":{"80":1}}],["基于链表实现map",{"0":{"80":1}}],["基于链表实现",{"0":{"66":1}}],["基于有序数组实现就是在入队的时候保证数组有序",{"2":{"65":1}}],["基于有序数组实现",{"0":{"65":1}}],["基于无序数组实现的enqueue时间复杂度是o",{"2":{"64":1}}],["基于无序数组实现",{"0":{"64":1}}],["基于分而治之的思想",{"2":{"52":1}}],["基础算法和数据结构是大多数技术面试中的重要考点",{"2":{"4":1}}],["基础算法不仅仅是计算机科学教育的起点",{"2":{"4":1}}],["基础算法篇",{"0":{"4":1}}],["基础知识显得格外重要",{"2":{"1":1}}],["自底向上的归并排序",{"0":{"53":1}}],["自顶向下的归并排序",{"0":{"52":1}}],["自反性",{"2":{"31":1}}],["待实现",{"2":{"51":1}}],["待续",{"2":{"27":1}}],["参考",{"2":{"102":1}}],["参考上一篇文章",{"2":{"51":1}}],["参考书籍",{"2":{"40":1}}],["中实现的动态调整数据的大小",{"2":{"125":1}}],["中我们定义了map的接口",{"2":{"85":1}}],["中我们实现的栈和队列的操作都能够在常数时间内完成",{"2":{"66":1}}],["中栈的实现方式",{"2":{"64":1}}],["中",{"2":{"51":1}}],["中的值都是相同的",{"2":{"37":1}}],["归并成一个有序的数组",{"2":{"51":1}}],["归并排序的优点是它能够保证任意长度为n的数组排序所需的时间与",{"2":{"50":1}}],["归并排序算法思路",{"0":{"50":1}}],["额外的空间与n成正比",{"2":{"50":1}}],["缺点是因为归并操作需要引入额外的数组",{"2":{"50":1}}],["缺点也很明显",{"2":{"7":1}}],["成正比",{"2":{"50":1}}],["贝塔学java",{"2":{"48":1,"113":1,"128":1}}],["微信公众号",{"2":{"48":1,"113":1,"128":1}}],["死磕归并排序算法",{"0":{"48":1},"1":{"49":1,"50":1,"51":1,"52":1,"53":1}}],["graph",{"2":{"133":2,"134":2,"135":15,"139":2,"140":20,"141":2,"142":21,"145":2,"146":10,"147":13,"148":9,"149":10,"152":22,"153":10}}],["github",{"2":{"113":1,"128":1}}],["g",{"2":{"80":1}}],["gt=hi",{"2":{"58":1}}],["gt+1",{"2":{"58":1}}],["gt",{"2":{"58":8,"80":9,"122":1,"127":2,"134":2,"142":1}}],["gap",{"2":{"47":12}}],["getcolor",{"2":{"98":1}}],["getright",{"2":{"98":1}}],["getleft",{"2":{"98":1}}],["get方法实现",{"2":{"81":1}}],["get方法的实现思路是遍历链表",{"2":{"80":1}}],["get",{"2":{"79":2,"80":3,"81":1,"85":2,"86":5,"93":1,"121":2,"126":1,"153":4}}],["getnext",{"2":{"22":2,"23":2}}],["getitem",{"2":{"22":2,"23":2}}],["子数组排序之后都是部分有序的",{"2":{"47":1}}],["子类自己去实现",{"2":{"43":1}}],["各个子数组都很短",{"2":{"47":1}}],["元素只能一点一点的从数组中移动到正确的位置",{"2":{"47":1}}],["希尔排序高效的原因",{"2":{"47":1}}],["希尔排序基于这两个特点对插入排序进行了改进",{"2":{"47":1}}],["希尔排序",{"0":{"47":1}}],["内层循环就直接结束了",{"2":{"46":1}}],["插入之后造成了两个红色节点相连",{"2":{"106":1}}],["插入之后只需要变化颜色即可",{"2":{"106":1}}],["插入的键值最大",{"2":{"106":1}}],["插入的过程和插入排序类似的操作",{"2":{"65":1}}],["插入操作的实现思路",{"2":{"88":1}}],["插入",{"0":{"88":1,"97":1,"104":1,"124":1},"1":{"105":1,"106":1}}],["插入到该位置上",{"2":{"46":1}}],["插入排序对于部分有序的数组排序是的效率很高",{"2":{"47":1}}],["插入排序的思路类似",{"2":{"46":1}}],["插入排序",{"0":{"46":1},"2":{"52":2,"58":1}}],["想象我们在玩扑克牌时",{"2":{"46":1}}],["想要继续问我java相关的一些问题",{"2":{"18":1}}],["操作完成之后就可以排定一个最大的元素",{"2":{"45":1}}],["操作显然是很快的",{"2":{"37":1}}],["直到找到一个位置为null的才结束",{"2":{"124":1}}],["直到找个比当前节点大的父节点或者已上浮到了根节点",{"2":{"69":1}}],["直到遇到一个节点的左子树为null",{"2":{"89":1,"108":1}}],["直到遇到右子树为null的时候就结束",{"2":{"87":1}}],["直到整个数组有序",{"2":{"52":1,"53":1}}],["直到数组整体有序",{"2":{"50":1}}],["直到数组中所有的元素都有序",{"2":{"45":1}}],["直到h步长为1",{"2":{"47":1}}],["直到所有元素有序",{"2":{"46":1}}],["直到最后一个元素",{"2":{"45":1}}],["直接返回当前的value值",{"2":{"116":1}}],["直接删除",{"2":{"108":1}}],["直接在当前节点新增一个key",{"2":{"97":1}}],["直接上图",{"2":{"109":1}}],["直接上机撸代码",{"2":{"26":1}}],["直接上代码",{"2":{"13":1}}],["直接看代码",{"2":{"19":1}}],["比较当前节点和父节点",{"2":{"69":1}}],["比较相邻的两个元素",{"2":{"45":1}}],["比如二叉树的查找方法",{"2":{"93":1}}],["比如",{"0":{"24":1},"2":{"80":1,"129":1,"151":1,"153":1}}],["冒泡排序",{"0":{"45":1}}],["交换a",{"2":{"58":2}}],["交换这两个值",{"2":{"56":1}}],["交换的次数与数组的大小是线性关系",{"2":{"44":1}}],["交换数组中的两个对象",{"2":{"43":1}}],["选择排序的是数据移动最少的",{"2":{"44":1}}],["选择排序",{"0":{"44":1}}],["打印出数据中的每个元素",{"2":{"43":1}}],["定义一个数组",{"2":{"132":1}}],["定义的方法签名为merge",{"2":{"51":1}}],["定义的公用方法",{"2":{"43":2}}],["定义两个栈",{"2":{"24":1}}],["排序算法的模板",{"0":{"43":1}}],["排序算法往往是其他算法的基础",{"2":{"42":1}}],["本篇主要讨论的是基于2",{"2":{"112":1}}],["本篇主要是通过数组和链表两种方式实现",{"2":{"78":1}}],["本篇中我们实现的2",{"2":{"98":1}}],["本篇我们继续一起来学习深度优先搜索算法的其他应用场景",{"2":{"143":1}}],["本篇我们继续使用该map接口",{"2":{"85":1}}],["本篇我们主要学习使用何种数据结构来表示一张图",{"2":{"136":1}}],["本篇我们先从无向图开始学习",{"2":{"129":1}}],["本篇我们将采用深度优先搜索的方式来找出图中的所有连通分量",{"2":{"144":1}}],["本篇我们将一起开始学习图算法的第一个搜索算法",{"2":{"138":1}}],["本篇我们将会一起来学习基于散列表来实现map",{"2":{"114":1}}],["本篇我们将会使用红黑树来实现map",{"2":{"93":1}}],["本篇我们将来学习二叉树",{"2":{"83":1}}],["本篇我们一起来学习实现优先级队列的常用方式",{"2":{"60":1}}],["本篇我们谈一种基于归并操作完成排序的算法",{"2":{"49":1}}],["本文我们就先从初级排序算法开始学习算法",{"2":{"42":1}}],["本站所有文章和资源仅为个人工作和学习中的记录",{"2":{"3":1}}],["相信这些方法对于java程序员来说不会陌生",{"2":{"79":1}}],["相信所有的程序员刚开始接触到的算法都会是排序算法",{"2":{"42":1}}],["相连具有以下特性",{"2":{"31":1}}],["相连",{"0":{"31":1}}],["相连表示是朋友关系",{"2":{"29":1}}],["常见的初级排序算法",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1},"2":{"49":1,"51":1,"57":1}}],["常用的路由算法",{"2":{"7":1}}],["树的高度也不会结构也不会发生变化",{"2":{"107":1}}],["树的高度",{"2":{"40":2}}],["总结",{"0":{"40":1,"112":1,"136":1}}],["由此我们可以看出在最坏的情况下2",{"2":{"97":1}}],["由此可以得出union方法的时间复杂度是o",{"2":{"39":1}}],["由下向上恢复堆有序",{"0":{"70":1}}],["由上向下恢复堆有序",{"0":{"69":1}}],["由于图是无向图",{"2":{"148":1}}],["由于是无向图",{"2":{"135":1}}],["由于是左倾红黑树",{"2":{"100":1}}],["由于hashcode需要返回的值就是一个int值",{"2":{"116":1}}],["由于如何画出红黑树不是本篇的重点",{"2":{"111":1}}],["由于根节点必须为黑色的性质",{"2":{"106":1}}],["由于只允许左边出现红色节点",{"2":{"105":1}}],["由于旋转操作完成之后需要修改父节点的链接",{"2":{"102":1}}],["由于红黑树本身也是二叉树",{"2":{"98":1}}],["由于2",{"2":{"98":1}}],["由于数组中的每个位置已经是堆的节点",{"2":{"74":1}}],["由于我们需要找出可达的路径",{"2":{"142":1}}],["由于我们需要在二叉树中表示出双键的节点",{"2":{"98":1}}],["由于我们需要动态的缩小堆的大小",{"2":{"73":1}}],["由于我们整个数组都是有序的",{"2":{"81":1}}],["由于我们为了方便计算父节点和子节点的索引位置",{"2":{"71":1}}],["由于第一次调用dosort传入的是src=aux",{"2":{"52":1}}],["由于随机分发请求",{"2":{"7":1}}],["合并之后的高度变成了n+1",{"2":{"39":1}}],["高度都是n",{"2":{"39":1}}],["他们都包含了2的n次方个节点",{"2":{"39":1}}],["加权quick",{"0":{"39":1},"2":{"40":1}}],["加入集群1跪了",{"2":{"12":1}}],["考虑了这两个要求之后大佬们提出以下三个方法来供选择",{"2":{"132":1}}],["考虑最糟糕的情况",{"2":{"46":1,"57":1}}],["考虑最佳情况下",{"2":{"38":1}}],["考虑到最糟糕的输入情况",{"2":{"38":1}}],["根结点是黑色",{"2":{"93":1,"99":1}}],["根本未从红黑树的理论模型出发讲红黑树",{"2":{"93":1}}],["根节点本身没有父节点",{"2":{"99":1}}],["根节点",{"2":{"38":1}}],["根据待查询key的hash函数计算出索引的位置",{"2":{"126":1}}],["根据key从小到大顺序打印出节点",{"2":{"111":1}}],["根据以上各种情况的分析",{"2":{"106":1}}],["根据当前的节点k找到父节点的位置k",{"2":{"69":1}}],["根据快速排序算法的思路",{"2":{"57":1}}],["根据物理节点的名字生成虚拟节点的名字",{"2":{"13":1}}],["根据一些大神的经验给出的建议是",{"2":{"12":1}}],["根据名字hash之后的位置在集群1和集群2之间",{"2":{"11":1}}],["根据名字的hash值计算出每组集群应该放在什么位置",{"2":{"9":1}}],["根据缓存数据的key计算出hash值",{"2":{"9":1}}],["找出来的路径也不一定是最短的",{"2":{"151":1}}],["找出最大值和数组最后一个元素交换",{"2":{"64":1}}],["找出q",{"2":{"38":1,"39":1}}],["找出p所在分量的根触点",{"2":{"38":1,"39":1}}],["数字的映射",{"2":{"153":1}}],["数组",{"2":{"146":2}}],["数组就是一颗由父链表示的一颗树",{"2":{"142":1}}],["数组中每个元素都是一个链表对象",{"2":{"132":1}}],["数组的下标对应数字顶点",{"2":{"153":1}}],["数组的大小为顶点的个数",{"2":{"132":1}}],["数组的扩容可以参考之前的文章",{"2":{"121":1}}],["数组大小动态扩容和缩容依然可以参考之前栈的实现方式",{"2":{"71":1}}],["数组用父链接的形式表示了森林",{"2":{"38":1}}],["数据下标表示顶点",{"2":{"132":1}}],["数据结构使用在前几篇中已经实现的linkedmap",{"2":{"121":1}}],["数据分布不均匀造成数据倾斜问题",{"2":{"12":1}}],["数据倾斜问题",{"0":{"12":1}}],["因为检查连通性深度优先搜索实现的版本能够保证在常量时间内完成",{"2":{"147":1}}],["因为是无向图",{"2":{"134":1}}],["因为是否有空位对于线性探测式散列表的查找至关重要",{"2":{"127":1}}],["因为数组的大小变了需要重新计算索引的位置",{"2":{"125":1}}],["因为第一位是符号位",{"2":{"121":1}}],["因为之前我们的操作可能会导致3键节点的存在",{"2":{"108":1}}],["因为递归时已经保住的父节点是双键节点",{"2":{"108":1}}],["因为删除操作可能会造成树不平衡",{"2":{"107":1}}],["因为优先插入建到当前节点组成2",{"2":{"99":1}}],["因为在红色节点表示与父节点同层高",{"2":{"99":1}}],["因为put方法还是太慢",{"2":{"81":1}}],["因为每次操作都需要遍历链表",{"2":{"81":1}}],["因为每次都需要变量整个数组",{"2":{"37":1}}],["因为我们的是单向链表",{"2":{"80":1}}],["因为排序在对数据处理和计算有这重要的地位",{"2":{"42":1}}],["因为union不需要为每对输入遍历整个数组",{"2":{"38":1}}],["因为需要key是顺序的存储",{"2":{"13":1}}],["时间复杂度为o",{"2":{"80":1}}],["时间复杂度o",{"2":{"37":1}}],["时间复杂度是o",{"2":{"26":1,"46":1}}],["判断是否存在顶点",{"2":{"153":1}}],["判断是否连通的connected的方法就是判断id",{"2":{"37":1}}],["判断节点的颜色",{"0":{"101":1}}],["判断返回的keys",{"2":{"81":2}}],["判断出从s",{"2":{"141":1,"152":1}}],["判断出p与q是否存在于同一个分量中",{"2":{"36":1}}],["判断出输入的整数对是否是相连的",{"2":{"35":1}}],["接下来我们来写单元测试校验下生成的父链树和实际的运行结果是否一致",{"2":{"142":1}}],["接下来我们就主要来讨论如何实现union方法和find方法",{"2":{"36":1}}],["接下来就是把虚拟节点放入到一致性hash环上",{"2":{"12":1}}],["抽象实现如下",{"2":{"36":1}}],["每条边连接的两个顶点属于不同的集合",{"2":{"149":1}}],["每条边都被记录了两次",{"2":{"135":1}}],["每条边都有两个顶点",{"2":{"135":1}}],["每遇到一个路口就用笔标记一下",{"2":{"140":1}}],["每种类型的键我们都需要一个不同的散列函数",{"2":{"115":1}}],["每一层递归操作都会让子数组有序",{"2":{"52":1}}],["每一次union操作都会找出每个分量的根节点进行归并",{"2":{"38":1}}],["每个顶点都需要存一个标识值",{"2":{"146":1}}],["每个节点都将大于等于它的子节点",{"2":{"68":1}}],["每个节点的链接都指向自己",{"2":{"38":1}}],["每个事件都定义了不同的权重值",{"2":{"60":1}}],["每个触点所对应的id",{"2":{"38":1}}],["每个触点表示一个分量",{"2":{"36":1}}],["每次删除之后都需要检测一次数组中实际元素的个数",{"2":{"127":1}}],["每次新插入的节点都必须是红色",{"2":{"93":1,"99":1}}],["每次的put",{"2":{"80":1}}],["每次union归并的树都是大小相等的",{"2":{"39":1}}],["每次查找都与中间值",{"2":{"19":1}}],["每次将请求随机的发送到其中一组redis集群中",{"2":{"7":1}}],["usfca",{"2":{"112":1}}],["users",{"2":{"111":2}}],["upsplit",{"2":{"103":1,"106":1}}],["underflow",{"2":{"108":1,"109":1,"110":1}}],["unchecked",{"2":{"58":1}}],["union算法最糟糕的情况不在出现",{"2":{"39":1}}],["union算法比quick",{"2":{"38":1}}],["union算法",{"0":{"38":1,"39":1},"2":{"40":2}}],["union操作会使两个分量归并",{"2":{"36":1}}],["union",{"0":{"36":1},"2":{"35":1,"36":1,"37":1,"38":1,"39":1,"40":2,"142":1,"144":1}}],["uf",{"2":{"36":2}}],["否则就是非连通",{"2":{"146":1}}],["否则就返回",{"2":{"19":1}}],["否则返回false",{"2":{"101":1}}],["否则返回null",{"2":{"80":1}}],["否则继续去对应的子树中去查找",{"2":{"96":1}}],["否则忽略掉这对整数",{"2":{"35":1}}],["动态调整数组的大小",{"0":{"125":1}}],["动态连通性",{"0":{"35":1}}],["动态规划等问题",{"2":{"4":1}}],["将v相邻的所有未被标记的顶点加入到队列",{"2":{"152":1}}],["将最大的根节点删除",{"2":{"71":1}}],["将新的元素添加到数组末尾",{"2":{"71":1}}],["将两个分量归并之后数量减一",{"2":{"36":1}}],["将等价类称作连通分量或者简称分量",{"2":{"34":1}}],["将整数对称为连接",{"2":{"34":1}}],["将计算的结果再次压入到操作数栈",{"2":{"24":1}}],["整个数组将会是有序的",{"2":{"75":1}}],["整个网络中的某种对象称为触点",{"2":{"33":1}}],["整理扑克牌都是把每一张插入到左边已经排好序的牌中适当的位置",{"2":{"46":1}}],["整数对p",{"2":{"31":1}}],["触点",{"0":{"33":1}}],["假设构造图的顶点与边是通过字符串来表示的",{"2":{"153":1}}],["假设我们有一条无限长的绳子",{"2":{"140":1}}],["假设相连是一个种等价关系",{"2":{"32":1}}],["假如从顶点v出发存在环",{"2":{"148":1}}],["假如上图是一个迷宫",{"2":{"140":1}}],["假如我们的数据是有序的",{"2":{"81":1}}],["假如我们从构建好的优先级队列中持续调用删除最小",{"2":{"73":1}}],["假如你设计的事件系统中有很多的事件",{"2":{"60":1}}],["假如你是微信的开发人员",{"0":{"27":1}}],["假如需要排序的数组是已经有序的",{"2":{"57":1}}],["假如输入的数组是有序的",{"2":{"44":1}}],["假如输入一对整数",{"2":{"31":1}}],["假如这个数组有100万的int值",{"0":{"26":1}}],["假如每组集群都分配了2个虚拟节点",{"2":{"12":1}}],["假如其中",{"2":{"10":1}}],["假如现在有5个数据需要缓存对应的key分别为key1",{"2":{"9":1}}],["假如当前我们系统的业务发展很快",{"2":{"7":1}}],["等于",{"2":{"58":1}}],["等价类",{"0":{"32":1}}],["等待着面试官的到来",{"2":{"18":1}}],["后面的表示与顶点v相连的相邻顶点",{"2":{"153":1}}],["后面有在使用到其他的术语再做解释",{"2":{"131":1}}],["后面再插入操作中可以看到详细的转变过程",{"2":{"103":1}}],["后面我们聊到一种算法符号表",{"2":{"31":1}}],["后续的版本都会基于此接口实现",{"2":{"79":1}}],["后期我们聊到图算法可以给出具体的路径",{"2":{"40":1}}],["后端技术",{"2":{"2":1}}],["传递性",{"2":{"31":1}}],["qroot",{"2":{"38":3,"39":7}}],["qid",{"2":{"37":3}}],["q",{"2":{"36":4,"37":3,"38":2,"39":2}}],["q是相连的",{"2":{"35":1}}],["q时",{"2":{"35":1}}],["q与r相连",{"2":{"31":1}}],["q理解为",{"2":{"31":1}}],["quick3waysort",{"2":{"58":1}}],["quicksort",{"2":{"57":5,"58":7}}],["quickunionimpl",{"2":{"38":2}}],["quickfindimpl",{"2":{"37":2}}],["quick",{"0":{"37":1,"38":1},"2":{"40":2}}],["quot",{"2":{"29":4}}],["queue",{"2":{"23":2,"61":1,"63":1,"64":8,"65":8,"69":3,"70":5,"71":6,"73":6,"152":6}}],["人",{"2":{"31":1}}],["人美声甜的小姐姐",{"2":{"18":1}}],["概念",{"0":{"30":1},"1":{"31":1,"32":1,"33":1,"34":1,"35":1}}],["通过数字顶点返回对应的字符名称",{"2":{"153":1}}],["通过名称返回对应的数字顶点",{"2":{"153":1}}],["通过二叉树实现map",{"2":{"153":1}}],["通过同一条边相连的两个顶点我们称这两个顶点相邻",{"2":{"131":1}}],["通过上面的三种情况的演示",{"2":{"97":1}}],["通过rank方法判断该key是否存在",{"2":{"81":1}}],["通过自己手写各个版本的map实现",{"2":{"78":1}}],["通过移动数组的下标来找到节点父节点和子节点",{"2":{"68":1}}],["通过选择合适的排序算法可以大幅度提高数据处理的效率",{"2":{"4":1}}],["通常都是使用的字符作为顶点而非数字",{"2":{"153":1}}],["通常情况下我们很多时候需要找出图中的最短路径",{"2":{"151":1}}],["通常选择的是数组的第一个元素",{"2":{"56":1}}],["通常我们可能需要处理数百万的对象和数亿的连接",{"2":{"29":1}}],["有兴趣的同学可以去翻翻",{"2":{"153":1}}],["有兴趣的可以自己实现",{"2":{"66":1}}],["有需要添加一条w",{"2":{"134":1}}],["有需要的朋友可以去仓库中查看",{"2":{"111":1}}],["有一种方式是数组中的每一个元素都指向一个链表用来存放散列值相同的对象",{"2":{"121":1}}],["有比较好的性能",{"2":{"97":1}}],["有两种方式来处理冲突",{"2":{"114":1}}],["有两种方法",{"2":{"26":1}}],["有两个办法",{"2":{"58":1}}],["有时候我们可以需要判断在大型网络中两台计算机是否相连",{"2":{"29":1}}],["言归正传",{"2":{"29":1}}],["好了",{"2":{"29":1}}],["菡萏香销翠叶残",{"2":{"29":1}}],["心目中女神的形象瞬间碎了",{"2":{"29":1}}],["身体发福了",{"2":{"29":1}}],["濯清涟而不妖",{"2":{"29":1}}],["出队操作",{"2":{"71":1}}],["出队列",{"2":{"23":1,"61":1}}],["出淤泥而不染",{"2":{"29":1}}],["停更了很多天",{"2":{"29":1}}],["春节放假会了老家",{"2":{"29":1}}],["拖延时间战术",{"2":{"27":1}}],["今天烧脑严重",{"2":{"27":1}}],["美丽的面试官",{"2":{"27":1}}],["美女面试官",{"2":{"18":1}}],["args",{"2":{"153":1}}],["array",{"2":{"43":8,"44":5,"45":5,"46":5,"47":5,"51":1,"52":33,"53":3,"57":13,"58":26,"63":5,"76":5}}],["arrays",{"2":{"26":2,"153":3}}],["arr",{"2":{"19":5,"20":5,"21":9,"25":5,"26":11}}],["avgdegree",{"2":{"135":1}}],["append",{"2":{"134":9}}],["api的定义",{"0":{"79":1}}],["adj",{"2":{"133":1,"134":8,"135":2,"140":1,"142":1,"146":1,"148":1,"149":1,"152":1}}],["addedge",{"2":{"133":1,"134":1,"140":8,"142":8,"147":9,"152":8,"153":1}}],["and",{"2":{"118":1}}],["aux",{"2":{"51":8,"52":5,"53":9}}],["abstractqueue",{"2":{"63":2,"64":1,"65":1,"71":1}}],["abstractuf",{"2":{"36":2,"37":1,"38":1,"39":1}}],["abstract",{"2":{"36":1,"63":1}}],["a是b的好友",{"0":{"27":1}}],["a",{"2":{"26":1,"43":4,"51":7,"52":1,"53":6,"58":4,"63":2,"74":1,"80":1,"153":2}}],["只看节点的变化可能不太直观",{"2":{"100":1}}],["只允许存在左节点是因为能够减少可能出现的情况",{"2":{"98":1}}],["只是重新定义id",{"2":{"38":1}}],["只能这么快了",{"2":{"26":1}}],["只需要找出数组中是否有",{"2":{"26":1}}],["只要每组集群对应的虚拟节点越多",{"2":{"12":1}}],["第三个if判断如果左右两个子节点都是红色",{"2":{"106":1}}],["第三种情况插入的键值在原来两键之间",{"2":{"106":1}}],["第二步就是需要处理碰撞冲突",{"2":{"121":1}}],["第二个if判断处理如果左节点时红色且他的左节点也是红色",{"2":{"106":1}}],["第二中实现",{"2":{"80":1}}],["第二是在partition方法中随机取切分元素",{"2":{"58":1}}],["第二种情况是插入的键值最小",{"2":{"106":1}}],["第二种",{"2":{"26":1,"80":1}}],["第一个if判断处理如果右节点是红色",{"2":{"106":1}}],["第一是在排序数组之前先随机打乱数组",{"2":{"58":1}}],["第一种实现",{"2":{"80":1}}],["第一种",{"2":{"26":1,"80":1}}],["与之前一样没扫描到一个顶点我们就需要标记这个顶点",{"2":{"146":1}}],["与之前的优先级排序有些差别",{"2":{"73":1}}],["与真正的实现还是有一段距离",{"2":{"97":1}}],["与查询操作类似",{"2":{"88":1}}],["与key进行比较",{"2":{"81":2}}],["与a",{"2":{"51":1,"58":2}}],["与3",{"2":{"26":1}}],["与栈的实现过程类似",{"2":{"23":1}}],["要区分颜色主要是想要在二叉树中来表示出2",{"2":{"99":1}}],["要删除",{"2":{"80":1}}],["要实现上面定义的api",{"2":{"134":1}}],["要实现该操作较麻烦",{"2":{"52":1}}],["要实现动态的调整大小",{"2":{"21":1}}],["要将一个数组排序",{"2":{"50":1}}],["要与另一个数相加等于0",{"2":{"26":1}}],["用一颗父链树来表示根节点到所有连通顶点的最短路径",{"2":{"152":1}}],["用最大值或者最小值替换当前的节点",{"2":{"90":1}}],["用左子树的最大值替换待删除节点",{"2":{"90":1}}],["用插入排序将h个子数组独立排序",{"2":{"47":1}}],["用这个算法会浪费小姐姐的大好青春",{"2":{"26":1}}],["用二分查找法最多需要log2n",{"2":{"19":1}}],["没想到这次回家遇到了她",{"2":{"29":1}}],["没想等来的是一位美女小姐姐",{"2":{"18":1}}],["没有考虑到大量数据的情况",{"2":{"26":1}}],["k>",{"2":{"79":1,"81":1,"85":2}}],["k++",{"2":{"25":1,"51":1,"52":1,"53":1}}],["k",{"2":{"25":3,"51":6,"52":6,"53":6,"69":8,"70":6,"73":6,"76":4,"79":5,"80":6,"81":7,"84":2,"85":10,"86":2,"87":1,"88":1,"90":2,"98":2,"106":2,"110":2,"121":8,"123":2,"124":1,"125":1,"126":1,"127":1}}],["key为字符串",{"2":{"153":1}}],["keys",{"2":{"79":1,"81":11,"85":1,"123":2,"124":3,"125":3,"126":2,"127":6,"153":6}}],["key1",{"2":{"9":1}}],["key5存放在了集群2",{"2":{"9":1}}],["key5",{"2":{"9":1}}],["key4",{"2":{"9":1}}],["key3的时候根据顺时针查找",{"2":{"10":1}}],["key3存放在了集群1",{"2":{"9":1}}],["key3",{"2":{"9":1}}],["key2存放在了集群3",{"2":{"9":1}}],["key2",{"2":{"9":1}}],["key",{"2":{"7":3,"19":4,"79":5,"80":19,"81":13,"84":4,"85":6,"86":9,"87":1,"88":6,"90":9,"98":4,"106":10,"110":11,"121":11,"124":6,"126":5,"127":5,"153":9}}],["juejin",{"2":{"132":1}}],["java中每个char都可以表示成一个int值",{"2":{"119":1}}],["java中long类型的hashcode计算是先把值无符号右移32位",{"2":{"117":1}}],["java中的string就是采用的这种方式",{"2":{"120":1}}],["java中的约定",{"2":{"115":1}}],["java中的hashmap当链表的节点数超过了8个就会把链表转换成红黑树",{"2":{"93":1}}],["java中的map主要就是将一个键和一个值联系起来",{"2":{"78":1}}],["j++",{"2":{"25":1,"26":1,"44":1,"45":1,"51":2,"52":2,"53":2,"81":1}}],["j",{"2":{"25":4,"26":4,"43":3,"44":4,"45":6,"46":7,"47":7,"51":3,"52":17,"53":3,"57":7,"58":14,"63":3,"81":13,"134":2}}],["请看代码",{"2":{"25":1}}],["其余都是1",{"2":{"121":1}}],["其次这种方式没办法表示平行边",{"2":{"132":1}}],["其次是计算每个子树所包含的节点个数",{"2":{"102":1}}],["其次我们数组的下标是从0开始的",{"2":{"73":1}}],["其实就是节点颜色的变化",{"2":{"103":1}}],["其实右边也是可以的",{"2":{"98":1}}],["其实对于长度为n的数组使用快速排序时间复杂度为",{"2":{"55":1}}],["其实将它和数组中的第一个元素进行交换",{"2":{"44":1}}],["其实是没想到好的解法",{"2":{"27":1}}],["其中红色节点表示一个集合",{"2":{"149":1}}],["其中m",{"2":{"122":1}}],["其中0x7fffffff",{"2":{"121":1}}],["其中一个节点将会上浮",{"2":{"103":1}}],["其中size的计算在前面已经说到",{"2":{"88":1}}],["其中根节点是最大的节点",{"2":{"68":1}}],["其中的入队列enqueue和出队列dequeue是我们主要需要实现的方式",{"2":{"61":1}}],["其中exch",{"2":{"57":1}}],["其中每个数字表示的是某种对象",{"2":{"31":1}}],["其中存在三个数字相加等于0",{"0":{"25":1}}],["其他使用场景",{"0":{"16":1}}],["其他数据不受影响",{"2":{"11":1}}],["其他数据存放的位置不受影响",{"2":{"10":1}}],["||",{"2":{"24":3,"81":1}}],["弹出所需要的操作数",{"2":{"24":1}}],["弹出一个运算符",{"2":{"24":1}}],["遇到右括号",{"2":{"24":1}}],["遇到符号就压入符号栈",{"2":{"24":1}}],["遇到数字就压入操作数栈",{"2":{"24":1}}],["忽略左边括号",{"2":{"24":1}}],["属于临场发挥",{"2":{"24":1}}],["挠挠头",{"2":{"24":1}}],["刚好看到了这个解法",{"2":{"24":1}}],["刚才你提到了链表",{"0":{"22":1}}],["刚才故意没说动态调整大小",{"2":{"21":1}}],["昨天晚上熬夜看算法没白辛苦啊",{"2":{"24":1}}],["50",{"2":{"111":1}}],["5",{"0":{"24":1},"2":{"52":2,"57":1,"58":1,"97":1,"111":1,"127":1,"140":3,"142":4,"147":3,"152":4}}],["胃开的差不多了",{"0":{"24":1}}],["首节点为空",{"2":{"23":1}}],["首先我们需要先回到2",{"2":{"107":1}}],["首先我们需要先定义出优先级队的api",{"2":{"61":1}}],["首先设置一个步长h用来分隔出子数组",{"2":{"47":1}}],["首先找到数组中的最小元素",{"2":{"44":1}}],["首先排序",{"2":{"26":1}}],["首先把3",{"2":{"26":1}}],["首先需要查找出待删除的元素位置",{"2":{"127":1}}],["首先需要定义出队列",{"2":{"23":1}}],["首先需要先定义个node",{"2":{"22":1}}],["首先需要在提供一个",{"2":{"21":1}}],["首先看下栈的定义",{"2":{"20":1}}],["采用链表实现的栈相对于数组实现还较为简单一些",{"2":{"22":1}}],["和一支粉笔",{"2":{"140":1}}],["和前面实现查找最小值有些相似",{"2":{"89":1}}],["和小姐姐的互动很和谐",{"2":{"22":1}}],["和hi",{"2":{"19":1}}],["x",{"2":{"102":12}}],["x26",{"2":{"21":2,"46":2,"47":2,"52":4,"58":2,"65":2,"69":2,"73":2,"81":4,"106":6,"108":10,"109":4,"110":8,"118":4,"119":2,"121":1,"127":2}}],["x3c",{"2":{"19":2,"20":6,"21":1,"22":8,"23":10,"24":4,"25":3,"26":3,"36":1,"37":1,"39":2,"43":1,"44":2,"45":2,"46":1,"47":2,"51":2,"52":5,"53":4,"58":4,"61":2,"63":5,"64":4,"65":3,"70":1,"71":3,"73":2,"79":2,"80":2,"81":8,"85":6,"86":1,"88":1,"90":1,"106":1,"110":1,"111":2,"119":1,"121":6,"125":3,"127":1,"133":1,"134":6,"135":3,"141":1,"142":3,"146":1,"148":1,"149":1,"152":6,"153":4}}],["让新元素上浮到适合位置",{"2":{"71":1}}],["让垃圾回收器回收无用对象",{"2":{"21":1}}],["让我先来帮你开个胃",{"0":{"19":1}}],["让我们继续来看刚才容错性的例子",{"2":{"12":1}}],["避免游离对象",{"2":{"21":1}}],["就可以进行缩容操作",{"2":{"127":1}}],["就需要扩容到原来的2倍",{"2":{"124":1}}],["就需要回到数组的开始位置继续查找",{"2":{"124":1}}],["就需要把数据的容量缩小到原来的一半",{"2":{"21":1}}],["就把d节点完全复制到c中",{"2":{"80":1}}],["就把数组扩容2倍",{"2":{"21":1}}],["就和优先级队列的插入过一样",{"2":{"74":1}}],["就是先归并哪些小的数组",{"2":{"53":1}}],["就好像达芬奇再次遇到了蒙娜丽莎",{"2":{"29":1}}],["一",{"0":{"137":1},"1":{"138":1,"139":1,"140":1,"141":1,"142":1}}],["一条边连接了一个顶点与其自身",{"2":{"131":1}}],["一次递归可以排定所有等于切分元素的值",{"2":{"58":1}}],["一开始我们有n个分量",{"2":{"36":1}}],["一个数a",{"2":{"26":1}}],["一个int类型的数组",{"0":{"25":1}}],["一个用户保存操作数",{"2":{"24":1}}],["一个用于保存运算符",{"2":{"24":1}}],["一上来就说出了最优解",{"2":{"21":1}}],["一致性哈希算法",{"0":{"8":1},"1":{"9":1,"10":1,"11":1,"12":1}}],["一致性hash算法由此而生~",{"2":{"7":1}}],["一致性hash算法java版实现",{"0":{"5":1,"13":1},"1":{"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":2,"15":2,"16":1}}],["经过上面的分析之后我们现在可以来代码实现红黑树的插入操作",{"2":{"106":1}}],["经过大脑快速思考后",{"2":{"26":1}}],["经过多年的面试经验总结",{"2":{"21":1}}],["经过容错性",{"2":{"12":1}}],["已猜到你会问这个问题了",{"2":{"21":1}}],["那在红黑树中应该如何来表示这个操作呢",{"2":{"103":1}}],["那你先休息10分钟",{"2":{"27":1}}],["那如何实现动态调整栈的大小",{"0":{"21":1}}],["那么顶点v中的邻接表中有w",{"2":{"148":1}}],["那么可以表示成edgeto",{"2":{"142":1}}],["那么可以这样考虑找到出路",{"2":{"140":1}}],["那么可以直接删除",{"2":{"110":1}}],["那么表示图中有环",{"2":{"148":1}}],["那么表示v存在一个自环",{"2":{"135":1}}],["那么表示当前节点与父节点共同组成了2",{"2":{"99":1}}],["那么表示当前节点和父节点共同组成了2",{"2":{"98":1}}],["那么把v行w列设置为true",{"2":{"132":1}}],["那么直接把待插入对象放入到这个空位",{"2":{"122":1}}],["那么直接新增一个红色左节点",{"2":{"105":1}}],["那么索引加一继续查找",{"2":{"122":1}}],["那么值就修改值",{"2":{"122":1}}],["那么散列表都不适合",{"2":{"121":1}}],["那么我可以这个计算好的值缓存起来",{"2":{"120":1}}],["那么我们可以直接进行删除操作",{"2":{"107":1}}],["那么我们就可以跳过merge方法",{"2":{"52":1}}],["那么hashcode一定相同",{"2":{"115":1}}],["那么左子树不为空就与左子树中最大值进行交换",{"2":{"110":1}}],["那么先借一个节点到右边来",{"2":{"109":1}}],["那么通过变色与父节点共同形成三键节点之后",{"2":{"108":1}}],["那么通过旋转移动一个节点到左子节点形成双键节点之后",{"2":{"108":1}}],["那么如果保证当前递归节点是一个双键节点呢",{"2":{"108":1}}],["那么在搜索的过程中必定会再次遇到顶点v",{"2":{"148":1}}],["那么在最后找到的最小值就一定会在一个双键节点中",{"2":{"108":1}}],["那么在出队列的时候可以直接删掉最大值",{"2":{"65":1}}],["那么插入一个红色的右节点",{"2":{"105":1}}],["那么插入排序的效率和选择排序一样",{"2":{"46":1}}],["那么插入排序算法会很快",{"2":{"46":1}}],["那么与父节点组成了3键的节点",{"2":{"99":1}}],["那么二叉树就会演变成链表",{"2":{"91":1}}],["那么get方法将无法查询到9这个元素",{"2":{"127":1}}],["那么get方法会加快很多",{"2":{"81":1}}],["那么get",{"2":{"91":2}}],["那么这个当前节点就是最小值",{"2":{"89":1}}],["那么这组集群上面的key会相对均匀的分摊到其他集群上",{"2":{"12":1}}],["那么查找的时候我们可以使用二分查找法",{"2":{"81":1}}],["那么就执行与删除最大值类似的变化",{"2":{"110":1}}],["那么就执行与删除最小值类似的变化",{"2":{"110":1}}],["那么就删除该节点",{"2":{"108":1}}],["那么就进行变色",{"2":{"106":1}}],["那么就进行颜色转换",{"2":{"106":1}}],["那么就进行右旋",{"2":{"106":2}}],["那么就进行左旋",{"2":{"106":2}}],["那么就可以基于2",{"2":{"98":1}}],["那么就可以把数组的所有元素进行排序",{"2":{"73":1}}],["那么就理解了红黑树本质",{"2":{"93":1}}],["那么就新建一个node放到链表的开头",{"2":{"80":1}}],["那么就交换两个元素的位置",{"2":{"45":1}}],["那么子节点和父节点的位置应该如何计算",{"2":{"71":1}}],["那么当前索引位置直接往后移动",{"2":{"46":1}}],["那么union方法的时间复杂度o",{"2":{"38":1}}],["那么union方法的时间复杂度是o",{"2":{"37":1,"38":1}}],["那么将这一对整数输出",{"2":{"35":1}}],["那么等价关系能够将对象划分为多个等价类",{"2":{"32":1}}],["那么p与r也相连",{"2":{"31":1}}],["那么q与p相连",{"2":{"31":1}}],["那么a与c就是连通的",{"0":{"27":1}}],["那么使用链表如何实现栈",{"0":{"22":1}}],["那么取子集中的第一个元素",{"2":{"13":1}}],["那么多少合适呢",{"2":{"12":1}}],["那么各个物理集群的数据分布越均匀",{"2":{"12":1}}],["那么集群3的压力会增大",{"2":{"12":1}}],["那么原来落在集群1上的所有数据会直接落在集群3上面",{"2":{"12":1}}],["那么影响的数据只有key1和key3",{"2":{"10":1}}],["那么此时的redis集群中可用的数量变成了2",{"2":{"7":1}}],["on",{"2":{"118":1}}],["of",{"2":{"80":1,"118":1}}],["orelse",{"2":{"80":1}}],["orderpriorityqueue",{"2":{"65":2}}],["out",{"2":{"43":1,"111":1,"140":5,"142":8,"147":3,"152":10,"153":1}}],["optionalnode",{"2":{"80":3}}],["optional",{"2":{"80":4}}],["op",{"2":{"24":5}}],["operate",{"2":{"24":3}}],["override",{"2":{"20":7,"21":2,"22":7,"23":7,"36":2,"37":2,"38":2,"39":2,"44":1,"45":1,"46":1,"47":1,"51":1,"52":2,"53":1,"57":1,"58":1,"64":2,"65":2,"71":2,"76":1,"80":3,"81":4,"86":1,"87":1,"89":2,"90":1,"98":3,"106":1,"108":1,"109":1,"110":1,"116":1,"117":1,"121":4,"124":1,"126":1,"127":1,"134":1,"140":2}}],["objects",{"2":{"80":1,"81":1,"86":3,"87":2,"88":2,"89":2,"90":3,"101":1,"103":1,"106":2,"109":1,"110":3,"124":1,"126":1,"127":1}}],["object",{"2":{"20":1,"21":2,"64":1,"65":1,"71":1,"123":2}}],["floatconsts",{"2":{"118":3}}],["floattorawintbits",{"2":{"118":1}}],["floattointbits",{"2":{"118":2}}],["float",{"0":{"118":1},"2":{"118":2}}],["flipcolors",{"2":{"107":1,"108":3,"109":2}}],["false",{"2":{"98":1,"149":1}}],["f",{"2":{"80":1}}],["fields",{"2":{"118":1}}],["final",{"2":{"98":2,"134":1}}],["find也有自己的优势",{"2":{"147":1}}],["find方法需要访问数组n",{"2":{"38":1}}],["find方法只需要访问一次数组就可以得到根触点",{"2":{"38":1}}],["find",{"2":{"36":3,"37":4,"38":3,"39":3,"40":1}}],["find算法是动态的添加节点",{"2":{"147":1}}],["find算法不行",{"2":{"147":1}}],["find算法实现的连通性检查",{"2":{"144":1}}],["find算法只能判断出给定的两个整数是否是相连的",{"2":{"40":1}}],["find算法更快",{"2":{"38":1,"147":1}}],["find算法api定义",{"0":{"36":1}}],["find算法的目标是当程序从输入中读取了整数对p",{"2":{"35":1}}],["find算法",{"0":{"37":1},"2":{"29":1,"40":1,"142":1,"144":1}}],["first和last指向同一个元素",{"2":{"23":1}}],["first表示的是队列的头结点",{"2":{"23":1}}],["first",{"2":{"22":8,"23":7,"80":5}}],["fixcapacityarraystack",{"2":{"20":2}}],["foreach",{"2":{"111":1,"142":3,"152":4,"153":3}}],["for",{"2":{"21":1,"24":1,"25":3,"26":3,"36":1,"37":1,"39":1,"43":1,"44":2,"45":2,"46":2,"47":2,"51":2,"52":5,"53":4,"58":2,"64":1,"65":1,"76":1,"80":3,"81":2,"118":1,"119":1,"121":1,"124":1,"125":1,"126":1,"127":2,"134":3,"135":4,"140":1,"142":1,"146":2,"148":2,"149":2,"152":1,"153":2}}],["from",{"2":{"0":1}}],["栈在使用的时候有可能也会遍历全部的元素",{"2":{"20":1}}],["栈的特点就是后进先出",{"2":{"20":1}}],["返回路径",{"2":{"141":1,"152":1}}],["返回与v相邻的所有顶点",{"2":{"133":1}}],["返回图中边的总数",{"2":{"133":1}}],["返回顶点的个数",{"2":{"133":1}}],["返回p所在分量的标识符",{"2":{"36":1}}],["返回元素的个数",{"2":{"20":1}}],["返回比hash值大的map子集",{"2":{"13":1}}],["v++",{"2":{"135":2,"146":1,"149":1}}],["v的边",{"2":{"134":1}}],["v表示图中顶点的个数",{"2":{"134":1}}],["val",{"2":{"119":2}}],["value为数字",{"2":{"153":1}}],["value代替",{"2":{"121":1}}],["values",{"2":{"81":9,"118":1,"123":2,"124":2,"125":3,"126":1,"127":3}}],["value完全复制到需要删除的节点",{"2":{"80":1}}],["value",{"2":{"79":1,"80":11,"81":3,"84":4,"85":1,"86":1,"88":6,"90":2,"98":4,"106":8,"110":4,"116":3,"117":4,"118":4,"119":3,"121":2,"124":3}}],["valueof",{"2":{"24":1}}],["visualization",{"2":{"112":1}}],["vlaue",{"2":{"80":1}}],["v",{"2":{"79":2,"80":4,"81":2,"84":2,"85":2,"86":1,"88":1,"98":2,"106":2,"121":2,"123":2,"124":1,"126":1,"133":5,"134":15,"135":12,"139":1,"140":6,"141":2,"142":15,"145":2,"146":15,"148":6,"149":12,"152":16,"153":3}}],["v>",{"2":{"79":1,"81":2,"85":3,"121":4,"125":1}}],["void",{"2":{"20":2,"21":2,"22":1,"23":2,"36":1,"37":1,"38":1,"39":1,"43":3,"44":1,"45":1,"46":1,"47":1,"51":2,"52":10,"53":2,"57":2,"58":4,"61":1,"63":1,"64":1,"65":1,"69":1,"70":1,"71":1,"73":1,"76":1,"79":2,"80":2,"81":2,"85":4,"89":2,"90":1,"103":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"121":2,"124":1,"125":1,"127":1,"133":1,"134":1,"140":2,"142":2,"146":1,"147":1,"148":1,"149":1,"152":2,"153":1}}],["vnode6",{"2":{"12":1}}],["vnode5",{"2":{"12":1}}],["vnode4",{"2":{"12":1}}],["vnode3",{"2":{"12":1}}],["vnode2",{"2":{"12":1}}],["vnode1",{"2":{"12":1}}],["edgeto",{"2":{"142":6,"152":6}}],["edu",{"2":{"112":1}}],["e++",{"2":{"134":1}}],["e表示图总共边的数据",{"2":{"134":1}}],["e",{"2":{"80":2,"133":1,"134":4,"135":1}}],["empty",{"2":{"80":1}}],["el",{"2":{"57":3,"58":9}}],["else",{"2":{"19":2,"23":1,"24":6,"39":1,"51":3,"52":3,"53":3,"58":2,"80":1,"81":2,"86":2,"88":2,"90":2,"106":2,"110":3,"148":1,"149":1}}],["equals不一定相同",{"2":{"115":1}}],["equals",{"2":{"24":10,"80":3,"124":1,"126":1,"127":1}}],["exp",{"2":{"118":2}}],["exponent",{"2":{"118":1}}],["expression",{"2":{"24":2}}],["exch",{"2":{"43":2,"44":1,"45":1,"46":1,"47":1,"52":2,"57":2,"58":6,"63":1,"64":1,"65":1,"69":1,"70":1,"71":1,"73":1,"76":1}}],["extends",{"2":{"20":1,"23":1,"37":1,"38":1,"39":1,"61":1,"64":1,"65":1,"71":1,"81":2,"85":2}}],["enqueue时间复杂度是o",{"2":{"65":1}}],["enqueue和栈的push方式实现方式一致",{"2":{"64":1}}],["enqueue",{"2":{"23":2,"61":1,"64":1,"65":1,"71":1,"134":2,"152":2}}],["使得a",{"2":{"58":1}}],["使得开发者能够更系统地分析问题",{"2":{"4":1}}],["使用",{"2":{"153":1}}],["使用一个数组来反向映射数字",{"2":{"153":1}}],["使用map来保存字符串",{"2":{"153":1}}],["使用map来维护字符串和数字的映射关系",{"2":{"153":1}}],["使用队列来保存已经被标记过但是邻接表还未被遍历过的顶点",{"2":{"152":1}}],["使用递归来遍历所有的顶点",{"2":{"140":1}}],["使用字符串打印出图的关系",{"2":{"133":1}}],["使用二叉树实现的map运行的效率取决于树的形状",{"2":{"91":1}}],["使用冒泡排序的时间复杂度是o",{"2":{"45":1}}],["使用选择排序的时间复杂度是o",{"2":{"44":1}}],["使用同样的数据结构",{"2":{"38":1}}],["使用链表实现队列需要维护两个变量first",{"2":{"23":1}}],["使用链表如何实现先进先出队列",{"0":{"23":1}}],["使用链表",{"2":{"22":1}}],["使用数组实现栈的完整代码",{"2":{"20":1}}],["使用数组和链表都可以实现栈的功能",{"2":{"20":1}}],["小于右子树中的任意节点",{"2":{"84":1}}],["小于三个部分",{"2":{"58":1}}],["小于5就切换到插入排序",{"2":{"58":1}}],["小于5就使用插入排序",{"2":{"52":2}}],["小于就查询左半边数组",{"2":{"19":1}}],["小树合并到大树",{"2":{"39":1}}],["小姐姐",{"2":{"20":1,"26":1}}],["说说使用数组如何实现栈",{"0":{"20":1}}],["说说二分查找吧",{"0":{"19":1}}],["次就可以判断出元素是否存在",{"2":{"19":1}}],["前几篇我们一起学习了基于数组",{"2":{"114":1}}],["前面的2是底数",{"2":{"19":1}}],["前言",{"0":{"6":1,"18":1,"29":1,"42":1,"49":1,"55":1,"60":1,"73":1,"78":1,"83":1,"93":1,"114":1,"129":1,"138":1,"151":1},"1":{"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1}}],[">v是否存在路径",{"2":{"141":1,"152":1}}],[">>>",{"2":{"117":1}}],[">=",{"2":{"47":2,"52":5,"57":2,"58":3,"76":1}}],[">",{"2":{"19":1,"21":1,"22":1,"23":1,"24":2,"26":2,"46":1,"51":2,"52":4,"53":2,"58":2,"65":1,"69":1,"76":1,"80":1,"81":2,"86":1,"88":1,"90":1,"106":1,"110":1,"111":1,"119":1,"121":1,"124":1,"125":1,"127":1,"134":1,"142":1,"152":2,"153":4}}],["illegalstateexception",{"2":{"142":1,"152":1}}],["illegalargumentexception",{"2":{"86":1,"106":1,"124":1,"126":1,"127":1}}],["ioexception",{"2":{"111":1}}],["istwocolor",{"2":{"149":1}}],["isred",{"2":{"101":1,"106":6,"108":11,"109":6,"110":7}}],["isnull",{"2":{"80":1,"81":1,"86":3,"87":2,"88":2,"89":2,"90":3,"101":1,"103":1,"106":2,"109":1,"110":2,"124":1,"126":1,"127":1}}],["ispresent",{"2":{"80":1}}],["isempty",{"2":{"20":2,"22":1,"23":4,"61":1,"79":1,"85":1,"108":2,"109":2,"110":2,"152":1}}],["i=lo+1",{"2":{"58":1}}],["ids",{"2":{"146":4}}],["id",{"2":{"36":3,"37":4,"38":4,"39":4,"145":1,"146":3}}],["i++",{"2":{"25":1,"26":2,"36":1,"37":1,"39":1,"44":1,"45":1,"46":1,"47":1,"51":3,"52":4,"53":3,"58":5,"64":1,"70":1,"73":1,"119":1,"121":1,"125":1,"134":2,"153":2}}],["i",{"2":{"25":4,"26":10,"36":4,"37":4,"39":3,"43":3,"44":5,"45":3,"46":3,"47":3,"51":7,"52":9,"53":13,"57":4,"58":16,"63":3,"64":4,"65":7,"70":6,"73":7,"119":3,"121":3,"125":4,"134":7,"153":7}}],["implements",{"2":{"20":1,"22":1,"23":1,"36":1,"44":1,"45":1,"46":1,"47":1,"51":1,"52":2,"53":1,"57":1,"58":1,"63":1,"98":1,"121":1}}],["iterator",{"2":{"20":3,"22":3,"23":3}}],["iterable",{"2":{"20":1,"23":1,"61":1,"79":1,"85":2,"133":1,"134":1,"141":1,"142":1,"152":2}}],["item",{"2":{"20":3,"21":4,"22":7,"23":7,"61":1,"64":2,"65":2,"71":2}}],["if",{"2":{"19":2,"21":2,"23":2,"24":7,"25":1,"26":2,"37":2,"38":1,"39":2,"44":1,"45":1,"51":3,"52":12,"53":3,"57":4,"58":10,"64":1,"70":2,"73":2,"80":5,"81":5,"86":4,"87":2,"88":4,"89":2,"90":5,"101":1,"103":1,"106":7,"108":9,"109":7,"110":10,"118":1,"119":1,"124":3,"126":2,"127":3,"135":2,"140":1,"142":2,"146":2,"148":3,"149":3,"152":2}}],["insertionsort",{"2":{"46":1,"52":4,"58":2}}],["integer",{"0":{"116":1},"2":{"24":1,"111":1,"116":1,"152":1}}],["integer>",{"2":{"24":1,"133":1,"134":3,"141":1,"142":2,"152":4,"153":1}}],["interface",{"2":{"20":1,"23":1,"36":1,"43":1,"61":1,"79":1,"81":1,"85":2,"153":1}}],["int",{"2":{"19":5,"20":5,"21":2,"22":2,"23":3,"24":2,"25":7,"26":11,"36":15,"37":8,"38":7,"39":10,"43":2,"44":4,"45":3,"46":3,"47":4,"51":6,"52":28,"53":9,"57":7,"58":16,"61":1,"63":2,"64":4,"65":3,"69":1,"70":2,"71":2,"73":3,"76":2,"79":1,"81":10,"84":1,"85":2,"86":1,"88":2,"90":1,"98":1,"106":1,"110":1,"116":3,"117":3,"118":3,"119":3,"121":6,"123":3,"124":1,"125":2,"126":1,"127":1,"133":6,"134":11,"135":12,"139":3,"140":6,"141":3,"142":8,"145":5,"146":11,"148":4,"149":3,"152":11,"153":7}}],["index++",{"2":{"20":1,"21":1}}],["index",{"2":{"20":2,"21":4,"64":4,"81":19,"124":11,"126":7,"127":17,"153":4}}],["index的值就对应着3组集群",{"2":{"7":1}}],["index=hash",{"2":{"7":1}}],["++size",{"2":{"71":1}}],["++i",{"2":{"57":1,"58":1}}],["+=",{"2":{"39":2,"53":2}}],["+",{"0":{"24":2},"2":{"19":2,"24":3,"25":4,"26":1,"43":1,"44":1,"45":2,"47":1,"51":1,"52":12,"53":3,"57":2,"58":5,"70":1,"71":2,"73":3,"81":4,"84":2,"88":4,"89":4,"90":2,"108":2,"119":1,"124":2,"126":1,"127":3}}],["l",{"2":{"153":1}}],["line",{"2":{"153":4}}],["linearprobinghashmap",{"2":{"123":1,"125":7}}],["linkedmap",{"2":{"121":4}}],["linkedlistqueue的数组用来存储顶点v的相邻节点",{"2":{"134":1}}],["linkedlistqueue我们已经在之前的文章中实现",{"2":{"132":1}}],["linkedlistqueue",{"2":{"23":1,"132":1,"134":4,"152":1}}],["linkedliststack",{"2":{"22":1,"24":2,"142":1,"152":1}}],["lt++",{"2":{"58":2}}],["lt=lo",{"2":{"58":1}}],["lt",{"2":{"43":1,"52":1,"58":5}}],["left是红色",{"2":{"108":1}}],["left",{"2":{"84":1,"86":1,"87":2,"88":3,"89":6,"90":8,"98":2,"102":4,"103":1,"106":7,"107":2,"108":14,"109":5,"110":13}}],["less方法的实现请看之前的文章",{"2":{"57":1}}],["less",{"2":{"43":2,"44":1,"45":1,"46":1,"47":1,"51":2,"52":5,"53":1,"57":2,"58":3,"63":1,"64":1,"65":1,"69":1,"70":2,"73":2}}],["length",{"2":{"19":1,"21":4,"25":5,"26":7,"37":1,"44":4,"45":4,"46":3,"47":4,"52":3,"53":6,"57":1,"58":1,"76":1,"119":2,"121":1,"153":3}}],["lgn",{"2":{"39":1,"40":2}}],["last表示队列的尾结点",{"2":{"23":1}}],["last",{"2":{"23":5}}],["long",{"0":{"117":1},"2":{"117":2}}],["logn",{"2":{"81":1}}],["log",{"2":{"19":1,"26":1}}],["lo",{"2":{"19":5,"51":7,"52":40,"53":4,"57":9,"58":24,"81":6}}],["0x7fffffff",{"2":{"121":1}}],["0x7fc00000",{"2":{"118":1}}],["0",{"2":{"19":1,"20":1,"21":2,"24":1,"25":3,"26":4,"36":1,"37":1,"39":1,"43":1,"44":1,"45":2,"46":1,"52":3,"53":1,"57":1,"58":3,"63":1,"64":1,"69":1,"76":4,"79":1,"81":6,"85":1,"86":2,"88":3,"90":2,"106":2,"110":2,"118":1,"119":3,"121":3,"125":1,"127":1,"134":2,"135":6,"140":4,"142":4,"146":1,"147":4,"148":1,"149":1,"152":4,"153":2}}],["=v",{"2":{"142":1}}],["=next",{"2":{"80":1}}],["=a",{"2":{"52":1}}],["==",{"2":{"20":1,"21":2,"22":1,"23":1,"25":1,"36":1,"37":2,"38":1,"39":1,"57":2,"58":3,"79":1,"81":2,"85":1,"108":1,"118":1,"119":1,"135":1,"146":1,"149":1}}],["=",{"2":{"19":6,"20":2,"21":7,"22":7,"23":10,"24":9,"25":5,"26":7,"36":4,"37":4,"38":5,"39":9,"43":3,"44":5,"45":3,"46":3,"47":7,"51":11,"52":20,"53":15,"57":4,"58":14,"63":4,"64":7,"65":5,"69":1,"70":3,"71":4,"73":2,"74":1,"76":2,"79":1,"80":22,"81":22,"84":3,"85":1,"86":2,"87":1,"88":6,"89":6,"90":9,"98":6,"102":10,"103":3,"106":8,"107":3,"108":10,"109":7,"110":17,"111":1,"118":3,"119":5,"121":3,"123":3,"124":7,"125":5,"126":3,"127":10,"134":6,"135":7,"140":4,"142":10,"146":5,"147":2,"148":5,"149":7,"152":13,"153":9}}],["symbolgraph",{"2":{"153":3}}],["system",{"2":{"43":1,"111":1,"140":5,"142":8,"147":3,"152":10,"153":1}}],["s++",{"2":{"148":1}}],["s不能到达v",{"2":{"142":1,"152":1}}],["s",{"2":{"139":1,"140":2,"141":1,"142":7,"148":5,"152":11,"153":1}}],["sb",{"2":{"134":6}}],["signif",{"2":{"118":1}}],["significand",{"2":{"118":1}}],["silently9527",{"2":{"113":1,"128":1}}],["sink",{"2":{"70":1,"71":1,"73":1,"76":2}}],["size=左子树的个数",{"2":{"84":1}}],["size++",{"2":{"20":1,"21":1,"22":1,"23":1,"64":1,"65":1,"81":1,"121":1,"124":1}}],["size",{"2":{"20":7,"21":6,"22":4,"23":5,"61":1,"64":6,"65":5,"70":1,"71":4,"73":3,"76":6,"79":2,"81":8,"84":2,"85":2,"88":7,"89":6,"90":3,"98":1,"102":4,"106":1,"108":3,"121":4,"123":1,"124":1,"127":4,"153":1}}],["swim",{"2":{"69":1,"71":1}}],["src",{"2":{"52":13}}],["shellsort",{"2":{"47":1}}],["show",{"2":{"13":1,"19":1}}],["sz",{"2":{"39":9,"53":8}}],["suppresswarnings",{"2":{"58":1}}],["super",{"2":{"37":1,"38":1,"39":1,"64":1,"65":1,"71":1}}],["sum也是用类似的方法",{"2":{"26":1}}],["sum的算法多了一层循环",{"2":{"26":1}}],["sum实现类似使用两层循环",{"2":{"26":1}}],["sum中",{"2":{"26":1}}],["sum",{"2":{"26":1}}],["sum简化成2",{"2":{"26":1}}],["sortedmap",{"2":{"81":1,"85":1}}],["sorttemplate",{"2":{"43":1,"44":1,"45":1,"46":1,"47":1,"51":1,"52":2,"53":1,"57":1,"58":1}}],["sort",{"2":{"26":2,"43":2,"44":1,"45":1,"46":1,"47":1,"51":1,"52":2,"53":1,"57":1,"58":1,"76":1}}],["split",{"2":{"24":3,"153":12}}],["stream",{"2":{"153":2}}],["str",{"2":{"24":9}}],["stringbuilder",{"2":{"134":2}}],["string>",{"2":{"24":1,"111":1}}],["string",{"0":{"119":1},"2":{"24":4,"133":1,"134":1,"153":13}}],["stack",{"2":{"20":2,"22":1,"24":2,"142":6,"152":6}}],["static",{"2":{"19":1,"24":1,"25":1,"26":2,"98":2,"116":1,"117":1,"118":2,"135":4,"153":1}}],["sedepthfirstsearcharch",{"2":{"140":1}}],["separatechaininghashmap",{"2":{"121":2}}],["selectionsort",{"2":{"44":1}}],["setnext",{"2":{"23":1}}],["searchnode",{"2":{"80":3}}],["search",{"2":{"19":1,"26":2,"139":2,"140":6}}],["存在返回对应的下标",{"2":{"19":1}}],["pv表示的是到达v的顶点",{"2":{"148":1}}],["pv",{"2":{"148":2}}],["pathto",{"2":{"141":1,"142":4,"152":6}}],["paths",{"2":{"141":2,"142":7,"152":10}}],["partition",{"2":{"57":5,"58":5}}],["param",{"2":{"19":2}}],["post",{"2":{"132":1}}],["pop",{"2":{"20":2,"21":1,"22":1,"24":10}}],["png",{"2":{"111":2}}],["p的根触点",{"2":{"38":1,"39":1}}],["pid",{"2":{"37":3}}],["prenode",{"2":{"80":4}}],["println",{"2":{"111":1,"140":5,"142":5,"147":3,"152":6,"153":1}}],["print",{"2":{"43":3,"142":3,"152":4}}],["private",{"2":{"20":2,"21":1,"22":5,"23":4,"39":1,"51":2,"52":10,"53":2,"57":2,"58":4,"63":1,"64":2,"65":2,"69":1,"70":1,"71":2,"73":1,"84":5,"86":1,"88":2,"90":1,"106":1,"108":3,"109":2,"110":1,"121":3,"123":4,"125":1,"134":3,"140":3,"142":4,"146":4,"148":3,"149":4,"152":5,"153":3}}],["programmerbooks",{"2":{"113":1,"128":1}}],["proot",{"2":{"38":3,"39":7}}],["protected",{"2":{"36":2,"87":2,"101":1,"102":2,"103":1,"107":1}}],["p",{"2":{"36":5,"37":5,"38":8,"39":8,"153":1}}],["p与p是相连的",{"2":{"31":1}}],["p与q相连",{"2":{"31":1}}],["put的性能将会大大减低",{"2":{"91":1}}],["put的时间复杂度都是log",{"2":{"91":1}}],["put方法实现",{"2":{"81":1}}],["put方法的实现思路也是遍历链表",{"2":{"80":1}}],["put",{"2":{"79":1,"80":1,"81":1,"85":1,"88":3,"106":5,"111":11,"121":2,"124":1,"125":1,"127":1,"153":1}}],["push",{"2":{"20":2,"21":1,"22":1,"24":3,"142":3,"152":3}}],["public",{"2":{"19":2,"20":10,"21":2,"22":9,"23":9,"24":1,"25":1,"26":2,"36":5,"37":4,"38":4,"39":4,"43":1,"44":2,"45":2,"46":2,"47":2,"51":2,"52":4,"53":2,"57":2,"58":2,"61":1,"63":4,"64":4,"65":4,"71":4,"76":1,"79":1,"80":5,"81":5,"84":1,"85":2,"86":1,"87":1,"89":4,"90":1,"98":12,"106":1,"108":1,"109":1,"110":1,"111":1,"116":2,"117":2,"118":2,"119":1,"121":6,"123":1,"124":1,"126":1,"127":1,"133":7,"134":7,"135":4,"139":1,"140":5,"141":1,"142":4,"145":5,"146":5,"147":1,"148":3,"149":3,"152":6,"153":8}}],["bfs",{"2":{"152":2}}],["breadthfirstpaths",{"2":{"152":4}}],["break",{"2":{"57":3,"58":3,"70":1,"73":1,"127":1}}],["bit",{"2":{"118":4}}],["binaryheappriorityqueue",{"2":{"71":2}}],["binarysearch",{"2":{"19":1,"26":2}}],["based",{"2":{"118":1}}],["balance",{"2":{"108":2,"109":1,"110":1}}],["bst",{"2":{"108":1,"109":1,"110":1}}],["black",{"2":{"98":3,"101":1,"103":2,"106":1,"108":1,"109":1,"110":1}}],["bubblesort",{"2":{"45":1}}],["b就返回true",{"2":{"43":1}}],["b",{"2":{"43":2,"63":2,"80":1,"153":1}}],["b是c的好友",{"0":{"27":1}}],["boolean",{"2":{"20":3,"22":2,"23":3,"36":2,"43":1,"61":1,"63":1,"79":2,"85":2,"98":4,"101":1,"139":1,"140":3,"141":1,"142":3,"145":1,"146":3,"148":4,"149":6,"152":4,"153":2}}],["bb",{"2":{"13":1,"19":1}}],["you",{"2":{"19":1}}],["大家可以参考下",{"2":{"112":1}}],["大家可以自行基于2",{"2":{"112":1}}],["大的数组排序",{"2":{"52":1}}],["大于就查询右半边的数组",{"2":{"19":1}}],["大量的key会被重新定位到其他服务器",{"2":{"7":1}}],["进行比较",{"2":{"19":1}}],["最近几篇文章一起学习到的图算法都是以数字作为了顶点",{"2":{"153":1}}],["最终父链树形成了",{"2":{"142":1}}],["最终保证整个数组有序",{"2":{"56":2}}],["最好的方式就是基于我们实现的版本画出红黑树",{"2":{"111":1}}],["最好的情况下二叉树是平衡的",{"2":{"91":1}}],["最后强制转换成int值",{"2":{"117":1}}],["最后实现的删除操作也会使用到删除最小值和删除最大值",{"2":{"107":1}}],["最后在变色",{"2":{"106":1}}],["最后也分析了该版本的时间复杂度以及最糟糕的情况",{"2":{"93":1}}],["最后所有key4",{"2":{"9":1}}],["最糟糕的情况下需要递归n",{"2":{"57":1}}],["最坏的情况下",{"2":{"39":1}}],["最和谐的面试过程就是与面试官你推我挡",{"2":{"21":1}}],["最大值实现思路类似",{"2":{"89":1}}],["最大值的实现",{"2":{"87":1}}],["最大",{"2":{"19":1}}],["最小值",{"2":{"121":1}}],["最小值的实现",{"2":{"87":1}}],["最小",{"2":{"19":1}}],["果然是开胃啊",{"2":{"19":1}}],["看起来quick",{"2":{"38":1}}],["看你这么会说话",{"0":{"19":1}}],["看上图",{"2":{"16":1}}],["是因为数字来实现这些算法会非常的简洁方便",{"2":{"153":1}}],["是因为它只交换相邻的元素",{"2":{"47":1}}],["是有一组顶点和一组能够将两个订单相连组成的",{"2":{"130":1}}],["是否等于id",{"2":{"37":1}}],["是否需要建立一条新的连接才能通信",{"2":{"29":1}}],["是的",{"2":{"18":1}}],["是开发高效",{"2":{"4":1}}],["你这个算法得运行到什么时候",{"0":{"26":1}}],["你来设计个算法帮我统计出有多少组这样的数字",{"0":{"25":1}}],["你来设计一个算法对算术表示式求值",{"0":{"24":1}}],["你刚才实现的栈是定容的",{"0":{"21":1}}],["你是本次的面试官",{"2":{"18":1}}],["你什么时候有时间来我们公司二面呢",{"2":{"18":1}}],["到公司后",{"2":{"18":1}}],["随机选择一个切分元素",{"2":{"56":1}}],["随机算法",{"2":{"7":1}}],["随便给你两个用户",{"0":{"27":1}}],["随时准备着",{"2":{"18":1}}],["我在之前也看过很多关于红黑树的文章",{"2":{"93":1}}],["我需要定义个方法来判断节点属于什么颜色",{"2":{"101":1}}],["我需要记录每一个树的大小",{"2":{"39":1}}],["我需要思考一会",{"2":{"24":1}}],["我可以趴下休息一会吗",{"2":{"27":1}}],["我已经尽力了",{"2":{"26":1}}],["我大意了",{"2":{"26":1}}],["我窃喜中",{"2":{"18":1}}],["我依然被带到了那个小黑屋",{"2":{"18":1}}],["我",{"2":{"18":2,"19":2,"20":1,"21":2,"22":2,"23":1,"24":3,"25":1,"26":3,"27":2}}],["我们假设图中不存在自环和平行边",{"2":{"148":1}}],["我们只需要在数字与字符串的关系做一个映射",{"2":{"153":1}}],["我们只需要根据hashcode的值使用除留余数法即可转换成数组的下标",{"2":{"115":1}}],["我们只能判断出哪些顶点与起点s是连通的",{"2":{"141":1}}],["我们依然需要使用一个边的数组edgeto",{"2":{"152":1}}],["我们依然基于这张图来看",{"2":{"142":1}}],["我们依然先来定义搜索的api",{"2":{"139":1}}],["我们依然可以基于前面我们使用到的队列api来修改",{"2":{"61":1}}],["我们就需要遍历一遍全部的边",{"2":{"132":1}}],["我们称为自环",{"2":{"131":1}}],["我们考虑把这两种情况进行合并",{"2":{"108":1}}],["我们先来讨论下红黑树删除最小值和最大值的情况",{"2":{"107":1}}],["我们先来看最简单的情况",{"2":{"106":1}}],["我们先来看看红黑树的性质",{"2":{"93":1}}],["我们使用2",{"2":{"97":1}}],["我们发现最糟糕的情况是插入的节点有序",{"2":{"97":1}}],["我们发现2",{"2":{"97":1}}],["我们发现初级版本的实现插入或删除最大值的操作最糟糕的情况会是线性时间",{"2":{"66":1}}],["我们会继续改进我们实现的map",{"2":{"91":1}}],["我们会定义两个数组变量分部存放keys",{"2":{"81":1}}],["我们会发现选择排序运行的时候和未排序的时间一样长",{"2":{"44":1}}],["我们把最大元素删除",{"2":{"75":1}}],["我们有两种方式",{"2":{"74":1}}],["我们的算法依然会对其进行切分",{"2":{"58":1}}],["我们实现的快速排序在递归的时候会遇到许多全部重复的子数组",{"2":{"58":1}}],["我们来看下算法如何改进",{"2":{"57":1}}],["我们来看下一致性哈希算法的容错性如何呢",{"2":{"10":1}}],["我们需要按照起点的顺序来遍历所有的顶点",{"2":{"152":1}}],["我们需要把相连的顶点对应的标识值记录成相同值",{"2":{"146":1}}],["我们需要把上一篇中的sink",{"2":{"73":1}}],["我们需要实现从顶点s到顶点v是否存在路径可达",{"2":{"141":1}}],["我们需要从顶点0开始找到一条出路",{"2":{"140":1}}],["我们需要三个成员变量",{"2":{"134":1}}],["我们需要重新修复红黑树",{"2":{"108":1}}],["我们需要重新定义一个有序的map",{"2":{"81":1}}],["我们需要先了解2",{"2":{"94":1}}],["我们需要先定义出map的接口定义",{"2":{"79":1}}],["我们需要先完成两个有序数组的归并操作",{"2":{"51":1}}],["我们需要由上向下恢复堆有序",{"2":{"68":1}}],["我们需要由下向上恢复堆有序",{"2":{"68":1}}],["我们需要考虑另外一种算法",{"2":{"38":1}}],["我们需要设计数据结构来保存已知的所有整数对的信息",{"2":{"35":1}}],["我们希望根据请求的url或者url参数将相同的请求转发到同一个应用服务器中",{"2":{"16":1}}],["我们可以提供一些工具方法",{"2":{"135":1}}],["我们可以使用v乘以v的矩阵来表示",{"2":{"132":1}}],["我们可以参考之前在文章",{"2":{"125":1}}],["我们可以总结出统一的变化规律",{"2":{"106":1}}],["我们可以来看一个2",{"2":{"100":1}}],["我们可以通过类似的方式去删除只有一个子节点或者是没有子节点的节点",{"2":{"90":1}}],["我们可以二分查找法",{"2":{"81":1}}],["我们可以从右向左调用sink",{"2":{"74":1}}],["我们可以用数组来表示二叉堆",{"2":{"68":1}}],["我们可以写出第一版实现",{"2":{"57":1}}],["我们可以对每次缓存key的hash值取模",{"2":{"7":1}}],["我们可以考虑hash算法",{"2":{"7":1}}],["感冒好了吗",{"2":{"18":1}}],["吓退了面试官",{"2":{"18":1}}],["面试时根本不虚",{"2":{"112":1}}],["面试的季节到了",{"2":{"61":1,"64":2,"66":1}}],["面试未完",{"2":{"27":1}}],["面试官露出迷人的微笑",{"2":{"26":1}}],["面试官",{"0":{"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1},"2":{"27":1}}],["面试官带起口罩后就说面试先暂时到这里",{"2":{"18":1}}],["面试官原本想的是http问的差不多了",{"2":{"18":1}}],["面试篇",{"2":{"18":1}}],["w邻接表中也会有v",{"2":{"148":1}}],["w相连",{"2":{"148":1}}],["w的边",{"2":{"134":1}}],["w",{"2":{"133":2,"134":3,"135":3,"140":3,"142":6,"145":1,"146":5,"148":4,"149":5,"152":5}}],["why",{"2":{"93":6,"99":6}}],["while",{"2":{"19":1,"38":1,"39":1,"47":2,"57":3,"58":4,"69":1,"70":1,"73":1,"76":1,"81":1,"142":1,"152":2}}],["weightedquickunionimpl",{"2":{"39":2}}],["wiki",{"2":{"16":1}}],["www",{"2":{"16":1,"112":1}}],["rotateright",{"2":{"102":1,"106":1,"108":2,"109":2,"110":1}}],["rotateleft",{"2":{"102":1,"106":1,"108":2}}],["root",{"2":{"80":3,"86":1,"87":1,"89":4,"90":2,"106":3,"108":6,"109":6,"110":6}}],["right",{"2":{"84":1,"86":1,"87":2,"88":3,"89":6,"90":5,"98":2,"102":4,"103":1,"106":4,"107":2,"108":8,"109":6,"110":9}}],["rank方法的实现",{"2":{"81":1}}],["rank方法如果key值存在就返回对应在数组中的下标",{"2":{"81":1}}],["rank",{"2":{"81":5,"85":1}}],["random",{"2":{"58":3}}],["redblack",{"2":{"112":1}}],["redblack5",{"2":{"111":1}}],["redblack4",{"2":{"111":1}}],["redblack23redblacktreemap",{"2":{"111":2,"153":1}}],["red",{"2":{"98":3,"102":2,"103":1,"106":1,"108":1,"109":1,"110":1}}],["result",{"2":{"118":5}}],["resut",{"2":{"24":6}}],["resize",{"2":{"21":4,"124":1,"125":1,"127":1}}],["resources",{"2":{"16":1}}],["return",{"2":{"19":3,"20":6,"21":1,"22":6,"23":6,"24":1,"25":1,"26":2,"36":2,"37":2,"38":2,"39":2,"43":1,"52":6,"57":2,"58":4,"63":1,"64":1,"65":1,"71":1,"79":2,"80":4,"81":6,"85":2,"86":5,"87":5,"88":4,"89":4,"90":4,"98":3,"101":2,"102":2,"103":1,"106":2,"108":4,"109":3,"110":2,"116":2,"117":2,"118":2,"119":1,"121":3,"124":1,"126":2,"134":4,"135":4,"140":2,"142":2,"146":3,"148":2,"149":2,"152":2,"153":4}}],["rf",{"2":{"0":1}}],["n2323",{"2":{"153":1}}],["n分隔的每段第一个字符串表示顶点v",{"2":{"153":1}}],["ng",{"2":{"153":1}}],["nginx",{"2":{"16":1}}],["nb",{"2":{"153":1}}],["name",{"2":{"153":2}}],["nan",{"2":{"118":1}}],["n个元素的数组需要n次交换",{"2":{"44":1}}],["nlogn",{"2":{"50":1,"55":1}}],["nlog",{"2":{"26":1}}],["n²log",{"2":{"26":1}}],["n²",{"2":{"26":1,"38":1,"44":1,"45":1,"46":1,"49":1,"57":1}}],["n³",{"2":{"26":1}}],["numberofselfloops",{"2":{"135":1}}],["numbers",{"2":{"24":12}}],["null",{"2":{"21":1,"22":2,"23":4,"64":1,"65":1,"71":1,"79":1,"80":6,"81":3,"85":1,"86":3,"90":1,"106":1,"108":2,"109":1,"110":1,"124":2,"126":3,"127":7}}],["nextint",{"2":{"58":1}}],["next",{"2":{"20":1,"22":2,"23":1,"80":17}}],["newcapacity",{"2":{"21":2}}],["new",{"2":{"20":2,"21":1,"22":2,"23":2,"24":2,"36":1,"39":1,"52":1,"53":1,"58":1,"64":1,"65":1,"71":1,"80":1,"86":1,"88":1,"106":2,"108":1,"109":1,"110":1,"111":1,"121":2,"123":2,"124":1,"125":1,"126":1,"127":1,"134":3,"140":3,"142":6,"146":2,"147":2,"148":1,"149":2,"152":7,"153":3}}],["n",{"2":{"19":1,"26":3,"36":4,"37":3,"38":3,"39":4,"40":1,"64":1,"65":1,"80":1,"88":1,"91":1,"122":1,"134":2,"153":3}}],["nonzero",{"2":{"118":1}}],["nonnull",{"2":{"110":1}}],["nosuchelementexception",{"2":{"108":1,"109":1,"110":1}}],["not",{"2":{"86":1,"124":1,"126":1,"127":1}}],["nodes",{"2":{"85":1,"111":1}}],["node>",{"2":{"80":2}}],["node",{"2":{"22":5,"23":9,"80":33,"84":4,"86":12,"87":13,"88":19,"89":22,"90":23,"98":6,"101":5,"102":8,"103":9,"106":26,"107":1,"108":8,"109":25,"110":37}}],["no",{"2":{"13":1,"19":1}}],["具体的操作过程如下",{"2":{"24":1}}],["具体的算法过程",{"0":{"9":1}}],["具体配置可以参考官方文档",{"2":{"16":1}}],["添加如下代码",{"2":{"15":2}}],["对比两种红黑树的版本差异",{"2":{"112":1}}],["对比命中率影响了多少",{"2":{"15":2}}],["对应了23树中的节点分裂",{"2":{"103":1}}],["对上一篇中二叉树的节点做一些修改",{"2":{"98":1}}],["对一个长度为n的数组",{"2":{"57":1}}],["对每一组相邻的元素执行同样的操作",{"2":{"45":1}}],["对象如何与数字关联起来",{"2":{"31":1}}],["对称性",{"2":{"31":1}}],["对待3",{"2":{"26":1}}],["对这个算法进行改进一下",{"2":{"26":1}}],["对的哦",{"2":{"26":1}}],["对于顶点v",{"2":{"135":1}}],["对于自定义类型的键我们通常需要自定义实现hashcode和equals",{"2":{"115":1}}],["对于map接口的定义以及已经实现的公用方法将不会重复叙述",{"2":{"93":1}}],["对于k节点的左边节点下标是2k+1",{"2":{"73":1}}],["对于小数组的排序直接切换成插入排序",{"2":{"58":1}}],["对于小规模的数组使用归并排序会增加递归调用栈",{"2":{"52":1}}],["对于小规模的数组可以是用插入排序",{"2":{"52":1}}],["对于大规模的乱序数组插入排序很慢",{"2":{"47":1}}],["对于n个元素的数组",{"2":{"44":1,"45":1}}],["对于一个包含n个元素的列表",{"2":{"19":1}}],["对于容错性和伸缩性支持很差",{"2":{"7":1}}],["测试",{"2":{"52":2,"58":1}}],["测试数组是否已经有序",{"2":{"52":1}}],["测试添加节点node5",{"2":{"15":1}}],["测试删除节点node3",{"2":{"15":1}}],["测试代码",{"0":{"15":1}}],["核心代码",{"0":{"14":1}}],["text",{"2":{"153":3}}],["testdelete",{"2":{"111":1}}],["test",{"2":{"111":1,"140":2,"142":2,"147":2,"152":2}}],["twocolor",{"2":{"149":3}}],["twocolorgraph",{"2":{"149":2}}],["tostring",{"2":{"133":1,"134":2,"153":1}}],["table",{"2":{"121":7}}],["tailmap",{"2":{"13":1}}],["treenode",{"2":{"98":1}}],["treenode>",{"2":{"85":1}}],["treemap底层也是用的是红黑树",{"2":{"93":1}}],["true",{"2":{"57":1,"58":1,"98":1,"140":1,"142":1,"146":1,"148":2,"149":2,"152":2}}],["tmp",{"2":{"21":3,"43":2,"58":3,"63":2}}],["throws",{"2":{"111":1}}],["throw",{"2":{"86":1,"106":1,"108":1,"109":1,"110":1,"124":1,"126":1,"127":1,"142":1,"152":1}}],["this",{"2":{"20":4,"21":10,"22":2,"23":1,"63":1,"64":1,"65":1,"71":7,"80":4,"81":7,"84":2,"98":5,"121":5,"123":3,"124":8,"125":3,"126":3,"127":12,"134":8,"140":2,"142":7,"146":6,"148":6,"149":10,"152":12,"153":10}}],["the",{"2":{"13":1,"19":1,"106":1}}],["t",{"2":{"20":7,"21":4,"22":6,"23":7,"61":2,"63":4,"64":5,"65":5,"71":5,"106":1}}],["t>",{"2":{"20":5,"22":7,"23":9,"61":2,"63":4,"64":3,"65":3,"71":3}}],["movetoredright",{"2":{"109":2,"110":1}}],["movetoredleft",{"2":{"108":2,"110":1}}],["modules",{"2":{"16":1}}],["main",{"2":{"153":1}}],["marked判断顶点s与v是否相邻",{"2":{"139":1}}],["marked",{"2":{"139":1,"140":10,"142":5,"146":5,"148":5,"149":5,"152":6}}],["mask",{"2":{"118":3}}],["map",{"0":{"79":1},"2":{"79":1,"80":1,"81":1,"85":2,"111":18,"121":1,"153":10}}],["maxdegree",{"2":{"135":5}}],["maximum",{"2":{"118":1}}],["max",{"2":{"64":2,"65":2,"71":4,"85":1,"87":6,"90":4,"110":4,"121":1}}],["math",{"2":{"53":1}}],["macos",{"2":{"0":1}}],["min",{"2":{"44":4,"53":1,"85":1,"87":2,"110":4}}],["mid+1",{"2":{"52":1}}],["mid",{"2":{"19":7,"51":7,"52":27,"53":3,"81":5}}],["merge",{"2":{"51":1,"52":6,"53":2}}],["mergesort",{"2":{"51":1,"52":2,"53":1}}],["me",{"2":{"13":1}}],["不一定非得这种字符串",{"2":{"153":1}}],["不满足第二点",{"2":{"132":1}}],["不了解的兄弟请查看上一篇",{"2":{"93":1}}],["不相等就返回null",{"2":{"81":1}}],["不需要把完整的构造并表示一张图",{"2":{"147":1}}],["不需要使用辅助数组",{"2":{"55":1}}],["不需要考虑扩容的问题",{"2":{"22":1}}],["不同的排序算法实现的方式不一样",{"2":{"43":1}}],["不存在返回",{"2":{"19":1}}],["不废话",{"2":{"19":1}}],["不扯废话",{"2":{"13":1}}],["不断学习",{"2":{"1":1}}],["先选择一条通道走",{"2":{"140":1}}],["先把键值转换成一个整数然后在使用除留余数法计算出数组的下标",{"2":{"115":1}}],["先把初始化根节点为红色",{"2":{"108":1}}],["先插入键值到节点",{"2":{"99":1}}],["先插入新的key到当前节点",{"2":{"97":1}}],["先递归拆分成小的数组",{"2":{"52":1}}],["先后移动当前索引的位置",{"2":{"46":1}}],["先来聊聊春节放假期间发生的事",{"2":{"29":1}}],["先栈顶添加元素",{"2":{"22":1}}],["先计算出key的hash值",{"2":{"13":1}}],["先构造一个长度为2^32",{"2":{"9":1}}],["物理节点作为value存放到map中",{"2":{"13":1}}],["把查找的key和节点的key进行比较",{"2":{"86":1}}],["把next指针指向next",{"2":{"80":1}}],["把需要删除节点的next的key",{"2":{"80":1}}],["把上一个节点的next指向当前节点next",{"2":{"80":1}}],["把一个输入的数组构建成一个堆有序",{"2":{"74":1}}],["把原始数据构造成一个有序堆",{"2":{"73":1}}],["把结果输出到另一个数组中",{"2":{"73":1}}],["把分量中所有的值都统一成qid",{"2":{"37":1}}],["把数组划分为两个子数组",{"2":{"56":1}}],["把数组扩容到指定的大小并拷贝原来的数据到新的数组中",{"2":{"21":1}}],["把数据存放到最近的集群上",{"2":{"9":1}}],["把虚拟节点的名字求hash值",{"2":{"13":1}}],["个顶点",{"2":{"134":1}}],["个人觉得对于理解红黑树也有帮助",{"2":{"99":1}}],["个人生活",{"2":{"2":1}}],["个虚拟节点",{"2":{"12":1}}],["10",{"2":{"147":1}}],["16",{"2":{"111":2}}],["170",{"2":{"111":1}}],["17",{"2":{"111":2}}],["15",{"2":{"111":1}}],["150",{"2":{"12":1,"111":1}}],["180",{"2":{"111":1}}],["18",{"2":{"111":1}}],["1次",{"2":{"38":1,"57":1}}],["1",{"0":{"24":1},"2":{"19":6,"25":2,"26":1,"37":1,"39":1,"40":1,"44":1,"45":3,"46":3,"47":3,"51":1,"52":14,"53":5,"57":5,"58":10,"64":2,"65":5,"70":1,"71":5,"73":4,"74":1,"81":8,"84":2,"88":2,"89":2,"90":1,"98":1,"108":1,"124":2,"126":1,"127":3,"140":2,"142":2,"147":3,"152":2,"153":1}}],["1的整数环",{"2":{"9":1}}],["从一幅图中找出所有的连通分量",{"2":{"144":1}}],["从本篇开始我们将会一起来学习图相关的算法",{"2":{"129":1}}],["从本篇开始我将自己实现map的功能",{"2":{"78":1}}],["从左边借节点",{"2":{"110":1}}],["从左向右遍历数组",{"2":{"74":1}}],["从右边借节点",{"2":{"110":1}}],["从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点",{"2":{"99":1}}],["从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点",{"2":{"93":1}}],["从每个叶子到根的所有路径上不能有两个连续的红色结点",{"2":{"93":1,"99":1}}],["从该节点的左子树中取出最大值或者是从右子树中取出最小值",{"2":{"90":1}}],["从上面的结果我们可以看出",{"2":{"141":1}}],["从上面的结果来看",{"2":{"12":1}}],["从上面的实现我们可以看出二叉树的查询方法和上篇中数组二分查找法实现的一样简单高效",{"2":{"88":1}}],["从根节点开始沿着左子树递归",{"2":{"87":1}}],["从根节点开始沿着右子树递归",{"2":{"87":1}}],["从堆中按照递减顺序取出所有元素就可以得到排序结果",{"2":{"73":1}}],["从数组的右边开始扫描找出小于等于切分元素的值",{"2":{"56":1}}],["从数组的左边开始扫描找出大于等于切分元素的值",{"2":{"56":1}}],["从代码的实现我们可以看出",{"2":{"46":1}}],["从后往前开始扫码与当前索引位置元素进行比较",{"2":{"46":1}}],["从栈顶删除元素",{"2":{"22":1}}],["从栈中弹出",{"2":{"20":1}}],["从而更加高效地利用内存",{"2":{"4":1}}],["在广度优先搜索中",{"2":{"152":1}}],["在前面两篇中我们通过深度优先搜索可以从图中找出一条通过顶点v到顶点w的路径",{"2":{"151":1}}],["在前几篇也一起讨论了其他的排序算法",{"2":{"55":1}}],["在深度搜索完成之后这个edgeto",{"2":{"142":1}}],["在访问其中一个顶点时",{"2":{"140":1}}],["在搜索一张图的时候",{"2":{"140":1}}],["在走的路上放上一根绳子",{"2":{"140":1}}],["在下一篇我们将来学习图的第一个搜索算法",{"2":{"136":1}}],["在下一次调用时直接返回",{"2":{"120":1}}],["在实际的过程中图的大小不确定",{"2":{"132":1}}],["在实现红黑树的插入或者删除操作可能会出现红色节点在右边或者两个连续的红色节点",{"2":{"102":1}}],["在实现之前",{"2":{"61":1}}],["在实现归并排序之前",{"2":{"51":1}}],["在开发图的相关算法时",{"2":{"132":1}}],["在开始实现算法之前",{"2":{"139":1}}],["在开始学习这些算法之前我们需要先来了解下图的基本定义",{"2":{"129":1}}],["在开始之前",{"2":{"79":1}}],["在开始之前我们先定义一个排序算法通用的模板",{"2":{"43":1}}],["在线性探测中需要把原来的数据重新插入到扩容之后的数据",{"2":{"125":1}}],["在节点数超过了8之后变为红黑树",{"2":{"121":1}}],["在java8中采用的这两种方式的混合",{"2":{"121":1}}],["在java中对于常用的数据类型已经实现了hashcode",{"2":{"115":1}}],["在查找路径上进行和删除最小值相同的变换可以保证在查找过程中任意当前节点不会是双键节点",{"2":{"110":1}}],["在删除掉最小值之后",{"2":{"108":1}}],["在正式实现删除操作之前",{"2":{"107":1}}],["在执行删除操作时我们也会实现到变色的操作",{"2":{"107":1}}],["在红黑树中要实现节点分裂",{"2":{"103":1}}],["在出现这些情况的时候我们需要通过旋转操作来完成修复",{"2":{"102":1}}],["在后面扩展部分会有讲解",{"2":{"99":1}}],["在后面的排序算法都会实现这个模板",{"2":{"43":1}}],["在基于2",{"2":{"99":1}}],["在基于数组的实现中",{"2":{"81":1}}],["在上篇中我们学习了深度优先搜索",{"2":{"143":1}}],["在上面我们已经演示过了2",{"2":{"99":1}}],["在上面我们已经解释过了",{"2":{"99":1}}],["在上面的图中空连接未画出",{"2":{"99":1}}],["在上一篇的二叉树中",{"2":{"97":1}}],["在上一篇中我们把图通过邻接表数组表示出来了",{"2":{"138":1}}],["在上一篇中我们通过二叉树作为了map的实现",{"2":{"93":1}}],["在上一篇中我们基于数组和链表实现了map的相关操作",{"2":{"83":1}}],["在上一篇中我们一起使用二叉堆实现了优先级队列",{"2":{"73":1}}],["在上一篇",{"2":{"49":1,"85":1}}],["在上一次",{"2":{"18":1}}],["在学习红黑树之前",{"2":{"93":1}}],["在递归中把当前节点的右子树返回即可",{"2":{"89":1}}],["在二叉树中我们可能会经常使用到查询树中的最大值和最小值",{"2":{"87":1}}],["在二叉树中查找一个键最简单直接的方式就是使用递归",{"2":{"86":1}}],["在二叉堆中",{"2":{"68":1}}],["在遍历链表的时候记录下当前节点的上一个节点",{"2":{"80":1}}],["在看本篇之前需要先看下前一篇",{"2":{"73":1}}],["在元素进行插入和删除操作的过程中",{"2":{"68":1}}],["在一个二叉堆中",{"2":{"68":1}}],["在",{"2":{"66":1}}],["在此过程中我们需要引入一个辅助数组",{"2":{"51":1}}],["在排序之初",{"2":{"47":1}}],["在进行分量归并操作时总是把小的树连接到大的树上",{"2":{"39":1}}],["在数组初始化之后",{"2":{"38":1}}],["在p与q之间添加一条连接",{"2":{"36":1}}],["在pop方法中需要检查当前占用的空间是否是数组的四分之一",{"2":{"21":1}}],["在该算法中",{"2":{"32":1,"152":1}}],["在这篇采用的是union",{"2":{"144":1}}],["在这种应用中",{"2":{"29":1}}],["在这个敏感的时候",{"2":{"18":1}}],["在2",{"2":{"26":1,"95":1,"103":1}}],["在遇到数据量较大时效率极低",{"2":{"26":1}}],["在nginx请求的分发过程中",{"2":{"16":1}}],["在计算数据key需要存放到哪个物理节点时",{"2":{"13":1}}],["在每次添加物理节点的时候",{"2":{"13":1}}],["在根据虚拟节点的和实际集群的对应关系把数据存放到redis集群",{"2":{"12":1}}],["在缓存数据的时候根据顺时针查找虚拟节点",{"2":{"12":1}}],["在之前写了两篇关于缓存的文章",{"2":{"6":1}}],["虚拟节点",{"2":{"12":1}}],["集群3",{"2":{"12":1}}],["集群2",{"2":{"12":1}}],["集群",{"2":{"12":1}}],["集群1",{"2":{"10":1,"12":1}}],["歪果仁的脑子就是好使",{"2":{"12":1}}],["怎么搞呢",{"2":{"12":1}}],["新加redis集群4之后影响的只有key1数据",{"2":{"11":1}}],["伸缩性的验证证明了一致性哈希算法确实能解决hash算法的问题",{"2":{"12":1}}],["伸缩性",{"0":{"11":1}}],["当在调用connected方法的时候直接取出两个顶点的标识值比较",{"2":{"146":1}}],["当回退的路口已经没有路可以走的时候就在继续往后回退",{"2":{"140":1}}],["当遇到了一个已经被标记过的顶点",{"2":{"148":1}}],["当遇到了当前索引的元素大于了左边有序数组的最后一个元素时",{"2":{"46":1}}],["当遇到一个已经被标记的路口时就退回到上一个路口继续选择一个未走过的通道",{"2":{"140":1}}],["当数组已存放的容量超过了数组总容量的一半",{"2":{"124":1}}],["当插入键的位置超过了数组的大小",{"2":{"124":1}}],["当插入一个键",{"2":{"122":1}}],["当节点中的key值达到了3个就需要进行分裂",{"2":{"103":1}}],["当然与实现还有一些距离",{"2":{"93":1}}],["当前节点的左子节点和右子节点都是单键节点",{"2":{"108":1}}],["当前节点的左子节点是一个单键节点",{"2":{"108":1}}],["当前节点的左子节点是一个双键节点",{"2":{"108":1}}],["当前节点的size",{"2":{"88":1}}],["当前节点下节点的总个数",{"2":{"98":1}}],["当前节点只有一个key",{"2":{"97":1}}],["当前索引位置左边的元素是有序的",{"2":{"46":1}}],["当前索引的位置从0开始",{"2":{"46":1}}],["当遍历到需要删除的节点时",{"2":{"80":1}}],["当操作完成所有的元素之后",{"2":{"75":1}}],["当某个节点优先级下降",{"2":{"68":1}}],["当某个节点的优先级上升",{"2":{"68":1}}],["当步长为1时就成了普通的插入排序",{"2":{"47":1}}],["当确定当前索引位置上的元素在左边有序适合的位置之后",{"2":{"46":1}}],["当且仅当两个对象相连时他们才属于同一个等价类",{"2":{"32":1}}],["当年她在我心目中那是",{"2":{"29":1}}],["当队列为空时",{"2":{"23":1}}],["当队列为空",{"2":{"23":1}}],["当出队列时dequeue从头结点删除元素",{"2":{"23":1}}],["当入队列时enqueue向尾部结点添加元素",{"2":{"23":1}}],["当新增加或者减少物理集群影响也会最小",{"2":{"12":1}}],["当再次缓存key1",{"2":{"10":1}}],["当我们把红色节点拖动到与父节点同一个高度的时候",{"2":{"100":1}}],["当我们需要排序的数组中出现了大量的重复元素",{"2":{"58":1}}],["当我们需要扩展一组新的redis机器",{"2":{"7":1}}],["当我们三组redis集群中其中一组节点宕机了",{"2":{"7":1}}],["跪了",{"2":{"10":1}}],["容错性",{"0":{"10":1}}],["然后测试深度优先搜索",{"2":{"140":1}}],["然后开始判断当前位置上的key是否和待查询key相等",{"2":{"126":1}}],["然后通过红黑树的性质来验证",{"2":{"111":1}}],["然后判断是否node",{"2":{"108":1}}],["然后在变色",{"2":{"106":1}}],["然后在判断是否需要分裂",{"2":{"99":1}}],["然后删除左子树中的最大值",{"2":{"110":1}}],["然后删除右子树中的最小值",{"2":{"90":1,"110":1}}],["然后删除掉左子树的最大值",{"2":{"90":1}}],["然后删除它",{"2":{"64":1}}],["然后c",{"2":{"80":1}}],["然后比较每个node的key值是否相等",{"2":{"80":1}}],["然后比较每个node中的key是否相等",{"2":{"80":1}}],["然后放入到堆缩小后数组中空出来的位置",{"2":{"75":1}}],["然后把调用swim",{"2":{"74":1}}],["然后把最后一个元素放入到顶端",{"2":{"71":1}}],["然后把数组切换成大于",{"2":{"58":1}}],["然后把hash值作为key",{"2":{"13":1}}],["然后递归对子数组进行排序",{"2":{"56":1}}],["然后再使用除留余数法计算出数组的下标",{"2":{"121":1}}],["然后再成对归并得到子数组",{"2":{"53":1}}],["然后再将结果归并在一起",{"2":{"50":1}}],["然后调用treemap",{"2":{"13":1}}],["然后顺着hash环顺时针方向查找reids集群",{"2":{"9":1}}],["然后给每组redis集群命名",{"2":{"9":1}}],["计算图中的自环个数",{"2":{"135":1}}],["计算所有顶点的平均度数",{"2":{"135":1}}],["计算所有顶点的最大度数",{"2":{"135":1}}],["计算顶点v的度数",{"2":{"135":1}}],["计算的方式与上一篇中二叉树的size实现类似",{"2":{"102":1}}],["计算的公式index=hash",{"2":{"7":1}}],["计算子树节点的个数",{"2":{"102":1}}],["计算方式",{"2":{"84":1}}],["计算hash值之后的分部如下图",{"2":{"9":1}}],["计算出出来的hash值同样也分布在一致性hash环上",{"2":{"9":1}}],["称为一致性hash环",{"2":{"9":1}}],["也就是说",{"2":{"121":1}}],["也就是需要处理遇到了两个散列值相同的对象应该如何存储",{"2":{"121":1}}],["也不能连续",{"2":{"99":1}}],["也不需要要强行记忆",{"2":{"99":1}}],["也允许同一个节点包含最多两个键三条链接",{"2":{"95":1}}],["也可以来源于网路的请求",{"2":{"153":1}}],["也可以采用我们之前实现的红黑树来表示",{"2":{"121":1}}],["也可以是2",{"2":{"94":1}}],["也可以参考这篇文章",{"2":{"64":1}}],["也成为堆有序",{"2":{"68":1}}],["也是优先级队列的核心方法",{"2":{"61":1}}],["也有可能是a",{"2":{"52":1}}],["也会造成缓存的命中率下降",{"2":{"7":1}}],["也能展示出对编程的深入理解",{"2":{"4":1}}],["40",{"2":{"111":3}}],["4树去实现红黑树",{"2":{"112":1}}],["4树实现的红黑树中允许出现3键",{"2":{"99":1}}],["4树都是b树的特列情况",{"2":{"94":1}}],["4树是接口",{"2":{"94":1}}],["4树的关系就好比接口与实现类的关系",{"2":{"94":1}}],["4树",{"2":{"94":2}}],["4",{"0":{"24":1},"2":{"7":1,"21":1,"57":1,"74":1,"97":1,"127":1,"140":2,"142":3,"147":2,"152":3}}],["同理",{"2":{"7":1}}],["造成缓存的命中率直线下降",{"2":{"7":1}}],["所有叶子都是黑色",{"2":{"93":1,"99":1}}],["所有数据缓存的节点位置就发生了变化",{"2":{"7":1}}],["所以如果v的邻接表中有个顶点已被标记过并且该顶点不等于到达v的顶点",{"2":{"148":1}}],["所以还需要一个ids",{"2":{"146":1}}],["所以依然需要定义一个marked",{"2":{"146":1}}],["所以图所有顶点的总度数是边的2倍",{"2":{"135":1}}],["所以addedge方法在向图中添加边既要添加一条v",{"2":{"134":1}}],["所以这种数据结构效率的高",{"2":{"132":1}}],["所以这里我们需要实现这两个方法",{"2":{"87":1}}],["所以需要排除掉该情况",{"2":{"148":1}}],["所以需要定义一个变量count",{"2":{"146":1}}],["所以需要预留出足够的空间",{"2":{"132":1}}],["所以需要数组支持动态的扩容",{"2":{"121":1}}],["所以需要进行右旋",{"2":{"106":1}}],["所以散列表是无序的",{"2":{"121":1}}],["所以字符串转换成一个int值",{"2":{"119":1}}],["所以integer的hashcode实现很简单",{"2":{"116":1}}],["所以就不贴出代码了",{"2":{"111":1}}],["所以红黑树的删除操作的关键就是需要保证待删除节点是一个双键的节点",{"2":{"107":1}}],["所以删除操作会比插入操作更加麻烦",{"2":{"107":1}}],["所以只能出现红色节点在左边",{"2":{"100":1}}],["所以每次新插入的节点都必须是红色",{"2":{"99":1}}],["所以加在了这里",{"2":{"99":1}}],["所以从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点",{"2":{"99":1}}],["所以不可能是红色节点",{"2":{"99":1}}],["所以在在递归到每个节点是都需要保住当前节点是双键节点",{"2":{"108":1}}],["所以在红黑树中只有黑色节点会贡献树的高度",{"2":{"99":1}}],["所以在上一篇中实现的二叉树查找方法可以不用做任何的修改就可以直接应用到红黑树",{"2":{"98":1}}],["所以在学习红黑树之前",{"2":{"94":1}}],["所以造成红黑树比较难理解",{"2":{"93":1}}],["所以数组中的第一个位置是不会使用的",{"2":{"71":1}}],["所以时间复杂度是o",{"2":{"57":1}}],["所以时间复杂度o",{"2":{"26":1}}],["所以递归最后的结果一定是输入到了array中",{"2":{"52":1}}],["所以所我们排序的数组中存在着部分有序",{"2":{"46":1}}],["所以我们在进行搜索的时候需要记录下图中的边",{"2":{"142":1}}],["所以我们在插入操作之后统一设置一次根节点为黑色",{"2":{"106":1}}],["所以我们定义的旋转方法需要返回旋转之后的节点来重置父节点的链接",{"2":{"102":1}}],["所以我们需要进行左旋一次",{"2":{"105":1}}],["所以我们需要在节点中添加一个颜色的属性color",{"2":{"98":1}}],["所以我们需要做一些操作来保证堆再次有序",{"2":{"68":1}}],["所以我们先来了解下删除最大值和最小值应该如何实现",{"2":{"89":1}}],["所以我们只需要扫描数组的一半元素",{"2":{"74":1}}],["所以我们可以考虑使用插入排序来处理子数组的排序",{"2":{"52":1}}],["所以我们这里使用了comparable数组",{"2":{"43":1}}],["所以我们做了一个由三组主从复制的redis组成的高可用的redis集群",{"2":{"7":1}}],["所以刚才我思考了下",{"2":{"26":1}}],["所以继承了iterable",{"2":{"20":1}}],["所以二分查找法的时间复杂度是o",{"2":{"19":1}}],["所以同一份数据需要在每组集群中都存在",{"2":{"7":1}}],["250",{"2":{"111":1}}],["25",{"2":{"111":2}}],["2",{"0":{"24":1,"95":1,"100":1},"1":{"96":1,"97":1},"2":{"7":1,"19":1,"21":2,"52":4,"53":2,"57":1,"68":1,"69":4,"70":2,"73":2,"74":1,"76":1,"81":1,"94":4,"95":1,"96":1,"97":1,"100":2,"124":2,"127":1,"135":2,"140":3,"142":4,"147":3,"152":4}}],["完美的解决了刚才随机算法的缺点",{"2":{"7":1}}],["无向图api的实现",{"0":{"134":1}}],["无向图的api定义",{"0":{"133":1}}],["无论数据插入的顺序如何都能保证二叉树近似平衡",{"2":{"91":1}}],["无论是排序",{"2":{"4":1}}],["无论是在学术研究",{"2":{"4":1}}],["无法给出具体的路径出来",{"2":{"141":1}}],["无法给出具体达到的路径",{"2":{"40":1}}],["无法组成2",{"2":{"99":1}}],["无法处理大量的数据",{"2":{"80":1}}],["无需建立一个辅助数组浪费空间",{"2":{"73":1}}],["无需对数据做冗余",{"2":{"7":1}}],["31",{"2":{"119":1}}],["323",{"2":{"153":1}}],["32",{"2":{"117":1}}],["30",{"2":{"111":2}}],["3数的双键",{"2":{"99":1}}],["3树实现的红黑树版本",{"2":{"112":1}}],["3树实现的左倾红黑树中是不允许的",{"2":{"99":1}}],["3树实现的左倾红黑树",{"0":{"98":1},"1":{"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1}}],["3树对比来看",{"2":{"100":1}}],["3树如何表示成左倾红黑树",{"2":{"100":1}}],["3树如下图",{"2":{"95":1}}],["3树在左倾红黑树中表示",{"0":{"100":1}}],["3树插入键的过程",{"2":{"99":1}}],["3树双键",{"2":{"99":1}}],["3树去看红黑树的性质就不在是干瘪瘪的约定",{"2":{"99":1}}],["3树红黑树参考算法4",{"2":{"98":1}}],["3树中的三键节点的情况",{"2":{"103":1}}],["3树中的双键节点",{"2":{"98":1}}],["3树中",{"2":{"103":1}}],["3树中双键节点在红黑树中的表示",{"2":{"100":1}}],["3树中单键节点在红黑树中的表示",{"2":{"100":1}}],["3树中存在着双键的节点",{"2":{"98":1}}],["3树中可以出现一个节点存在一个键值两条链接",{"2":{"95":1}}],["3树来实现我们的红黑树",{"2":{"98":1}}],["3树之后",{"2":{"98":1}}],["3树依然完美平衡的",{"2":{"97":1}}],["3树顺序插入看看如何",{"2":{"97":1}}],["3树的理论模型中",{"2":{"107":1}}],["3树的理论模型来理解",{"2":{"99":1}}],["3树的双键或3键",{"2":{"99":2}}],["3树的双键节点的情况",{"2":{"99":1}}],["3树的实现",{"2":{"99":1}}],["3树的生长是由下向上的",{"2":{"97":1}}],["3树的查找过程与二叉树类似",{"2":{"96":1}}],["3树和标准的二叉树的生长是不同的",{"2":{"97":1}}],["3树和2",{"2":{"94":1}}],["3树与2",{"2":{"94":1}}],["3树",{"0":{"95":1},"1":{"96":1,"97":1},"2":{"94":3,"100":1}}],["3",{"0":{"24":1},"2":{"7":1,"47":3,"57":1,"74":1,"94":5,"97":1,"99":1,"112":1,"140":3,"142":3,"147":3,"152":4}}],["公式变成了index=hash",{"2":{"7":1}}],["公式",{"2":{"7":1}}],["现在有三组redis集群",{"2":{"7":1}}],["现在通常使用redis来做分布式缓存",{"2":{"7":1}}],["html",{"2":{"112":1}}],["http协议中",{"2":{"18":1}}],["https",{"2":{"16":1,"112":1,"113":1,"128":1,"132":1}}],["http缓存",{"2":{"6":1}}],["huaan9527",{"2":{"111":2}}],["h",{"2":{"102":14,"107":7,"108":34,"119":6,"153":1}}],["hascycle",{"2":{"148":1}}],["haspathto",{"2":{"141":1,"142":5,"152":6}}],["hasnext",{"2":{"20":1,"22":1,"23":1}}],["hashcycle",{"2":{"148":3}}],["hashcode",{"2":{"116":3,"117":3,"118":1,"119":1,"121":1}}],["hash",{"2":{"16":1,"119":2,"121":4,"124":1,"126":1,"127":1}}],["hash算法",{"2":{"7":1}}],["hi",{"2":{"19":4,"51":6,"52":34,"53":4,"57":7,"58":17,"81":4}}],["hr",{"2":{"18":1}}],["浪费了存储空间",{"2":{"7":1}}],["这的hash函数使用key的hashcode与上0x7fffffff得到一个非负的整数",{"2":{"121":1}}],["这也是使用最多的一种方式",{"2":{"114":1}}],["这三个操作就是上面总结的统一变化规律的代码实现",{"2":{"106":1}}],["这时候会出现三种情况",{"2":{"122":1}}],["这时候就需要使用到散列函数",{"2":{"115":1}}],["这时候分裂的操作就是把左右两个子节点的颜色变成黑色",{"2":{"103":1}}],["这时候如果有一组redis集群出现了问题",{"2":{"12":1}}],["这两种实现方式效率都比较低",{"2":{"83":1}}],["这两种情况都很适合插入排序",{"2":{"47":1}}],["这里我们就需要使用到广度优先搜索算法",{"2":{"151":1}}],["这里我们就采用简单的链表来实现拉链式散列表",{"2":{"121":1}}],["这里我们使用的是一个数组edgeto",{"2":{"142":1}}],["这里我们实现的拉链式散列表的数组大小是固定的",{"2":{"121":1}}],["这里我们选择使用treemap",{"2":{"13":1}}],["这里就不详细叙述了",{"2":{"109":1}}],["这里就不重复叙述",{"2":{"102":1}}],["这里就会有3中情况",{"2":{"108":1}}],["这里的变色和插入是的变色操作恰好相反",{"2":{"107":1}}],["这里还是简单说说什么是二叉树",{"2":{"84":1}}],["这里只实现了定长的优先级队列",{"2":{"64":1}}],["这里你就需要使用到优先级队列",{"2":{"60":1}}],["这里有很大的提升空间",{"2":{"58":1}}],["这点和归并排序一样",{"2":{"58":1}}],["这段代码是实现快速排序的常规实现",{"2":{"57":1}}],["这些算法无法处理大量数据",{"2":{"49":1}}],["这些算法的时间复杂度都是o",{"2":{"49":1}}],["这种数据结构的效率较差",{"2":{"132":1}}],["这种图称之为无向图",{"2":{"130":1}}],["这种散列值不会太好",{"2":{"115":1}}],["这种方式绳子总能帮你找到一条出路",{"2":{"140":1}}],["这种方式中最简单的实现就是线性探测",{"2":{"122":1}}],["这种方式被称为拉链法",{"2":{"121":1}}],["这种方式对应着java里面的hashmap",{"2":{"114":1}}],["这种方式会更高效",{"2":{"74":1}}],["这种状态就对应了2",{"2":{"103":1}}],["这种算法构造出来树的高度会远远小于未加权版本所构造的树高度",{"2":{"39":1}}],["这种算法的实现思路是在同一个连通分量中所有触点在id",{"2":{"37":1}}],["这种算法的好处是请求会被均匀的分发到每组redis集群上",{"2":{"7":1}}],["这种问题叫做动态连通性问题",{"2":{"35":1}}],["这就是一张二分图",{"2":{"149":1}}],["这就是本篇我们需要学习的堆排序",{"2":{"73":1}}],["这就是归并排序的算法思路",{"2":{"50":1}}],["这就是你推我挡的结果",{"2":{"22":1}}],["这就需要使用到union",{"2":{"29":1}}],["这次全搞懂",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1},"2":{"49":1,"51":1,"57":1}}],["这次回家遇到了我学生时代的女神",{"2":{"29":1}}],["这次面试我来和你聊聊",{"2":{"18":1}}],["这是也是深度优先搜索的一个应用场景",{"2":{"144":1}}],["这是最大的整型数",{"2":{"121":1}}],["这是二叉树的一个重要特性",{"2":{"88":1}}],["这是年后连夜肝出来的第一篇文章",{"2":{"29":1}}],["这是我们需要考虑的",{"2":{"7":1}}],["这小姐姐的问题是越来越难了",{"2":{"27":1}}],["这个的标识值我们使用的是count的值",{"2":{"146":1}}],["这个定义在之前的文章中已有提到",{"2":{"144":1}}],["这个数据结构将会做我们实现图算法的基础",{"2":{"138":1}}],["这个接口是最简单的一个map定义",{"2":{"79":1}}],["这个过程我们可以跳过子堆为1的元素",{"2":{"74":1}}],["这个操作就是自顶向下的归并排序",{"2":{"52":1}}],["这个方法将数组a",{"2":{"51":1}}],["这个优点是初级排序无法达到的",{"2":{"50":1}}],["这个算法改进之后的时间复杂度是o",{"2":{"26":1}}],["这个算法确实有问题",{"2":{"26":1}}],["这个算法的时间复杂度是o",{"2":{"26":1}}],["这个简单",{"2":{"25":1}}],["这个问题有点麻烦",{"2":{"24":1}}],["这个时候也可以选择使用一致性hash算法",{"2":{"16":1}}],["这位小姐姐竟然如此善良",{"2":{"19":1}}],["这样数组一定是有序的",{"2":{"47":1}}],["这样数据就会均匀的分布到各组集群中",{"2":{"12":1}}],["这样显得我是没有提前准备的",{"2":{"24":1}}],["这样就可以表示两个顶点相连",{"2":{"132":1}}],["这样就可以保证同一个请求每次都被分发到同一个redis集群上",{"2":{"7":1}}],["这样就排定了一个元素",{"2":{"44":1,"56":1}}],["这样就会造成了数据的冗余",{"2":{"7":1}}],["如",{"2":{"153":1}}],["如上图",{"2":{"131":1}}],["如此反复",{"2":{"46":1}}],["如此反复直到所有元素都是有序的",{"2":{"44":1}}],["如此往复",{"2":{"45":1}}],["如下图",{"2":{"38":1,"149":1}}],["如何表示出图",{"0":{"132":1}}],["如何实现自动扩容呢",{"2":{"64":1}}],["如何能够快速的判断出是否相连呢",{"2":{"29":1}}],["如何检测社交网络中两个人是否是朋友关系",{"0":{"28":1},"1":{"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1},"2":{"142":1,"144":1}}],["如何判断这两个用户是否连通的",{"0":{"27":1}}],["如何体现面试官的优越感",{"2":{"21":1}}],["如何将请求路由的不同的redis集群上",{"2":{"7":1}}],["如果v",{"2":{"148":1}}],["如果v同时也出现了在v的邻接表中",{"2":{"135":1}}],["如果相同就是连通的",{"2":{"146":1}}],["如果相等那么就直接返回value",{"2":{"126":1}}],["如果相等那么覆盖掉value",{"2":{"80":1}}],["如果相等就直接更新节点的值",{"2":{"88":1}}],["如果相等就返回value",{"2":{"80":1}}],["如果相等",{"2":{"86":1}}],["如果相等直接修改values",{"2":{"81":1}}],["如果相等返回values",{"2":{"81":1}}],["如果相等表示p与q已经属于同一分量中",{"2":{"37":1}}],["如果顶点v与w相连",{"2":{"132":1}}],["如果与数组的容量相差较大",{"2":{"127":1}}],["如果下一个位置还是一个空位",{"2":{"122":1}}],["如果你需要的map需要支持取出最大值",{"2":{"121":1}}],["如果计算一个散列值比较耗时",{"2":{"120":1}}],["如果hashcode相同",{"2":{"115":1}}],["如果两个对象的equals相等",{"2":{"115":1}}],["如果两个触点在不同的分量中",{"2":{"36":1}}],["如果待删除的节点处理叶子节点",{"2":{"110":1}}],["如果查找的键值在右节点",{"2":{"110":1}}],["如果查找的键值在左节点",{"2":{"110":1}}],["如果左边是红色",{"2":{"109":1}}],["如果插入的键大于当前节点的键值",{"2":{"105":1}}],["如果插入的键小于当前节点的键值",{"2":{"105":1}}],["如果出现了两个连续的红色节点",{"2":{"99":1}}],["如果节点是红色",{"2":{"98":1}}],["如果当前节点大于了两个key",{"2":{"97":1}}],["如果当确定当前索引位置上的元素大于了已排序的最后一个元素",{"2":{"46":1}}],["如果遇到图很大",{"2":{"132":1}}],["如果遇到空的链接表示查找未命中",{"2":{"96":1}}],["如果遇到与查找键相等的节点",{"2":{"96":1}}],["如果我们删除的节点当前是双键节点",{"2":{"107":1}}],["如果我们搞懂了这些问题",{"2":{"93":1}}],["如果我们需要在当前的基础上再添加一组redis集群4",{"2":{"11":1}}],["如果递归结束后还未找到值就新建一个节点并返回",{"2":{"88":1}}],["如果递归结束还未找到就返回null",{"2":{"86":1}}],["如果put的key值比当前节点大就需要去右子树递归",{"2":{"88":1}}],["如果p与q相连",{"2":{"31":2}}],["如果较小就去左子树递归",{"2":{"88":1}}],["如果较小就去左子树中继续递归查找",{"2":{"86":1}}],["如果较大就在右子树中查找",{"2":{"86":1}}],["如果存在一条边是v",{"2":{"142":1}}],["如果存在路径",{"2":{"141":1,"152":1}}],["如果存在请打印出来",{"2":{"141":1}}],["如果存在需要移动数组",{"2":{"81":1}}],["如果存在就返回所在数组的下表",{"2":{"81":1}}],["如果存在就返回在数组中的索引",{"2":{"19":1}}],["如果不好理解可以把图的tostring打印出来就可以理解了",{"2":{"135":1}}],["如果不重新插入7的位置就是空位",{"2":{"127":1}}],["如果不相等那么就继续查找下一个索引直到遇到某个位置是null才结束",{"2":{"126":1}}],["如果不相等表示不存在该key",{"2":{"81":1}}],["如果不存在就直接返回",{"2":{"81":1}}],["如果不存在就返回0",{"2":{"81":1}}],["如果不存在就返回小于key键的数量",{"2":{"81":1}}],["如果不为空",{"2":{"13":1}}],["如果未查找到有key相等的node",{"2":{"80":1}}],["如果比父节点大就交换",{"2":{"69":1}}],["如果输入数组是一个倒置的",{"2":{"46":1}}],["如果前一个比后一个大",{"2":{"45":1}}],["如果a",{"2":{"43":1,"52":1}}],["如果已知的所有整数对都不能说明p",{"2":{"35":1}}],["如果是非叶子节点",{"2":{"110":1}}],["如果是就进行旋转操作",{"2":{"108":1}}],["如果是红色就返回true",{"2":{"101":1}}],["如果是红色节点",{"2":{"99":1}}],["如果是",{"2":{"21":2}}],["如果等于就返回mid",{"2":{"19":1}}],["如果子集为空就需要把treemap的第一个元素返回",{"2":{"13":1}}],["如果说每组redis集群的配置都是一样的",{"2":{"12":1}}],["如leetcode",{"2":{"4":1}}],["需要找到与s连通的所有顶点",{"2":{"139":1}}],["需要先进行左旋",{"2":{"106":1}}],["需要插入并且移动数组",{"2":{"81":1}}],["需要把size通过参数传入",{"2":{"73":1}}],["需要把last设置为null",{"2":{"23":1}}],["需要了解之前的队列的实现可以查看",{"2":{"61":1}}],["需要在每一层递归的时候交换输入数据和输出数组的角色",{"2":{"52":1}}],["需要push方法中检查当前的size是否已经达到了数组的最大容量",{"2":{"21":1}}],["需要缓存的数据很多",{"2":{"7":1}}],["需要不断努力",{"2":{"1":1}}],["谈到缓存不说一下一致性hash算法那就是在耍流氓",{"2":{"6":1}}],["应用级缓存",{"2":{"6":1}}],["下一个位置和待插入的键不相等",{"2":{"122":1}}],["下一个位置和待插入的键相等",{"2":{"122":1}}],["下一篇我们将会学习使用红黑树来实现我们的map操作",{"2":{"91":1}}],["下面我来看看java中常用类型的hashcode计算方式",{"2":{"115":1}}],["下面我们就以redis为例",{"2":{"7":1}}],["下篇我们将基于二叉树来实现map",{"2":{"81":1}}],["下层顶端元素到合适位置",{"2":{"71":1}}],["下沉是堆排序的第二个阶段",{"2":{"75":1}}],["下沉操作构造堆",{"2":{"74":1}}],["下沉排序演示过程",{"2":{"75":1}}],["下沉排序",{"0":{"75":1},"2":{"73":1}}],["下沉",{"0":{"70":1},"2":{"68":1}}],["下次再聊",{"2":{"18":1}}],["下",{"2":{"6":1}}],["上面我们已经实现了红黑树的主要代码",{"2":{"111":1}}],["上面代码中的balance就是重新修复红黑树",{"2":{"108":1}}],["上浮操作保证指针左边的元素都是堆有序的",{"2":{"74":1}}],["上浮",{"0":{"69":1},"2":{"68":1}}],["上次面试你的面试官开会去了",{"2":{"18":1}}],["上次面试的结果不错",{"2":{"18":1}}],["上",{"2":{"6":1}}],["万字长文聊缓存",{"2":{"6":2}}],["万丈高楼平地起",{"2":{"1":1}}],["熟悉基础算法有助于在这些平台上获得更高的评价",{"2":{"4":1}}],["熟练使用命令rm",{"2":{"0":1}}],["熟练window",{"2":{"0":1}}],["普遍要求解决算法问题",{"2":{"4":1}}],["cycle",{"2":{"148":2}}],["cc",{"2":{"147":4}}],["cn",{"2":{"132":1}}],["char",{"2":{"119":1}}],["check",{"2":{"118":1}}],["cs",{"2":{"112":1}}],["c",{"2":{"80":2,"153":1}}],["clone",{"2":{"52":1}}],["class",{"2":{"19":1,"20":1,"22":2,"23":1,"36":1,"37":1,"38":1,"39":1,"44":1,"45":1,"46":1,"47":1,"51":1,"52":2,"53":1,"57":1,"58":1,"63":1,"64":1,"65":1,"71":1,"80":1,"84":1,"98":1,"121":1,"133":1,"134":1,"139":1,"140":1,"141":1,"142":1,"145":1,"146":1,"148":1,"149":1,"152":2,"153":1}}],["cap",{"2":{"125":2}}],["capacity表示初始化数组的大小",{"2":{"123":1}}],["capacity",{"2":{"20":2,"121":3,"123":6,"124":4,"125":3,"126":1,"127":5}}],["can",{"2":{"86":1,"106":1,"124":1,"126":1,"127":1}}],["calculate",{"2":{"24":1}}],["current",{"2":{"22":5,"23":5}}],["color",{"2":{"98":8,"101":1,"102":6,"103":3,"106":1,"107":6,"108":2,"109":2,"110":2,"149":6}}],["contains",{"2":{"79":1,"85":1,"153":3}}],["connected",{"2":{"36":2,"145":1,"146":1,"147":2}}],["consistent",{"2":{"16":1}}],["count返回与顶点s相连的总顶点数",{"2":{"139":1}}],["count3",{"2":{"26":1}}],["count2",{"2":{"26":1}}],["count++",{"2":{"25":1,"26":2,"135":1,"140":1,"146":1}}],["count",{"2":{"25":2,"26":4,"36":5,"37":1,"38":1,"39":1,"135":2,"139":1,"140":4,"145":1,"146":4,"147":1}}],["count1",{"2":{"25":1}}],["compare",{"2":{"63":1,"81":3,"86":3,"88":3,"90":3,"106":3,"110":3}}],["compareto",{"2":{"43":1,"52":1,"58":1,"81":4,"86":1,"88":1,"90":1,"106":1,"110":1}}],["comparator",{"2":{"63":7,"64":3,"65":3,"71":3}}],["comparable",{"2":{"43":8,"44":1,"45":1,"46":1,"47":1,"51":3,"52":15,"53":4,"57":4,"58":7,"73":1,"76":1,"81":1,"85":1}}],["com",{"2":{"16":1,"113":1,"128":1}}],["code",{"2":{"13":1,"19":1}}],["codeforces",{"2":{"4":1}}],["cpu等资源",{"2":{"4":1}}],["centos",{"2":{"0":1}}],["还可以减少空间复杂度",{"2":{"4":1}}],["还是基于红色节点的作用来理解",{"2":{"99":1}}],["还是继续沿用上面的例子",{"2":{"10":1}}],["还是图论",{"2":{"4":1}}],["还是实际开发中",{"2":{"4":1}}],["资源节约",{"2":{"4":1}}],["例如顺序插入1",{"2":{"97":1}}],["例如",{"2":{"4":1,"74":1,"127":1}}],["提高代码效率",{"2":{"4":1}}],["提高问题解决能力",{"2":{"4":1}}],["设计方案",{"2":{"4":1}}],["启发思维",{"2":{"4":1}}],["算法的思路",{"2":{"152":1}}],["算法改进",{"0":{"58":1}}],["算法实现",{"0":{"57":1}}],["算法实现的思路",{"2":{"44":1,"45":1,"46":1,"47":1}}],["算法思路",{"2":{"56":1}}],["算法第四版",{"2":{"40":1}}],["算法",{"2":{"40":1}}],["算法分析",{"2":{"37":1,"38":1,"39":1}}],["算法维护了两个变量lo",{"2":{"19":1}}],["算法竞赛和在线编程平台",{"2":{"4":1}}],["算法竞赛和在线平台",{"2":{"4":1}}],["算法都是最直接的工具",{"2":{"4":1}}],["算法是问题解决的核心",{"2":{"4":1}}],["搜索api的定义",{"0":{"139":1}}],["搜索",{"2":{"4":1}}],["掌握每种数据结构的优缺点",{"2":{"78":1}}],["掌握这些内容不仅能帮助应对各类面试问题",{"2":{"4":1}}],["掌握基础算法能够帮助开发者更好地理解问题的本质",{"2":{"4":1}}],["掌握和理解基础算法都是至关重要的",{"2":{"4":1}}],["职业发展",{"2":{"4":1}}],["健壮系统的关键工具",{"2":{"4":1}}],["欢迎斧正",{"2":{"3":1}}],["部分观点有一定主观性",{"2":{"3":1}}],["免责声明",{"0":{"3":1}}],["🐱",{"0":{"3":1}}],["🐸",{"0":{"1":1}}],["养成记录和分享的习惯",{"2":{"2":1}}],["行业视野",{"2":{"2":1}}],["博客",{"0":{"2":1}}],["🌀",{"0":{"2":1}}],["🌟",{"0":{"0":1}}],["夯实基础",{"2":{"1":1}}],["技术面试中的核心",{"2":{"4":1}}],["技术之路很广也很陡",{"2":{"1":1}}],["技巧总结",{"2":{"2":1}}],["技能",{"0":{"0":1}}],["学无止境",{"2":{"1":1}}],["学习和理解基础算法能训练逻辑思维能力",{"2":{"4":1}}],["学习",{"0":{"1":1}}]],"serializationVersion":2}';export{t as default};
