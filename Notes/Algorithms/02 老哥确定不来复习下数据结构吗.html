<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>02 老哥确定不来复习下数据结构吗 | Herman</title>
    <meta name="description" content="Herman's Notes: 个人技术知识库，记录 & 分享个人碎片化、结构化、体系化的技术知识内容。">
    <meta name="generator" content="VitePress v1.3.2">
    <link rel="preload stylesheet" href="/assets/style.BxE8_RUH.css" as="style">
    
    <script type="module" src="/assets/app.BBc7tYBO.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.vapwtr2c.js">
    <link rel="modulepreload" href="/assets/chunks/framework.d_Ke7vMG.js">
    <link rel="modulepreload" href="/assets/Notes_Algorithms_02 老哥确定不来复习下数据结构吗.md.Ceg2jCP8.lean.js">
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-bf383e74><!--[--><!--]--><!--[--><span tabindex="-1" data-v-e97857fd></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-e97857fd> Skip to content </a><!--]--><!----><header class="VPNav" data-v-bf383e74 data-v-207834a2><div class="VPNavBar has-sidebar top" data-v-207834a2 data-v-718fc1e4><div class="wrapper" data-v-718fc1e4><div class="container" data-v-718fc1e4><div class="title" data-v-718fc1e4><div class="VPNavBarTitle has-sidebar" data-v-718fc1e4 data-v-fc41dfbc><a class="title" href="/" data-v-fc41dfbc><!--[--><!--]--><!--[--><img class="VPImage logo" src="/favicon.ico" alt data-v-f2c6d1dc><!--]--><span data-v-fc41dfbc>Herman&#39;s Notes</span><!--[--><!--]--></a></div></div><div class="content" data-v-718fc1e4><div class="content-body" data-v-718fc1e4><!--[--><!--]--><div class="VPNavBarSearch search" data-v-718fc1e4><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-718fc1e4 data-v-6259bb24><span id="main-nav-aria-label" class="visually-hidden" data-v-6259bb24> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Notes/index.html" tabindex="0" data-v-6259bb24 data-v-420914ae><!--[--><span data-v-420914ae>💭 Notes</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Projects.html" tabindex="0" data-v-6259bb24 data-v-420914ae><!--[--><span data-v-420914ae>🦄 Projects</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Friends.html" tabindex="0" data-v-6259bb24 data-v-420914ae><!--[--><span data-v-420914ae>👫 Friends</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/AboutMe.html" tabindex="0" data-v-6259bb24 data-v-420914ae><!--[--><span data-v-420914ae>👋 About</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-718fc1e4 data-v-2de08662><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-2de08662 data-v-6ffb392b data-v-9f456e3f><span class="check" data-v-9f456e3f><span class="icon" data-v-9f456e3f><!--[--><span class="vpi-sun sun" data-v-6ffb392b></span><span class="vpi-moon moon" data-v-6ffb392b></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-718fc1e4 data-v-bbb06c93 data-v-4fe8b212><!--[--><a class="VPSocialLink no-icon" href="https://github.com/silently9527" aria-label="github" target="_blank" rel="noopener" data-v-4fe8b212 data-v-8c221f22><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-718fc1e4 data-v-69c03c92 data-v-d688c9f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d688c9f4><span class="vpi-more-horizontal icon" data-v-d688c9f4></span></button><div class="menu" data-v-d688c9f4><div class="VPMenu" data-v-d688c9f4 data-v-203f55c5><!----><!--[--><!--[--><!----><div class="group" data-v-69c03c92><div class="item appearance" data-v-69c03c92><p class="label" data-v-69c03c92>Appearance</p><div class="appearance-action" data-v-69c03c92><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-69c03c92 data-v-6ffb392b data-v-9f456e3f><span class="check" data-v-9f456e3f><span class="icon" data-v-9f456e3f><!--[--><span class="vpi-sun sun" data-v-6ffb392b></span><span class="vpi-moon moon" data-v-6ffb392b></span><!--]--></span></span></button></div></div></div><div class="group" data-v-69c03c92><div class="item social-links" data-v-69c03c92><div class="VPSocialLinks social-links-list" data-v-69c03c92 data-v-4fe8b212><!--[--><a class="VPSocialLink no-icon" href="https://github.com/silently9527" aria-label="github" target="_blank" rel="noopener" data-v-4fe8b212 data-v-8c221f22><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-718fc1e4 data-v-29464a66><span class="container" data-v-29464a66><span class="top" data-v-29464a66></span><span class="middle" data-v-29464a66></span><span class="bottom" data-v-29464a66></span></span></button></div></div></div></div><div class="divider" data-v-718fc1e4><div class="divider-line" data-v-718fc1e4></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-bf383e74 data-v-52ce94a8><div class="container" data-v-52ce94a8><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-52ce94a8><span class="vpi-align-left menu-icon" data-v-52ce94a8></span><span class="menu-text" data-v-52ce94a8>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-52ce94a8 data-v-147a7269><button data-v-147a7269>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-bf383e74 data-v-96072666><div class="curtain" data-v-96072666></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-96072666><span class="visually-hidden" id="sidebar-aria-label" data-v-96072666> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-793a6107><section class="VPSidebarItem level-0 collapsible is-link has-active" data-v-793a6107 data-v-21e77739><div class="item" tabindex="0" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/index.html" data-v-21e77739><!--[--><h2 class="text" data-v-21e77739>🎨 卧学算法</h2><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-21e77739><span class="vpi-chevron-right caret-icon" data-v-21e77739></span></div></div><div class="items" data-v-21e77739><!--[--><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/01%20%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95Java%E7%89%88%E5%AE%9E%E7%8E%B0.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>01 一致性Hash算法Java版实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/02%20%E8%80%81%E5%93%A5%E7%A1%AE%E5%AE%9A%E4%B8%8D%E6%9D%A5%E5%A4%8D%E4%B9%A0%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>02 老哥确定不来复习下数据结构吗</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/03%20%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%B8%A4%E4%B8%AA%E4%BA%BA%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%8B%E5%8F%8B%E5%85%B3%E7%B3%BB%EF%BC%88union-find%E7%AE%97%E6%B3%95%EF%BC%89.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>03 如何检测社交网络中两个人是否是朋友关系（union-find算法）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/04%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%8C%E8%BF%99%E6%AC%A1%E5%85%A8%E6%90%9E%E6%87%82.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>04 常见的初级排序算法，这次全搞懂</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/05%20%E6%AD%BB%E7%A3%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>05 死磕归并排序算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/06%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>06 快速排序算法实现及优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/07%20%E5%8E%9F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>07 原来实现优先级队列如此简单</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/08%20%E5%9B%BE%E8%A7%A3%E5%A0%86%E6%8E%92%E5%BA%8F.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>08 图解堆排序</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/09%20%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E6%88%96%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0Map.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>09 基于数组或链表实现Map</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/10%20%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0Map.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>10 基于二叉树实现Map</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/11%20%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B9%B6%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>11 硬核图解红黑树并手写实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/12%20%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%BC%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%BC%8F%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Map.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>12 基于拉链式和线性探测式散列表实现Map</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/13%20%E5%9B%BE%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>13 图算法系列之无向图的数据结构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/14%20%E5%9B%BE%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%80.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>14 图算法系列之深度优先搜索（一）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/15%20%E5%9B%BE%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%BA%8C.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>15 图算法系列之深度优先搜索（二）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Algorithms/16%20%E5%9B%BE%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>17 图算法系列之计算图中最短路径</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-793a6107><section class="VPSidebarItem level-0 collapsible is-link" data-v-793a6107 data-v-21e77739><div class="item" tabindex="0" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Mysql/index.html" data-v-21e77739><!--[--><h2 class="text" data-v-21e77739>📊 Mysql数据库</h2><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-21e77739><span class="vpi-chevron-right caret-icon" data-v-21e77739></span></div></div><div class="items" data-v-21e77739><!--[--><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Mysql/01%20Mysql%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>01 Mysql的安装及开启远程访问</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-21e77739 data-v-21e77739><div class="item" data-v-21e77739><div class="indicator" data-v-21e77739></div><a class="VPLink link link" href="/Notes/Mysql/02%20InnoDB%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-mysql%E7%B3%BB%E5%88%9701innodb%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.html" data-v-21e77739><!--[--><p class="text" data-v-21e77739>02 InnoDB行记录存储结构</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-bf383e74 data-v-2d74135c><div class="VPDoc has-sidebar has-aside" data-v-2d74135c data-v-68d915de><!--[--><!--]--><div class="container" data-v-68d915de><div class="aside" data-v-68d915de><div class="aside-curtain" data-v-68d915de></div><div class="aside-container" data-v-68d915de><div class="aside-content" data-v-68d915de><div class="VPDocAside" data-v-68d915de data-v-99eb047c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-99eb047c data-v-65e7abb7><div class="content" data-v-65e7abb7><div class="outline-marker" data-v-65e7abb7></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-65e7abb7>导航栏</div><ul class="VPDocOutlineItem root" data-v-65e7abb7 data-v-bbd455c7><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-99eb047c></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-68d915de><div class="content-container" data-v-68d915de><!--[--><!--]--><main class="main" data-v-68d915de><div style="position:relative;" class="vp-doc _Notes_Algorithms_02%20%E8%80%81%E5%93%A5%E7%A1%AE%E5%AE%9A%E4%B8%8D%E6%9D%A5%E5%A4%8D%E4%B9%A0%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97" data-v-68d915de><div><h1 id="老哥确定不来复习下数据结构吗" tabindex="-1">老哥确定不来复习下数据结构吗 <a class="header-anchor" href="#老哥确定不来复习下数据结构吗" aria-label="Permalink to &quot;老哥确定不来复习下数据结构吗&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>在上一次《面试篇》Http协议中，面试官原本想的是http问的差不多了，想要继续问我JAVA相关的一些问题，结果我突然觉得嗓子不舒服咳嗽了几声，（在这个敏感的时候）吓退了面试官，面试官带起口罩后就说面试先暂时到这里，下次再聊；两周之后我又收到了HR的电话；</p><p>HR：感冒好了吗？上次面试的结果不错，你什么时候有时间来我们公司二面呢？</p><p>我：随时准备着</p><p><img src="https://raw.githubusercontent.com/silently9527/images/main/75ef6ed9673a4a3388c6934eeb2c0715%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>到公司后，我依然被带到了那个小黑屋，等待着面试官的到来。没想等来的是一位美女小姐姐。</p><p>我：人美声甜的小姐姐，你是本次的面试官？（我窃喜中）</p><p>美女面试官：是的，上次面试你的面试官开会去了，这次面试我来和你聊聊</p><h4 id="面试官-看你这么会说话-让我先来帮你开个胃-说说二分查找吧" tabindex="-1">面试官：看你这么会说话，让我先来帮你开个胃，说说二分查找吧 <a class="header-anchor" href="#面试官-看你这么会说话-让我先来帮你开个胃-说说二分查找吧" aria-label="Permalink to &quot;面试官：看你这么会说话，让我先来帮你开个胃，说说二分查找吧&quot;">​</a></h4><p>我：（果然是开胃啊，这位小姐姐竟然如此善良）</p><p>我：二分查找法是在一个有序的数组中查到一个值，如果存在就返回在数组中的索引，否则就返回-1；算法维护了两个变量lo(最小)和hi(最大)，每次查找都与中间值(mid)进行比较，如果等于就返回mid，大于就查询右半边的数组，小于就查询左半边数组。二分查找法之所以快是因为每次一次查询都会排除掉一半的值。</p><blockquote><p>No BB, show you the code（不废话，直接看代码）</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class BinarySearch {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 二分查找</span></span>
<span class="line"><span>     * @param key</span></span>
<span class="line"><span>     * @param arr</span></span>
<span class="line"><span>     * @return 存在返回对应的下标，不存在返回 -1</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public static int search(int key, int[] arr) {</span></span>
<span class="line"><span>        int lo = 0, hi = arr.length - 1;</span></span>
<span class="line"><span>        while (lo &lt;= hi) {</span></span>
<span class="line"><span>            int mid = lo + (hi - lo) / 2;</span></span>
<span class="line"><span>            if (key &gt; arr[mid]) {</span></span>
<span class="line"><span>                lo = mid + 1;</span></span>
<span class="line"><span>            } else if (key &lt; arr[mid]) {</span></span>
<span class="line"><span>                hi = mid - 1;</span></span>
<span class="line"><span>            } else {</span></span>
<span class="line"><span>                return mid;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return -1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>对于一个包含n个元素的列表，用二分查找法最多需要log2n（前面的2是底数）次就可以判断出元素是否存在；所以二分查找法的时间复杂度是<code>O(log n)</code></strong></p><h4 id="面试官-说说使用数组如何实现栈" tabindex="-1">面试官：说说使用数组如何实现栈？ <a class="header-anchor" href="#面试官-说说使用数组如何实现栈" aria-label="Permalink to &quot;面试官：说说使用数组如何实现栈？&quot;">​</a></h4><p>我：小姐姐，栈的特点就是后进先出，使用数组和链表都可以实现栈的功能，首先看下栈的定义：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public interface Stack&lt;T&gt; extends Iterable {</span></span>
<span class="line"><span>    void push(T item); //向栈添加元素</span></span>
<span class="line"><span>    T pop(); //从栈中弹出</span></span>
<span class="line"><span>    boolean isEmpty();</span></span>
<span class="line"><span>    int size(); //返回元素的个数</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>栈在使用的时候有可能也会遍历全部的元素，所以继承了<code>Iterable</code>，使用数组实现栈的完整代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class FixCapacityArrayStack&lt;T&gt; implements Stack&lt;T&gt; {</span></span>
<span class="line"><span>    private T[] arr;</span></span>
<span class="line"><span>    private int size;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public FixCapacityArrayStack(int capacity) {</span></span>
<span class="line"><span>        this.arr = (T[]) new Object[capacity]; //初始化数组大小</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void push(T item) {</span></span>
<span class="line"><span>        this.arr[size++] = item;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public T pop() {</span></span>
<span class="line"><span>        return this.arr[--size];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean isEmpty() {</span></span>
<span class="line"><span>        return size == 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public int size() {</span></span>
<span class="line"><span>        return this.size;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public Iterator&lt;T&gt; iterator() {</span></span>
<span class="line"><span>        return new Iterator&lt;T&gt;() {</span></span>
<span class="line"><span>            int index;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public boolean hasNext() {</span></span>
<span class="line"><span>                return index &lt; size;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public T next() {</span></span>
<span class="line"><span>                return arr[index++];</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-你刚才实现的栈是定容的-那如何实现动态调整栈的大小" tabindex="-1">面试官：你刚才实现的栈是定容的，那如何实现动态调整栈的大小 <a class="header-anchor" href="#面试官-你刚才实现的栈是定容的-那如何实现动态调整栈的大小" aria-label="Permalink to &quot;面试官：你刚才实现的栈是定容的，那如何实现动态调整栈的大小&quot;">​</a></h4><p>我：（已猜到你会问这个问题了，刚才故意没说动态调整大小；经过多年的面试经验总结，最和谐的面试过程就是与面试官<code>你推我挡</code>，一上来就说出了最优解，如何体现面试官的优越感？）</p><p><img src="https://raw.githubusercontent.com/silently9527/images/main/67002370a964460bb4d6dd2814df3ad8%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我：要实现动态的调整大小，首先需要在提供一个 resize 的方法，把数组扩容到指定的大小并拷贝原来的数据到新的数组中；</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>private void resize(int newCapacity) {</span></span>
<span class="line"><span>    Object[] tmp = new Object[newCapacity];</span></span>
<span class="line"><span>    for (int index = 0; index &lt; size; index++) {</span></span>
<span class="line"><span>        tmp[index] = arr[index];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    this.arr = (T[]) tmp;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>需要<code>push</code>方法中检查当前的size是否已经达到了数组的最大容量，如果是，就把数组扩容2倍</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>public void push(T item) {</span></span>
<span class="line"><span>    if (this.arr.length == size) {</span></span>
<span class="line"><span>        this.resize(2 * this.arr.length);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    this.arr[size++] = item;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在<code>pop</code>方法中需要检查当前占用的空间是否是数组的四分之一，如果是，就需要把数据的容量缩小到原来的一半</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>public T pop() {</span></span>
<span class="line"><span>    T item = this.arr[--size];</span></span>
<span class="line"><span>    this.arr[size] = null;  //避免游离对象，让垃圾回收器回收无用对象</span></span>
<span class="line"><span>    if (size &gt; 0 &amp;&amp; size == this.arr.length / 4) {</span></span>
<span class="line"><span>        this.resize(this.arr.length / 2);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return item;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-刚才你提到了链表-那么使用链表如何实现栈" tabindex="-1">面试官：刚才你提到了链表，那么使用链表如何实现栈 <a class="header-anchor" href="#面试官-刚才你提到了链表-那么使用链表如何实现栈" aria-label="Permalink to &quot;面试官：刚才你提到了链表，那么使用链表如何实现栈&quot;">​</a></h4><p>我：（这就是<code>你推我挡</code>的结果，和小姐姐的互动很和谐）</p><p><img src="https://raw.githubusercontent.com/silently9527/images/main/37dc3e48af4e46f0bb09b335a1e2104c%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我：使用链表，首先需要先定义个Node，单向的链表包含了值和下一个节点的引用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class Node&lt;T&gt; {</span></span>
<span class="line"><span>    private T item;</span></span>
<span class="line"><span>    private Node next;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>采用链表实现的栈相对于数组实现还较为简单一些，不需要考虑扩容的问题。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class LinkedListStack&lt;T&gt; implements Stack&lt;T&gt; {</span></span>
<span class="line"><span>    private Node&lt;T&gt; first;</span></span>
<span class="line"><span>    private int size;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void push(T item) {//先栈顶添加元素</span></span>
<span class="line"><span>        this.first = new Node&lt;&gt;(item, first);</span></span>
<span class="line"><span>        size++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public T pop() { //从栈顶删除元素</span></span>
<span class="line"><span>        T item = first.getItem();</span></span>
<span class="line"><span>        size--;</span></span>
<span class="line"><span>        first = first.getNext();</span></span>
<span class="line"><span>        return item;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean isEmpty() {</span></span>
<span class="line"><span>        return first == null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public int size() {</span></span>
<span class="line"><span>        return this.size;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public Iterator&lt;T&gt; iterator() {</span></span>
<span class="line"><span>        return new Iterator&lt;T&gt;() {</span></span>
<span class="line"><span>            private Node&lt;T&gt; current = first;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public boolean hasNext() {</span></span>
<span class="line"><span>                return current != null;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public T next() {</span></span>
<span class="line"><span>                T item = current.getItem();</span></span>
<span class="line"><span>                current = current.getNext();</span></span>
<span class="line"><span>                return item;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-使用链表如何实现先进先出队列" tabindex="-1">面试官：使用链表如何实现先进先出队列 <a class="header-anchor" href="#面试官-使用链表如何实现先进先出队列" aria-label="Permalink to &quot;面试官：使用链表如何实现先进先出队列&quot;">​</a></h4><p>我：与栈的实现过程类似，首先需要定义出队列</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public interface Queue&lt;T&gt; extends Iterable {</span></span>
<span class="line"><span>    void enqueue(T item); //入队列</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    T dequeue(); //出队列</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int size();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean isEmpty();</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>使用链表实现队列需要维护两个变量first、last；first表示的是队列的头结点，last表示队列的尾结点；当入队列时<code>enqueue</code>向尾部结点添加元素，当出队列时<code>dequeue</code>从头结点删除元素。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class LinkedListQueue&lt;T&gt; implements Queue&lt;T&gt; {</span></span>
<span class="line"><span>    private Node&lt;T&gt; first;</span></span>
<span class="line"><span>    private Node&lt;T&gt; last;</span></span>
<span class="line"><span>    private int size;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void enqueue(T item) {</span></span>
<span class="line"><span>        Node&lt;T&gt; node = new Node&lt;&gt;(item, null);</span></span>
<span class="line"><span>        if (isEmpty()) {</span></span>
<span class="line"><span>            first = node; //当队列为空，first和last指向同一个元素</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            last.setNext(node);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        last = node;</span></span>
<span class="line"><span>        size++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public T dequeue() {</span></span>
<span class="line"><span>        T item = first.getItem();</span></span>
<span class="line"><span>        first = first.getNext();</span></span>
<span class="line"><span>        if (isEmpty()) { //当队列为空时，需要把last设置为null</span></span>
<span class="line"><span>            last = null;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        size--;</span></span>
<span class="line"><span>        return item;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public int size() {</span></span>
<span class="line"><span>        return this.size;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean isEmpty() {</span></span>
<span class="line"><span>        return first == null;  //首节点为空</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public Iterator&lt;T&gt; iterator() {</span></span>
<span class="line"><span>        return new Iterator&lt;T&gt;() {</span></span>
<span class="line"><span>            private Node&lt;T&gt; current = first;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public boolean hasNext() {</span></span>
<span class="line"><span>                return current != null;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            public T next() {</span></span>
<span class="line"><span>                T item = current.getItem();</span></span>
<span class="line"><span>                current = current.getNext();</span></span>
<span class="line"><span>                return item;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-胃开的差不多了-来聊一点算法吧-你来设计一个算法对算术表示式求值-比如-1-2-3-4-5" tabindex="-1">面试官：胃开的差不多了，来聊一点算法吧；你来设计一个算法对算术表示式求值，比如：<code>( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )</code> <a class="header-anchor" href="#面试官-胃开的差不多了-来聊一点算法吧-你来设计一个算法对算术表示式求值-比如-1-2-3-4-5" aria-label="Permalink to &quot;面试官：胃开的差不多了，来聊一点算法吧；你来设计一个算法对算术表示式求值，比如：`( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )`&quot;">​</a></h4><p>我：（昨天晚上熬夜看算法没白辛苦啊，刚好看到了这个解法。）</p><p>我：（挠挠头），这个问题有点麻烦，我需要思考一会。(这样显得我是没有提前准备的，属于临场发挥)</p><p>我：定义两个栈，一个用于保存运算符，一个用户保存操作数；具体的操作过程如下：</p><ul><li>忽略左边括号</li><li>遇到数字就压入操作数栈</li><li>遇到符号就压入符号栈</li><li>遇到右括号，弹出一个运算符，弹出所需要的操作数，将计算的结果再次压入到操作数栈</li></ul><p><img src="https://raw.githubusercontent.com/silently9527/images/main/8f2ff41a51bf41128f0c11239a10d8d2%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static int calculate(String expression) {</span></span>
<span class="line"><span>    Stack&lt;String&gt; operate = new LinkedListStack&lt;&gt;();</span></span>
<span class="line"><span>    Stack&lt;Integer&gt; numbers = new LinkedListStack&lt;&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    String[] split = expression.split(&quot; &quot;);</span></span>
<span class="line"><span>    for (String str : split) {</span></span>
<span class="line"><span>        if (&quot;(&quot;.equals(str)) {</span></span>
<span class="line"><span>        } else if (&quot;+&quot;.equals(str) || &quot;-&quot;.equals(str) || &quot;*&quot;.equals(str) || &quot;/&quot;.equals(str)) {</span></span>
<span class="line"><span>            operate.push(str);</span></span>
<span class="line"><span>        } else if (&quot;)&quot;.equals(str)) {</span></span>
<span class="line"><span>            String op = operate.pop();</span></span>
<span class="line"><span>            int resut = 0;</span></span>
<span class="line"><span>            if (&quot;+&quot;.equals(op)) {</span></span>
<span class="line"><span>                resut = numbers.pop() + numbers.pop();</span></span>
<span class="line"><span>            } else if (&quot;-&quot;.equals(op)) {</span></span>
<span class="line"><span>                resut = numbers.pop() - numbers.pop();</span></span>
<span class="line"><span>            } else if (&quot;*&quot;.equals(op)) {</span></span>
<span class="line"><span>                resut = numbers.pop() * numbers.pop();</span></span>
<span class="line"><span>            } else if (&quot;/&quot;.equals(op)) {</span></span>
<span class="line"><span>                resut = numbers.pop() / numbers.pop();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            numbers.push(resut);</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            numbers.push(Integer.valueOf(str));</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return numbers.pop();</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-一个int类型的数组-其中存在三个数字相加等于0-你来设计个算法帮我统计出有多少组这样的数字" tabindex="-1">面试官：一个int类型的数组，其中存在三个数字相加等于0，你来设计个算法帮我统计出有多少组这样的数字 <a class="header-anchor" href="#面试官-一个int类型的数组-其中存在三个数字相加等于0-你来设计个算法帮我统计出有多少组这样的数字" aria-label="Permalink to &quot;面试官：一个int类型的数组，其中存在三个数字相加等于0，你来设计个算法帮我统计出有多少组这样的数字&quot;">​</a></h4><p>我：这个简单，请看代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static int count1(int[] arr) {</span></span>
<span class="line"><span>    int length = arr.length;</span></span>
<span class="line"><span>    int count = 0;</span></span>
<span class="line"><span>    for (int i = 0; i &lt; length; i++) {</span></span>
<span class="line"><span>        for (int j = i + 1; j &lt; length; j++) {</span></span>
<span class="line"><span>            for (int k = j + 1; k &lt; length; k++) {</span></span>
<span class="line"><span>                if (arr[i] + arr[j] + arr[k] == 0) {</span></span>
<span class="line"><span>                    count++;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return count;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="面试官-假如这个数组有100万的int值-你这个算法得运行到什么时候" tabindex="-1">面试官：假如这个数组有100万的int值，你这个算法得运行到什么时候 <a class="header-anchor" href="#面试官-假如这个数组有100万的int值-你这个算法得运行到什么时候" aria-label="Permalink to &quot;面试官：假如这个数组有100万的int值，你这个算法得运行到什么时候&quot;">​</a></h4><p>我：（对的哦，这个算法的时间复杂度是O(n³)，在遇到数据量较大时效率极低）</p><p><img src="https://raw.githubusercontent.com/silently9527/images/main/144333dcdc8f4a45ac92198bb256e391%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>（经过大脑快速思考后）</p><p>我：这个算法确实有问题，我大意了，没有考虑到大量数据的情况；用这个算法会浪费小姐姐的大好青春，所以刚才我思考了下，对这个算法进行改进一下；</p><p>首先把<code>3-sum</code>简化成<code>2-sum</code>。</p><p>在<code>2-sum</code>中，一个数a[i]要与另一个数相加等于0；有两种方法：</p><p>第一种：与3-sum实现类似使用两层循环，时间复杂度是O(n²)</p><p>第二种：只需要找出数组中是否有-a[i]，查找的算法使用二分查找法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static int count2(int[] arr) {</span></span>
<span class="line"><span>    Arrays.sort(arr); //首先排序</span></span>
<span class="line"><span>    int length = arr.length;</span></span>
<span class="line"><span>    int count = 0;</span></span>
<span class="line"><span>    for (int i = 0; i &lt; length; i++) {</span></span>
<span class="line"><span>        if (BinarySearch.search(-arr[i], arr) &gt; i) {</span></span>
<span class="line"><span>            count++;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return count;</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>二分查找法的时间复杂度是O(log n), 实现<code>2-sum</code>的算法多了一层循环，所以时间复杂度O(nlog n)</p></blockquote><p><img src="https://raw.githubusercontent.com/silently9527/images/main/556f56178db44b33a648980fc20c6834%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>对待<code>3-sum</code>也是用类似的方法，直接上机撸代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static int count3(int[] arr) {</span></span>
<span class="line"><span>    Arrays.sort(arr);</span></span>
<span class="line"><span>    int length = arr.length;</span></span>
<span class="line"><span>    int count = 0;</span></span>
<span class="line"><span>    for (int i = 0; i &lt; length; i++) {</span></span>
<span class="line"><span>        for (int j = i + 1; j &lt; length; j++) {</span></span>
<span class="line"><span>            if (BinarySearch.search(-arr[i]-arr[j], arr) &gt; j) {</span></span>
<span class="line"><span>                count++;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return count;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>我：小姐姐，这个算法改进之后的时间复杂度是O(n²log n)，我已经尽力了，只能这么快了。（面试官露出迷人的微笑）</p><p><img src="https://raw.githubusercontent.com/silently9527/images/main/c5a981e7af6d4a3a85cfb605b8945c63%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="面试官-假如你是微信的开发人员-随便给你两个用户-如何判断这两个用户是否连通的。何为连通-a是b的好友-b是c的好友-那么a与c就是连通的" tabindex="-1">面试官：假如你是微信的开发人员，随便给你两个用户，如何判断这两个用户是否连通的。何为连通？A是B的好友，B是C的好友，那么A与C就是连通的 <a class="header-anchor" href="#面试官-假如你是微信的开发人员-随便给你两个用户-如何判断这两个用户是否连通的。何为连通-a是b的好友-b是c的好友-那么a与c就是连通的" aria-label="Permalink to &quot;面试官：假如你是微信的开发人员，随便给你两个用户，如何判断这两个用户是否连通的。何为连通？A是B的好友，B是C的好友，那么A与C就是连通的&quot;">​</a></h4><p>我：（这小姐姐的问题是越来越难了）</p><p>我：美丽的面试官，今天烧脑严重，我可以趴下休息一会吗？（其实是没想到好的解法，拖延时间战术）</p><p>面试官：可以，那你先休息10分钟。</p><p><strong>面试未完，待续</strong></p></div></div></main><footer class="VPDocFooter" data-v-68d915de data-v-d11a02ef><!--[--><!--]--><div class="edit-info" data-v-d11a02ef><!----><div class="last-updated" data-v-d11a02ef><div class="py-1 text-sm font-medium" data-v-d11a02ef> 📝 Last updated: 2024-07-16 21:34</div></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d11a02ef><span class="visually-hidden" id="doc-footer-aria-label" data-v-d11a02ef>Pager</span><div class="pager" data-v-d11a02ef><a class="VPLink link pager-link prev" href="/Notes/Algorithms/01%20%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95Java%E7%89%88%E5%AE%9E%E7%8E%B0.html" data-v-d11a02ef><!--[--><span class="desc" data-v-d11a02ef>Previous page</span><span class="title" data-v-d11a02ef>01 一致性Hash算法Java版实现</span><!--]--></a></div><div class="pager" data-v-d11a02ef><a class="VPLink link pager-link next" href="/Notes/Algorithms/03%20%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%B8%A4%E4%B8%AA%E4%BA%BA%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%8B%E5%8F%8B%E5%85%B3%E7%B3%BB%EF%BC%88union-find%E7%AE%97%E6%B3%95%EF%BC%89.html" data-v-d11a02ef><!--[--><span class="desc" data-v-d11a02ef>Next page</span><span class="title" data-v-d11a02ef>03 如何检测社交网络中两个人是否是朋友关系（union-find算法）</span><!--]--></a></div></nav></footer><!--[--><!--[--><!--[--><div id="comment-container"></div><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="relative px-6 pt-8 pb-4 text-center border-t dark:border-zinc-800 sm:pt-8 text-black/40 dark:text-zinc-300/40" data-v-bf383e74><p class="text-sm font-medium">Copyright © 2023-present Herman</p><p class="text-sm font-medium"> Theme | <a href="https://github.com/ZbWeR/easy-vitepress-blog">easy-vitepress-blog</a></p></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"aboutme.md\":\"BTl8jkos\",\"friends.md\":\"DwNOd4q_\",\"index.md\":\"4epCO0Dd\",\"notes_algorithms_01 一致性hash算法java版实现.md\":\"DcXAymxp\",\"notes_algorithms_02 老哥确定不来复习下数据结构吗.md\":\"Ceg2jCP8\",\"notes_algorithms_03 如何检测社交网络中两个人是否是朋友关系（union-find算法）.md\":\"BZEssXwm\",\"notes_algorithms_04 常见的初级排序算法，这次全搞懂.md\":\"BRzmhF4z\",\"notes_algorithms_05 死磕归并排序算法.md\":\"Dp1JG7cS\",\"notes_algorithms_06 快速排序算法实现及优化.md\":\"Dt_y1AGU\",\"notes_algorithms_07 原来实现优先级队列如此简单.md\":\"GEdQu9jH\",\"notes_algorithms_08 图解堆排序.md\":\"IqWyYh89\",\"notes_algorithms_09 基于数组或链表实现map.md\":\"CJk0NOkw\",\"notes_algorithms_10 基于二叉树实现map.md\":\"BPnV2Itn\",\"notes_algorithms_11 硬核图解红黑树并手写实现.md\":\"Dsk-Ggqo\",\"notes_algorithms_12 基于拉链式和线性探测式散列表实现map.md\":\"Yx-OrKVN\",\"notes_algorithms_13 图算法系列之无向图的数据结构.md\":\"nEbOMiBX\",\"notes_algorithms_14 图算法系列之深度优先搜索一.md\":\"D5tSYeCM\",\"notes_algorithms_15 图算法系列之深度优先搜索二.md\":\"LRIKV-qA\",\"notes_algorithms_16 图算法系列之计算图中最短路径.md\":\"DR7BrFQb\",\"notes_algorithms_index.md\":\"P3HIXQo_\",\"notes_index.md\":\"Bl3GBXyn\",\"notes_mysql_01 mysql的安装教程以及开启远程访问.md\":\"Cwk3rRto\",\"notes_mysql_02 innodb行记录存储结构-mysql系列01innodb行记录存储结构.md\":\"CDImxUA7\",\"notes_mysql_index.md\":\"BuI-xDmo\",\"notes_thoughts_index.md\":\"CPBnaq7_\",\"projects.md\":\"QkSCG1kn\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Herman's Notes\",\"titleTemplate\":\"Herman\",\"description\":\"Herman's Notes: 个人技术知识库，记录 & 分享个人碎片化、结构化、体系化的技术知识内容。\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/favicon.ico\",\"nav\":[{\"text\":\"💭 Notes\",\"link\":\"/Notes/index\"},{\"text\":\"🦄 Projects\",\"link\":\"Projects.md\"},{\"text\":\"👫 Friends\",\"link\":\"Friends.md\"},{\"text\":\"👋 About\",\"link\":\"AboutMe.md\"}],\"sidebar\":{\"/Notes/\":{\"text\":\"Notes\",\"items\":[{\"text\":\"🎨 卧学算法\",\"items\":[{\"title\":\"01 一致性Hash算法Java版实现\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"一致性Hash算法Java版实现\",\"categories\":\"算法\",\"tags\":\"算法/一致性hash\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/01 一致性Hash算法Java版实现\",\"text\":\"01 一致性Hash算法Java版实现\"},{\"title\":\"02 老哥确定不来复习下数据结构吗\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"老哥确定不来复习下数据结构吗\",\"categories\":\"算法\",\"tags\":\"数据结构/堆栈\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/02 老哥确定不来复习下数据结构吗\",\"text\":\"02 老哥确定不来复习下数据结构吗\"},{\"title\":\"03 如何检测社交网络中两个人是否是朋友关系（union-find算法）\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"如何检测社交网络中两个人是否是朋友关系（union-find算法）\",\"categories\":\"算法\",\"tags\":\"数据结构/union-find算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/03 如何检测社交网络中两个人是否是朋友关系（union-find算法）\",\"text\":\"03 如何检测社交网络中两个人是否是朋友关系（union-find算法）\"},{\"title\":\"04 常见的初级排序算法，这次全搞懂\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"常见的初级排序算法，这次全搞懂\",\"categories\":\"算法\",\"tags\":\"数据结构/排序算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/04 常见的初级排序算法，这次全搞懂\",\"text\":\"04 常见的初级排序算法，这次全搞懂\"},{\"title\":\"05 死磕归并排序算法\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"死磕归并排序算法\",\"categories\":\"算法\",\"tags\":\"数据结构/排序算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/05 死磕归并排序算法\",\"text\":\"05 死磕归并排序算法\"},{\"title\":\"06 快速排序算法实现及优化\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"快速排序算法实现及优化\",\"categories\":\"算法\",\"tags\":\"数据结构/排序算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/06 快速排序算法实现及优化\",\"text\":\"06 快速排序算法实现及优化\"},{\"title\":\"07 原来实现优先级队列如此简单\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"原来实现优先级队列如此简单\",\"categories\":\"算法\",\"tags\":\"数据结构/二叉堆\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/07 原来实现优先级队列如此简单\",\"text\":\"07 原来实现优先级队列如此简单\"},{\"title\":\"08 图解堆排序\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"图解堆排序\",\"categories\":\"算法\",\"tags\":\"数据结构/排序算法/堆排序\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/08 图解堆排序\",\"text\":\"08 图解堆排序\"},{\"title\":\"09 基于数组或链表实现Map\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"基于数组或链表实现Map\",\"categories\":\"算法\",\"tags\":\"数据结构/排序算法/堆排序\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/09 基于数组或链表实现Map\",\"text\":\"09 基于数组或链表实现Map\"},{\"title\":\"10 基于二叉树实现Map\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"基于二叉树实现Map\",\"categories\":\"算法\",\"tags\":\"数据结构/二叉树\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/10 基于二叉树实现Map\",\"text\":\"10 基于二叉树实现Map\"},{\"title\":\"11 硬核图解红黑树并手写实现\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"硬核图解红黑树并手写实现\",\"categories\":\"算法\",\"tags\":\"数据结构/红黑树\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/11 硬核图解红黑树并手写实现\",\"text\":\"11 硬核图解红黑树并手写实现\"},{\"title\":\"12 基于拉链式和线性探测式散列表实现Map\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"基于拉链式和线性探测式散列表实现Map\",\"categories\":\"算法\",\"tags\":\"数据结构/线性探索式/拉链式/HashMap\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/12 基于拉链式和线性探测式散列表实现Map\",\"text\":\"12 基于拉链式和线性探测式散列表实现Map\"},{\"title\":\"13 图算法系列之无向图的数据结构\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"图算法系列之无向图的数据结构\",\"categories\":\"算法\",\"tags\":\"数据结构/图算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/13 图算法系列之无向图的数据结构\",\"text\":\"13 图算法系列之无向图的数据结构\"},{\"title\":\"14 图算法系列之深度优先搜索（一）\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"图算法系列之深度优先搜索（一）\",\"categories\":\"算法\",\"tags\":\"数据结构/深度优先搜索/图算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/14 图算法系列之深度优先搜索一\",\"text\":\"14 图算法系列之深度优先搜索（一）\"},{\"title\":\"15 图算法系列之深度优先搜索（二）\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"图算法系列之深度优先搜索（二）\",\"categories\":\"算法\",\"tags\":\"数据结构/深度优先搜索/图算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/15 图算法系列之深度优先搜索二\",\"text\":\"15 图算法系列之深度优先搜索（二）\"},{\"title\":\"17 图算法系列之计算图中最短路径\",\"author\":\"Herman\",\"updateTime\":\"2024-07-16 21:34\",\"desc\":\"图算法系列之计算图中最短路径\",\"categories\":\"算法\",\"tags\":\"数据结构/广度优先搜索/图算法\",\"outline\":\"deep\",\"link\":\"/Notes/Algorithms/16 图算法系列之计算图中最短路径\",\"text\":\"17 图算法系列之计算图中最短路径\"}],\"collapsed\":false,\"link\":\"/Notes/Algorithms/index\",\"editLink\":false,\"lastUpdated\":false,\"showComment\":false},{\"text\":\"📊 Mysql数据库\",\"items\":[{\"title\":\"01 Mysql的安装及开启远程访问\",\"author\":\"Herman\",\"updateTime\":\"2024-08-11 21:34\",\"desc\":\"本篇文章主要记录两种MySQL的安装方式，以及如何重置用户登陆密码，如何开启远程访问\",\"categories\":\"数据库\",\"tags\":\"mysql\",\"outline\":\"deep\",\"link\":\"/Notes/Mysql/01 Mysql的安装教程以及开启远程访问\",\"text\":\"01 Mysql的安装及开启远程访问\"},{\"title\":\"02 InnoDB行记录存储结构\",\"author\":\"Herman\",\"updateTime\":\"2024-08-11 21:34\",\"desc\":\"InnoDB行记录存储结构\",\"categories\":\"数据库\",\"tags\":\"MySQL | InnoDB | InnoDB行记录\",\"outline\":\"deep\",\"link\":\"/Notes/Mysql/02 InnoDB行记录存储结构-mysql系列01innodb行记录存储结构\",\"text\":\"02 InnoDB行记录存储结构\"}],\"collapsed\":false,\"link\":\"/Notes/Mysql/index\",\"editLink\":false,\"lastUpdated\":false,\"showComment\":false}]}},\"search\":{\"provider\":\"local\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/silently9527\"}],\"footer\":{\"copyright\":\"Copyright © 2023-present Herman\"},\"outlineTitle\":\"导航栏\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>